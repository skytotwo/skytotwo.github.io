<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skytotwo.github.io/</id>
    <title>Totoro の Home</title>
    <updated>2019-08-05T04:10:19.062Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skytotwo.github.io/"/>
    <link rel="self" href="https://skytotwo.github.io//atom.xml"/>
    <subtitle>空杯心态，每天进步</subtitle>
    <logo>https://skytotwo.github.io//images/avatar.png</logo>
    <icon>https://skytotwo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Totoro の Home</rights>
    <entry>
        <title type="html"><![CDATA[Scrapy Item Loaders机制详解]]></title>
        <id>https://skytotwo.github.io//post/scrapy-item-loaders</id>
        <link href="https://skytotwo.github.io//post/scrapy-item-loaders">
        </link>
        <updated>2019-08-05T04:03:20.000Z</updated>
        <summary type="html"><![CDATA[<p>scrapy中的item其实设计上使用的是面向对象的模式，将爬取的数据字段组合封装，进一步交由管道处理存储，这里对其机制做相关讲解。</p>
]]></summary>
        <content type="html"><![CDATA[<p>scrapy中的item其实设计上使用的是面向对象的模式，将爬取的数据字段组合封装，进一步交由管道处理存储，这里对其机制做相关讲解。</p>
<!-- more -->
<h4 id="1-items"><strong>1. Items</strong></h4>
<p>爬虫的主要任务就是从非结构化的数据中获得结构化的数据。<br>
Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。</p>
<p><strong>声明Item</strong><br>
Item使用简单的class定义语法以及 Field 对象来声明。例如:</p>
<pre><code class="language-python">import scrapy

class Product(scrapy.Item):
    name = scrapy.Field()
    price = scrapy.Field()
    stock = scrapy.Field()
    last_updated = scrapy.Field(serializer=str)
</code></pre>
<p><strong>Item字段：</strong><br>
Field 对象指明了每个字段的元数据(metadata)。例如上面例子中 last_updated 中指明了该字段的序列化函数。</p>
<p>可以为每个字段指明任何类型的元数据。Field 对象对接受的值没有任何限制。Field 对象中保存的每个键可以由多个组件使用，并且只有这些组件知道这个键的存在。设置 Field 对象的主要目的就是在一个地方定义好所有的元数据。</p>
<p>需要注意的是，用来声明item的 Field 对象并没有被赋值为class的属性。 不过您可以通过 Item.fields 属性进行访问。</p>
<h4 id="2-用item-loader来填充item"><strong>2. 用Item Loader来填充Item</strong></h4>
<p>Item Loaders提供了一种便捷的方式填充抓取到的 Items 。 虽然Items可以使用自带的类字典形式API填充，但是Items Loaders提供了更便捷的API， 可以分析原始数据并对Item进行赋值。</p>
<p>从另一方面来说， Items 提供保存抓取数据的 容器 ， 而 Item Loaders提供的是 填充 容器的机制。</p>
<p>Item Loaders提供的是一种灵活，高效的机制，可以更方便的被spider或source format (HTML, XML, etc)扩展，并override更易于维护的、不同的内容分析规则。</p>
<p>要使用Item Loader, 你必须先将它实例化. 可以使用类似字典的对象来进行实例化, 或者不使用对象也可以, 当不用对象进行实例化的时候,Item会自动使用 ItemLoader.default_item_class 属性中指定的Item 类在Item Loader constructor中实例化.</p>
<p>然后,你开始收集数值到Item Loader时,通常使用 Selectors. 你可以在同一个item field 里面添加多个数值;Item Loader将知道如何用合适的处理函数来“添加”这些数值.</p>
<p>下面是在 Spider 中典型的Item Loader的用法, 使用 Items chapter 中声明的 Product item:</p>
<pre><code class="language-python">from scrapy.contrib.loader import ItemLoader
from myproject.items import Product

def parse(self, response):
    l = ItemLoader(item=Product(), response=response)
    l.add_xpath('name', '//div[@class=&quot;product_name&quot;]')
    l.add_xpath('name', '//div[@class=&quot;product_title&quot;]')
    l.add_xpath('price', '//p[@id=&quot;price&quot;]')
    l.add_css('stock', 'p#stock]')
    l.add_value('last_updated', 'today') # you can also use literal values
    return l.load_item()
</code></pre>
<p>我们可以看到发现 name 字段被从页面中两个不同的XPath位置提取:</p>
<pre><code class="language-python">//div[@class=&quot;product_name&quot;]
//div[@class=&quot;product_title&quot;]
</code></pre>
<p>换言之,数据通过用 add_xpath() 的方法,把从两个不同的XPath位置提取的数据收集起来. 这是将在以后分配给 name 字段中的数据｡</p>
<p>之后,类似的请求被用于 price 和 stock 字段 (后者使用 CSS selector 和 add_css() 方法), 最后使用不同的方法 add_value() 对 last_update 填充文本值( today ).</p>
<p>最终, 当所有数据被收集起来之后, 调用 ItemLoader.load_item() 方法, 实际上填充并且返回了之前通过调用 add_xpath(), add_css(), and add_value() 所提取和收集到的数据的Item.</p>
<h4 id="3-输入处理器与输出处理器"><strong>3. 输入处理器与输出处理器</strong></h4>
<ol>
<li>Item Loader在每个字段中都包含了一个输入处理器和一个输出处理器｡</li>
<li>输入处理器收到数据时立刻提取数据 (通过 add_xpath(), add_css() 或者 add_value() 方法) 之后输入处理器的结果被收集起来并且保存在ItemLoader内(但尚未分配给该Item).</li>
<li>收集到所有的数据后, 调用 ItemLoader.load_item() 方法来填充,并得到填充后的 Item 对象。在这一步中先调用输出处理器来处理之前收集到的数据，然后再存入Item中。输出处理器的结果是被分配到Item的最终值｡</li>
</ol>
<p>需要注意的是，输入和输出处理器都是可调用对象，调用时传入需要被分析的数据， 处理后返回分析得到的值。因此你可以使用任意函数作为输入、输出处理器。 唯一需注意的是它们必须接收一个（并且只是一个）迭代器性质的positional参数。</p>
<h4 id="4-声明items-loaders"><strong>4. 声明Items Loaders</strong></h4>
<p>Item Loaders 的声明类似于Items，以class的语法来声明：</p>
<pre><code class="language-python">from scrapy.contrib.loader import ItemLoader
from scrapy.contrib.loader.processor import TakeFirst, MapCompose, Join

class ProductLoader(ItemLoader):
    default_output_processor = TakeFirst()
    name_in = MapCompose(unicode.title)
    name_out = Join()
    price_in = MapCompose(unicode.strip)
    # ...
</code></pre>
<p>input processors 以_in为后缀来声明，output processors 以_out 为后缀来声明。也可以用ItemLoader.default_input_processor 和ItemLoader.default_output_processor 属性来声明默认的 input/output processors。</p>
<h4 id="5-声明input-and-output-processors"><strong>5. 声明Input and Output Processors</strong></h4>
<p>前面讲到，input and output processors可以在定义Item Loaders的时候声明，这是非常普遍的使用方法。但是，你也可以在定义Item的时候声明输入输出处理器。下面是例子：</p>
<pre><code class="language-python">import scrapy
from scrapy.contrib.loader.processor import Join, MapCompose, TakeFirst
from w3lib.html import remove_tags

def filter_price(value):
    if value.isdigit():
        return value

class ProductItem(scrapy.Item):
    name = scrapy.Field(
        input_processor=MapCompose(remove_tags),
        output_processor=Join(),
    )
    price = scrapy.Field(
        input_processor=MapCompose(remove_tags, filter_price),
        output_processor=TakeFirst(),
    )
</code></pre>
<p>使用Item：</p>
<pre><code class="language-bash">&gt;&gt;&gt; from scrapy.contrib.loader import ItemLoader
&gt;&gt;&gt; il = ItemLoader(item=Product())
&gt;&gt;&gt; il.add_value('name', [u'Welcome to my', u'&lt;strong&gt;website&lt;/strong&gt;'])
&gt;&gt;&gt; il.add_value('price', [u'€', u'&lt;span&gt;1000&lt;/span&gt;'])
&gt;&gt;&gt; il.load_item()
{'name': u'Welcome to my website', 'price': u'1000'}
</code></pre>
<p>关于集中声明 input and output processors方式的优先级排序如下：</p>
<ol>
<li>在Item Loader 中声明的 field-specific 属性: field_in and field_out (most precedence)</li>
<li>Item中的字段元数据(input_processor and output_processor key)</li>
<li>Item Loader 默认处理器: ItemLoader.default_input_processor() and ItemLoader.default_output_processor() (least precedence)</li>
</ol>
<h4 id="6-item-loader-context"><strong>6. Item Loader Context</strong></h4>
<p>Item Loader Context 是一个被Item Loader中的输入输出处理器共享的任意的键值对字典。它能在Item Loader声明、实例化、使用的时候传入。它用于调整输入输出处理器的行为。</p>
<p>举例来讲，函数parse_length用于接收text值并且获取其长度：</p>
<pre><code class="language-python">def parse_length(text, loader_context):
    unit = loader_context.get('unit', 'm')
    # ... length parsing code goes here ... 
    return parsed_length
</code></pre>
<p>通过接收一个loader_context参数，这个函数告诉Item Loader它能够接收Item Loader context。于是当函数被调用的时候Item Loader传递当前的active context给它。</p>
<p>有多种方式改变Item Loader context的值：</p>
<ol>
<li>
<p>修改当前 active Item Loader context：</p>
<p>loader = ItemLoader(product)<br>
loader.context[‘unit’] = ‘cm’</p>
</li>
<li>
<p>在Item Loader实例化的时候：</p>
<p>loader = ItemLoader(product, unit=’cm’)</p>
</li>
<li>
<p>对于那些支持带Item Loader context实例化的输入输出处理器（例如MapCompose），在Item Loader声明的时候修改它context：</p>
<pre><code class="language-python">class ProductLoader(ItemLoader): 
length_out = MapCompose(parse_length, unit=’cm’)
</code></pre>
</li>
</ol>
<h4 id="7-itemloader-object"><strong>7. ItemLoader object</strong></h4>
<p>参见官方文档</p>
<h4 id="8-重用和扩展item-loaders"><strong>8. 重用和扩展Item Loaders</strong></h4>
<p>当你的项目逐渐变大，使用了越来越多的spider的时候，维护变成了一个基本的问题。尤其是当你需要处理每个spider的许多不同的解析规则的时候，会出现很多的异常，迫使你开始考虑重用的问题。</p>
<p>Item Loader支持传统的Python继承机制来处理spider之间的差异。</p>
<p>例如，有些网站把它们的产Product名用三个短线封装起来（如：---Plasma TV---），而你想要去掉这些东西。</p>
<p>你可以通过reusing and extending默认Product Item Loader的方式去掉短线：</p>
<pre><code class="language-python">from scrapy.loader.processors import MapCompose
from myproject.ItemLoaders import ProductLoader

def strip_dashes(x):
    return x.strip('-')

class SiteSpecificLoader(ProductLoader):
    name_in = MapCompose(strip_dashes, ProductLoader.name_in)
</code></pre>
<p>另一种情形时继承Item Loader也很有用：有多种格式的源数据（如XML, HTML），在XML版本里面你想要去除CDATA:</p>
<pre><code class="language-python">from scrapy.loader.processors import MapCompose
from myproject.ItemLoaders import ProductLoader
from myproject.utils.xml import remove_cdata

class XmlProductLoader(ProductLoader):
    name_in = MapCompose(remove_cdata, ProductLoader.name_in)
</code></pre>
<p>这便是扩展输入处理器的方法。</p>
<ul>
<li>
<p>对于输出处理器，更常用的方式是在Item字段元数据里声明。因为通常它们依赖于具体的字段而不是网站。</p>
</li>
<li>
<p>还有很多其他方式开扩展、继承和覆盖Item Loader，不同的层次结构适于不同的项目。Scrapy只是提供了这些机制，不强制要求具体的组织方式。</p>
</li>
</ul>
<h4 id="9-内置的处理器"><strong>9. 内置的处理器</strong></h4>
<p>尽管你可以使用可调用的函数作为输入输出处理器，Scrapy提供了一些常用的处理器。有些处理器，如MapCompose（通常用于输入处理器），能把多个函数执行的结果按顺序组合起来产生最终的输出。</p>
<p>下面是一些内置的处理器：</p>
<p><strong>9.1 Identity</strong></p>
<p>class scrapy.loader.processors.Identity<br>
最简单的处理器，不进行任何处理，直接返回原来的数据。无参数。</p>
<p><strong>9.2 TakeFirst</strong></p>
<p>class scrapy.loader.processors.TakeFirst<br>
返回第一个非空(non-null/non-empty)值，常用于单值字段的输出处理器。无参数。</p>
<p>示例如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; from scrapy.loader.processors import TakeFirst
&gt;&gt;&gt; proc = TakeFirst()
&gt;&gt;&gt; proc(['', 'one', 'two', 'three'])
'one'
</code></pre>
<p><strong>9.3 Join</strong></p>
<p>class scrapy.loader.processors.Join(separator=u’ ‘)<br>
返回用分隔符连接后的值。分隔符默认为空格。不接受Loader contexts。</p>
<p>当使用默认分隔符的时候，这个处理器等同于这个函数：</p>
<pre><code class="language-python">u' '.join
</code></pre>
<p>使用示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from scrapy.loader.processors import Join
&gt;&gt;&gt; proc = Join()
&gt;&gt;&gt; proc(['one', 'two', 'three'])
u'one two three'
&gt;&gt;&gt; proc = Join('&lt;br&gt;')
&gt;&gt;&gt; proc(['one', 'two', 'three'])
u'one&lt;br&gt;two&lt;br&gt;three'
</code></pre>
<p><strong>9.4 Compose</strong></p>
<p>class scrapy.loader.processors.Compose(*functions, **default_loader_context)<br>
用给定的多个函数的组合而构造的处理器。每个输入值被传递到第一个函数，然后其输出再传递到第二个函数，诸如此类，直到最后一个函数返回整个处理器的输出。</p>
<p>默认情况下，当遇到None值的时候停止处理。可以通过传递参数stop_on_none=False改变这种行为。</p>
<p>使用示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from scrapy.loader.processors import Compose
&gt;&gt;&gt; proc = Compose(lambda v: v[0], str.upper)
&gt;&gt;&gt; proc(['hello', 'world'])
'HELLO'
</code></pre>
<p>每个函数可以选择接收一个loader_context参数。</p>
<p><strong>9.5 MapCompose</strong></p>
<p>class scrapy.loader.processors.MapCompose(*functions, **default_loader_context)<br>
与Compose处理器类似，区别在于各个函数结果在内部传递的方式：</p>
<ol>
<li>
<p>输入值是被迭代的处理的，每一个元素被单独传入第一个函数进行处理。处理的结果被l连接起来(concatenate)形成一个新的迭代器，并被传入第二个函数，以此类推，直到最后一个函数。最后一个函数的输出被连接起来形成处理器的输出。</p>
</li>
<li>
<p>每个函数能返回一个值或者一个值列表，也能返回None(会被下一个函数所忽略)</p>
</li>
<li>
<p>这个处理器提供了方便的方式来组合多个处理单值的函数。因此它常用与输入处理器，因为用extract()函数提取出来的值是一个unicode strings列表。</p>
</li>
</ol>
<p>下面的例子能说明这个处理器的工作方式：</p>
<pre><code class="language-python">&gt;&gt;&gt; def filter_world(x):
...     return None if x == 'world' else x
...
&gt;&gt;&gt; from scrapy.loader.processors import MapCompose
&gt;&gt;&gt; proc = MapCompose(filter_world, unicode.upper)
&gt;&gt;&gt; proc([u'hello', u'world', u'this', u'is', u'scrapy'])
[u'HELLO, u'THIS', u'IS', u'SCRAPY']
</code></pre>
<p>与Compose处理器类似，它也能接受Loader context。</p>
<p><strong>9.6 SelectJmes</strong></p>
<p>class scrapy.loader.processors.SelectJmes(json_path)<br>
查询指定的JSON path并返回输出。需要jmespath(https://github.com/jmespath/jmespath.py)支持。每次接受一个输入。</p>
<p>示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from scrapy.loader.processors import SelectJmes, Compose, MapCompose
&gt;&gt;&gt; proc = SelectJmes(&quot;foo&quot;) #for direct use on lists and dictionaries
&gt;&gt;&gt; proc({'foo': 'bar'})
'bar'
&gt;&gt;&gt; proc({'foo': {'bar': 'baz'}})
{'bar': 'baz'}
</code></pre>
<p>与Json一起使用：</p>
<pre><code class="language-python">&gt;&gt;&gt; import json
&gt;&gt;&gt; proc_single_json_str = Compose(json.loads, SelectJmes(&quot;foo&quot;))
&gt;&gt;&gt; proc_single_json_str('{&quot;foo&quot;: &quot;bar&quot;}')
u'bar'
&gt;&gt;&gt; proc_json_list = Compose(json.loads, MapCompose(SelectJmes('foo')))
&gt;&gt;&gt; proc_json_list('[{&quot;foo&quot;:&quot;bar&quot;}, {&quot;baz&quot;:&quot;tar&quot;}]')
[u'bar']
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python中dict和set实现原理]]></title>
        <id>https://skytotwo.github.io//post/python-dict-set</id>
        <link href="https://skytotwo.github.io//post/python-dict-set">
        </link>
        <updated>2019-08-05T03:55:32.000Z</updated>
        <summary type="html"><![CDATA[<p>python的dict和set设计上是很巧妙的，底层是用c语言编写，哈希表实现，这样确保了高效的数据处理。</p>
]]></summary>
        <content type="html"><![CDATA[<p>python的dict和set设计上是很巧妙的，底层是用c语言编写，哈希表实现，这样确保了高效的数据处理。</p>
<!-- more --> 
<p>1、dict的性能远高于list<br>
2、list的查询消耗随着查询数量的增大而增大<br>
3、dict的查询消耗并不会随着查询数量的增大而增大</p>
<p><strong>dict内部实现是根据哈西表来实现的：</strong><br>
<img src="http://picture.totoro.site/images/2019/08/05/20180407100709_810.png" alt="20180407100709_810.png"></p>
<p>1、当申明dict变量的时候，就会在内存中开辟一个连续的数组空间。<br>
2、连续的空间是允许存在空白的，这是为了后续能够实现在原空间内插入数据。<br>
3、如果在后续插入数据的时候，发现原空间中空白的比例小于原空间的三分之一，就会再申请开辟一段连续啊的空间用于存储，将原有的数据搬迁出来和新的数据一起插入新的空间中。（这时候顺序会打乱）<br>
4、dict查找时，会根据key值计算出在hash表中的位置，hash表中的键值对位置是唯一的。计算的方式是根据key值的后一位组合元素进行计算，计算过程中如果发现hash表中已经存在值，就加上key值前一位进行计算，最终找出value值的位置。如下：<br>
<img src="http://picture.totoro.site/images/2019/08/05/20180407102108_979.png" alt="20180407102108_979.png"><br>
abc —— key ，根据c来计算位置，如果计算结果被别的值占据，则用bc来计算。</p>
<p>5、dict查找性能快的原因是，直接对key值进行hash计算，因为开辟的数组空间是连续的，有偏移量的，直接将偏移量返回，就能马上找到value值在哪里。</p>
<hr>
<p><strong>原理概要</strong><br>
1、dict或者set的值，都必须是可以hash的，不可变的值都是可以被hash的，如str、fronzenset、tuple，或者自己定义的类，实现了__hash__这个魔法方法的，都可以被hash。<br>
2、dict的内存花销大，但是查询速度快，自定义的对象或者python的内部对象都是用dict来包装的。<br>
3、dict的存储顺序和元素的添加顺序有关。<br>
4、添加数据有可能改变已有数据的顺序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序学习记要（上）]]></title>
        <id>https://skytotwo.github.io//post/wechat-miniapp-learning-mark</id>
        <link href="https://skytotwo.github.io//post/wechat-miniapp-learning-mark">
        </link>
        <updated>2019-08-05T03:49:54.000Z</updated>
        <summary type="html"><![CDATA[<p>几年前小程序火爆的时候，自己也跟着学习了一下，有许多小细节需要注意的，这里做一点记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>几年前小程序火爆的时候，自己也跟着学习了一下，有许多小细节需要注意的，这里做一点记录</p>
<!-- more -->
<p>1、图片等尺寸应该使用rpx自适应标准，素材应该选用iphone6作为标准。<br>
遵循原则是：1px（物理像素）=1rpx=0.5pt（逻辑像素）<br>
所以如果素材是750px，则编写尺寸则是750rpx。<br>
2、在页面布局中，横向元素应该使用rpx，纵向大部分情况下是使用px，因为横向拉伸效果明显，需要自适应。<br>
3、编写样式的时候，可以用class或者style。而其中规则是，一般静态的样式，不太会改变的样式就用class，一些动态的样式就用style，style每一次编译的时候都回去解析样式，性能上来说，所有都放在style里，性能会降低。<br>
4、要让元素隐藏，可以使用wx:if=&quot;false&quot;,false的值也可以从js中绑定过来，用{{false}}表示。<br>
5、数据绑定wx:for所传的对象的代称为“wx:for-item=item”。<br>
6、wx:for 循环需要放在block块中，如下：</p>
<pre><code class="language-xml">&lt;block wx:for=&quot;{{posts_key}}&quot;&gt;
    ......
&lt;/block&gt;
</code></pre>
<p>7、点击冒泡事件：除了submit等少数事件外，其余均符合冒泡事件。即触发子元素后，父元素也会被触发。如果不想触发父元素，可以不使用bind前缀，使用catch前缀。<br>
8、使用template模板的原因，是因为将循环代码块抽离，可以达到多个页面复用的效果，直接引入就可以使用。<br>
9、template模板在 wx:for 循环中的使用，传递数据可以直接data=&quot;{{item}}&quot;,如下：</p>
<pre><code class="language-xml">&lt;block wx:for=&quot;{{posts_key}}&quot;&gt;
    &lt;!-- template--&gt;
    &lt;template is=&quot;postItem&quot; data=&quot;{{item}}&quot;/&gt;
&lt;/block&gt;
</code></pre>
<p>10、以下是几种引入方式：<br>
js引入方式（必须是相对路径，不然会报错！）</p>
<pre><code class="language-javascript">var postsData = require('../../data/posts-data.js');
</code></pre>
<p>template在wxml中的引入（路径可以相对也可以绝对）</p>
<pre><code class="language-xml">&lt;import src=&quot;post-item/post-item-template.wxml&quot;/&gt;
</code></pre>
<p>样式文件在wxss中的引入</p>
<pre><code class="language-xml">@import &quot;post-item/post-item-template.wxss&quot;;
</code></pre>
<p>11、数据文件要让外部使用，需要在里面自定义一个接口，暴露出去，如下：</p>
<pre><code class="language-javascript">module.exports = {
  postList: local_database
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[附件上传至FTP和从FTP下载的代码]]></title>
        <id>https://skytotwo.github.io//post/upload-or-download-ftp</id>
        <link href="https://skytotwo.github.io//post/upload-or-download-ftp">
        </link>
        <updated>2019-08-05T03:42:49.000Z</updated>
        <summary type="html"><![CDATA[<p>之前用java做过福建上传ftp和从ftp下载文件的功能，这里做一下记录。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前用java做过福建上传ftp和从ftp下载文件的功能，这里做一下记录。</p>
<!-- more -->
<p>/<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>以下为附件上传至FTP和从FTP下载的代码</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>*****************************/</p>
<pre><code class="language-java">
/**  
* Description: 向SFTP服务器上传文件  
* @param host FTP服务器hostname  
* @param port FTP服务器端口  
* @param username FTP登录账号  
* @param password FTP登录密码  
* @param basePath FTP服务器基础目录 
* @param filePath FTP服务器文件存放路径。例如分日期存放：/2015/01/01。文件的路径为
* basePath+filePath 
* @param filename 上传到FTP服务器上的文件名  
* @param input 输入流  
* @return 成功返回true，否则返回false  
* @throws Exception 
* @author jolly	2017-12-1
*/    
public static boolean uploadFileToSFTP(String filename, HttpServletRequest request) throws Exception {  
	boolean result = false;  
	FTPClient ftp = new FTPClient();  
	Properties prop = new Properties();
	ResourceBundle resource = ResourceBundle
		.getBundle(&quot;tellhow/actions/ftp&quot;);// 读取ftp配置文件
	String host = resource.getString(&quot;HOST&quot;);
	int port = Integer.parseInt(resource.getString(&quot;PORT&quot;));
	String username = resource.getString(&quot;USERNAME&quot;);
	String password = resource.getString(&quot;PASSWORD&quot;);
	String filePath = resource.getString(&quot;FILEPATH&quot;);
	String localPath = request.getRealPath(&quot;/WebRoot/WEB-INF/upload/&quot;);
	try {  
		int reply;  
		ftp.connect(host, port);// 连接FTP服务器  
		// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器  
		boolean b = ftp.login(username, password);// 登录  
		if(!b){
			throw new Exception(&quot;登陆FTP不成功！&quot;);
		}
		reply = ftp.getReplyCode();  
		if (!FTPReply.isPositiveCompletion(reply)) {  
			ftp.disconnect();  
			return result;  
		}  
		File file = new File(localPath+filename);
		InputStream input = new FileInputStream(file);
		boolean t = ftp.changeWorkingDirectory(encoding(filePath));
		if(!t){
			ftp.mkd(encoding(filePath));
			ftp.changeWorkingDirectory(encoding(filePath));
		}
		//设置上传文件的类型为二进制类型  
		//ftp.setFileType(FTP.BINARY_FILE_TYPE);  
		boolean b2 = ftp.storeFile(encoding(filename), input);
		input.close();
		ftp.logout();
		if(!b2){
			throw new Exception(&quot;上传文件不成功！&quot;); 
		}
		result = true;  
	} catch (IOException e) {  
		e.printStackTrace();  
		throw new Exception(&quot;未能连接上Ftp服务器！&quot;);
	} finally {  
		if (ftp.isConnected()) {  
			try {  
				ftp.disconnect();  
			} catch (IOException ioe) {  
			}  
		} 
	}  
	return result;  
}  

/**  
* Description: 从FTP服务器下载文件  
* @param host FTP服务器hostname  
* @param port FTP服务器端口  
* @param username FTP登录账号  
* @param password FTP登录密码  
* @param remotePath FTP服务器上的相对路径  
* @param fileName 要下载的文件名  
* @param localPath 下载后保存到本地的路径  
* @return  
* @author jolly	2017-12-1
* @throws Exception 
*/    
public static boolean downloadFileFromFTP(String fileName, HttpServletRequest request) throws Exception {  
	boolean result = false;  
	FTPClient ftp = new FTPClient();  
	Properties prop = new Properties();
	ResourceBundle resource = ResourceBundle
		.getBundle(&quot;tellhow/actions/ftp&quot;);// 读取ftp配置文件
	String host = resource.getString(&quot;host&quot;);
	int port = Integer.parseInt(resource.getString(&quot;PORT&quot;));
	String username = resource.getString(&quot;USERNAME&quot;);
	String password = resource.getString(&quot;PASSWORD&quot;);
	String basePath = resource.getString(&quot;BASEPATH&quot;);
	String filePath = resource.getString(&quot;FILEPATH&quot;);
	String remotePath = resource.getString(&quot;REMOTEPATH&quot;);
	String localPath = request.getRealPath(&quot;/WebRoot/WEB-INF/upload&quot;);
	try {  
		int reply;  
		ftp.connect(host, port);  
		// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器  
		boolean b = ftp.login(username, password);// 登录  
		if(!b){
			throw new Exception(&quot;登陆FTP不成功！&quot;);
		}
		reply = ftp.getReplyCode();  
		if (!FTPReply.isPositiveCompletion(reply)) {  
			ftp.disconnect();  
			return result;  
		}  
		ftp.changeWorkingDirectory(remotePath);// 转移到FTP服务器目录  
		FTPFile[] fs = ftp.listFiles();  
		for (FTPFile ff : fs) {  
			if (ff.getName().equals(fileName)) {  
				File localFile = new File(localPath + &quot;/&quot; + ff.getName());  

				OutputStream is = new FileOutputStream(localFile);  
				ftp.retrieveFile(ff.getName(), is);  
				is.close();  
			}  
		}  

		ftp.logout();  
		result = true;  
	} catch (IOException e) {  
		e.printStackTrace();  
	} finally {  
		if (ftp.isConnected()) {  
			try {  
				ftp.disconnect();  
			} catch (IOException ioe) {  
			}  
		}  
	}  
	return result;  
} 


/**
* 编码转换
* @param obj
* @return
*/
private static String encoding(Object obj){
	try{
		if(obj==null)
			return &quot;&quot;;
		else
			return new String(obj.toString().getBytes(&quot;GBK&quot;),&quot;ISO-8859-1&quot;);
	}catch(Exception e){
		e.printStackTrace();
	}
	return &quot;&quot;; 
}

//删除文件，用于ftp上传完后删除本地临时文件夹文件
public void delFolder(String folderPath) {
	try {
		delAllFile(folderPath); // 删除完里面所有内容
	} catch (Exception e) {
		e.printStackTrace();
	}
}
// 删除指定文件夹下所有文件
// param path 文件夹完整绝对路径
public boolean delAllFile(String path) {
	boolean flag = false;
	File file = new File(path);
	if (!file.exists()) {
		return flag;
	}
	if (!file.isDirectory()) {
		return flag;
	}
	String[] tempList = file.list();
	File temp = null;
	for (int i = 0; i &lt; tempList.length; i++) {
		if (path.endsWith(File.separator)) {
			temp = new File(path + tempList[i]);
		} else {
			temp = new File(path + File.separator + tempList[i]);
		}
		if (temp.isFile()) {
			temp.delete();
		}
		if (temp.isDirectory()) {
			delAllFile(path + &quot;/&quot; + tempList[i]);// 先删除文件夹里面的文件
			flag = true;
		}
	}
	return flag;
}

public class SFTPConstants {
	public static final String SFTP_REQ_HOST = &quot;host&quot;;
	public static final String SFTP_REQ_PORT = &quot;port&quot;;
	public static final String SFTP_REQ_USERNAME = &quot;username&quot;;
	public static final String SFTP_REQ_PASSWORD = &quot;password&quot;;
	public static final int SFTP_DEFAULT_PORT = 22;
	public static final String SFTP_REQ_LOC = &quot;location&quot;;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js代码判断浏览器种类]]></title>
        <id>https://skytotwo.github.io//post/js-check-browser</id>
        <link href="https://skytotwo.github.io//post/js-check-browser">
        </link>
        <updated>2019-08-05T03:38:17.000Z</updated>
        <summary type="html"><![CDATA[<p>很多时候，前端需要对当前浏览器类型进行判断，进而触发不同的操作，这里使用js代码对浏览器的种类进行判断。</p>
]]></summary>
        <content type="html"><![CDATA[<p>很多时候，前端需要对当前浏览器类型进行判断，进而触发不同的操作，这里使用js代码对浏览器的种类进行判断。</p>
<!-- more -->
<p>第一种，只区分浏览器，不考虑版本<br>
复制代码 代码如下:</p>
<pre><code class="language-javascript">function myBrowser(){
    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
    var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1;
    if (isOpera) {
        return &quot;Opera&quot;
    }; //判断是否Opera浏览器
    if (userAgent.indexOf(&quot;Firefox&quot;) &gt; -1) {
        return &quot;FF&quot;;
    } //判断是否Firefox浏览器
    if (userAgent.indexOf(&quot;Chrome&quot;) &gt; -1){
  		return &quot;Chrome&quot;;
 	}
    if (userAgent.indexOf(&quot;Safari&quot;) &gt; -1) {
        return &quot;Safari&quot;;
    } //判断是否Safari浏览器
    if (userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera) {
        return &quot;IE&quot;;
    }; //判断是否IE浏览器
}
</code></pre>
<p>//以下是调用上面的函数</p>
<pre><code class="language-javascript">var mb = myBrowser();
if (&quot;IE&quot; == mb) {
    alert(&quot;我是 IE&quot;);
}
if (&quot;FF&quot; == mb) {
    alert(&quot;我是 Firefox&quot;);
}
if (&quot;Chrome&quot; == mb) {
    alert(&quot;我是 Chrome&quot;);
}
if (&quot;Opera&quot; == mb) {
    alert(&quot;我是 Opera&quot;);
}
if (&quot;Safari&quot; == mb) {
    alert(&quot;我是 Safari&quot;);
}
</code></pre>
<p>第二种，区分浏览器，并考虑IE5.5 6 7 8<br>
复制代码 代码如下:</p>
<pre><code class="language-javascript">function myBrowser(){
    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
    var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器
    var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器
    var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器
    var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1; //判断是否Safari浏览器
    if (isIE) {
        var IE5 = IE55 = IE6 = IE7 = IE8 = false;
        var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);
        reIE.test(userAgent);
        var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]);
        IE55 = fIEVersion == 5.5;
        IE6 = fIEVersion == 6.0;
        IE7 = fIEVersion == 7.0;
        IE8 = fIEVersion == 8.0;
        if (IE55) {
            return &quot;IE55&quot;;
        }
        if (IE6) {
            return &quot;IE6&quot;;
        }
        if (IE7) {
            return &quot;IE7&quot;;
        }
        if (IE8) {
            return &quot;IE8&quot;;
        }
    }//isIE end
    if (isFF) {
        return &quot;FF&quot;;
    }
    if (isOpera) {
        return &quot;Opera&quot;;
    }
}//myBrowser() end
</code></pre>
<p>//以下是调用上面的函数</p>
<pre><code class="language-javascript">if (myBrowser() == &quot;FF&quot;) {
    alert(&quot;我是 Firefox&quot;);
}
if (myBrowser() == &quot;Opera&quot;) {
    alert(&quot;我是 Opera&quot;);
}
if (myBrowser() == &quot;Safari&quot;) {
    alert(&quot;我是 Safari&quot;);
}
if (myBrowser() == &quot;IE55&quot;) {
    alert(&quot;我是 IE5.5&quot;);
}
if (myBrowser() == &quot;IE6&quot;) {
    alert(&quot;我是 IE6&quot;);
}
if (myBrowser() == &quot;IE7&quot;) {
    alert(&quot;我是 IE7&quot;);
}
if (myBrowser() == &quot;IE8&quot;) {
    alert(&quot;我是 IE8&quot;);
}
</code></pre>
<p>下面给出一个判断当前浏览器是IE的JS代码.<br>
原理是利用了IE与标准浏览器在处理数组的toString方法的差异做成的。对于标准游览器，如果数组里面最后一个字符为逗号，JS引擎会自动剔除它。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jsp实现导出word文档]]></title>
        <id>https://skytotwo.github.io//post/jsp-word-config</id>
        <link href="https://skytotwo.github.io//post/jsp-word-config">
        </link>
        <updated>2019-08-05T03:33:18.000Z</updated>
        <summary type="html"><![CDATA[<p>java中除了使用常规的库来实现到处word，excel外，可以在jsp里配置实现导出效果，实际上效果是一致的，这里记录下相关的配置。</p>
]]></summary>
        <content type="html"><![CDATA[<p>java中除了使用常规的库来实现到处word，excel外，可以在jsp里配置实现导出效果，实际上效果是一致的，这里记录下相关的配置。</p>
<!-- more -->
<p>1、设置response</p>
<pre><code class="language-javascript">response.setContentType(&quot;application/vnd.ms-word; charset=UTF-8&quot;);
response.setHeader(&quot;Pragma&quot;,&quot;No-Cache&quot;);
response.setHeader(&quot;Cache-Control&quot;,&quot;No-Cache&quot;);
response.setHeader(&quot;Content-disposition&quot;,&quot;attachment; filename=&quot;+URLEncoder.encode(nc+&quot;(&quot;+bh+&quot;)&quot;, &quot;UTF-8&quot;)+&quot;.doc&quot;);
</code></pre>
<p>2、html指定word</p>
<pre><code class="language-javascript">&lt;html  xmlns:w='urn:schemas-microsoft-com:office:word' &gt;
</code></pre>
<p>3、head里添加配置文件</p>
<pre><code class="language-xml">&lt;xml&gt;  
    &lt;w:WordDocument&gt;  
      &lt;w:View&gt;Print&lt;/w:View&gt;  
      &lt;w:DoNotOptimizeForBrowser/&gt;  
      &lt;w:Compatibility&gt;  
        &lt;w:DontGrowAutofit/&gt;  
      &lt;/w:Compatibility&gt;  
    &lt;/w:WordDocument&gt;  
&lt;/xml&gt; 
</code></pre>
<p>4、导出</p>
<pre><code class="language-javascript">$(&quot;table&quot;).attr(&quot;border&quot;,'0');
	window.print();
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django中 CSRF 理解 原理 及 使用]]></title>
        <id>https://skytotwo.github.io//post/django-csrf</id>
        <link href="https://skytotwo.github.io//post/django-csrf">
        </link>
        <updated>2019-08-05T03:25:42.000Z</updated>
        <summary type="html"><![CDATA[<p>Django的设计中同样考虑到了csrf攻击问题，对此，使用middleware中间件来实现相关功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django的设计中同样考虑到了csrf攻击问题，对此，使用middleware中间件来实现相关功能。</p>
<!-- more -->
<p>分类：<br>
django为用户实现防止跨站请求伪造的功能，通过中间件 django.middleware.csrf.CsrfViewMiddleware 来完成。而对于django中设置防跨站请求伪造功能有分为全局和局部。<br>
全局：<br>
中间件 django.middleware.csrf.CsrfViewMiddleware<br>
局部：<br>
@csrf_protect，为当前函数强制设置防跨站请求伪造功能，即便settings中没有设置全局中间件。<br>
@csrf_exempt，取消当前函数防跨站请求伪造功能，即便settings中设置了全局中间件。</p>
<p>Django中CSRF防护原理：<br>
在用户访问django的可信站点时，django反馈给用户的表单中有一个隐含字段csrftoken，这个值是在服务器端随机生成的，每一次提交表单都会生成不同的值。当用户提交django的表单时，服务器校验这个表单的csrftoken是否和自己保存的一致，来判断用户的合法性。当用户被csrf攻击从其他站点发送精心编制的攻击请求时，由于其他站点不可能知道隐藏的csrftoken字段的信息这样在服务器端就会校验失败，攻击被成功防御，这样就能避免被 CSRF 攻击。</p>
<ol>
<li>在返回的 HTTP 响应的 cookie 里，django 会为你添加一个 csrftoken 字段，其值为一个自动生成的 token</li>
<li>在所有的 POST 表单时，必须包含一个 csrfmiddlewaretoken 字段 （只需要在模板里加一个 tag， django 就会自动帮你生成，见下面）</li>
<li>在处理 POST 请求之前，django 会验证这个请求的 cookie 里的 csrftoken 字段的值和提交的表单里的 csrfmiddlewaretoken 字段的值是否一样。如果一样，则表明这是一个合法的请求，否则，这个请求可能是来自于别人的 csrf 攻击，返回 403 Forbidden.</li>
<li>在所有 ajax POST 请求里，添加一个 X-CSRFTOKEN header，其值为 cookie 里的 csrftoken 的值<br>
Django中使用 CSRF 防护</li>
<li>GET 请求不要用有副作用。任何处理 GET 请求的代码对资源的访问都一定要是“只读“的。</li>
<li>启用 django.middleware.csrf.CsrfViewMiddleware 中间件</li>
<li>使用POST 表单元素时，加上{% csrf_token %}</li>
<li>渲染模块使用 RequestContext。RequestContext 会处理 csrf_token , 从而自动为表单添加一个名为 csrfmiddlewaretoken 的 input<br>
Django中CSRF防护解析：</li>
</ol>
<p>csrftoken的生成方式如下：<br>
md5_constructor(&quot;%s%s&quot; % (randrange(0, _MAX_CSRF_KEY), settings.SECRET_KEY)).hexdigest()<br>
● 1<br>
设置csrftoken:<br>
response.set_cookie(settings.CSRF_COOKIE_NAME,request.META[&quot;CSRF_COOKIE&quot;], max_age = 60 * 60 * 24 * 7 * 52, domain=settings.CSRF_COOKIE_DOMAIN)<br>
● 2<br>
csrftoken与cookie中的token比较：<br>
if not constant_time_compare(request_csrf_token, csrf_token):</p>
<p>对于前后端分离的 ajax 去调用的话  需要在传递的参数里带上    csrfmiddlewaretoken: &quot;{{ csrf_token }}&quot;</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django settings.py 的media路径设置]]></title>
        <id>https://skytotwo.github.io//post/django-settings-meida-lujing</id>
        <link href="https://skytotwo.github.io//post/django-settings-meida-lujing">
        </link>
        <updated>2019-06-16T08:45:56.000Z</updated>
        <summary type="html"><![CDATA[<p>Django对media等静态文件的路径配置有自己的一套，在settings和url里面都有对应配置，这里简单做一下介绍。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django对media等静态文件的路径配置有自己的一套，在settings和url里面都有对应配置，这里简单做一下介绍。</p>
<!--more-->
<p>在一个 models 中使用 FileField 或 ImageField 需要以下步骤:</p>
<ol>
<li>
<p>在你的 settings 文件中, 定义一个完整路径给MEDIA_ROOT 以便让 Django在此处保存上传文件. (出于性能考虑,这些文件并不保存到数据库.) 定义MEDIA_URL 作为该目录的公共 URL. 要确保该目录对 WEB 服务器用户帐号是可写的.</p>
</li>
<li>
<p>在你的 models.py 中添加 FileField 或 ImageField, 并确保定义了upload_to 选项,以告诉 Django 使用MEDIA_ROOT 的哪个子目录保存上传文件.</p>
</li>
<li>
<p>你的数据库中要保存的只是文件的路径(相对于 MEDIA_ROOT)，要想得到这个文件的路径可以用&quot;.url&quot;方法。例如，如果models里有一个取名为&quot;photo&quot;的ImageField，可以在Html模板里通过双花括号加object.photo.url得到该图片的路径。</p>
</li>
</ol>
<p>settings.py 设置</p>
<p>媒体文件的绝对路径：</p>
<pre><code class="language-python"># Absolute path to the directory that holds media.
# Example: &quot;/home/media/media.lawrence.com/&quot;   
MEDIA_ROOT = 'D:/Python26/Lib/site-packages/django/bin/newproj/media'
</code></pre>
<p>媒体文件的相对路径：</p>
<pre><code class="language-python"># URL that handles the media served from MEDIA_ROOT.
# Example: &quot;http://media.lawrence.com&quot;
MEDIA_URL = '/site_media/' 
</code></pre>
<p>设置静态文件路径</p>
<pre><code class="language-python">STATIC_PATH = 'D:/Python26/Lib/site-packages/django/bin/newproj/media'
</code></pre>
<p>urls.py 影射路径</p>
<pre><code class="language-python">(r'^site_media/(?P&lt;path&gt;.*)$', 'django.views.static.serve',{'document_root': settings.STATIC_PATH}),
</code></pre>
<p>将 MEDIA_URL 的site_media 影射到 settings.STATIC_PATH</p>
<p>models.py 上传图片字段设置</p>
<pre><code class="language-python">photo = models.ImageField('上传图片',upload_to='photos')
</code></pre>
<p>相当于传到 D:/Python26/Lib/site-packages/django/bin/newproj/media/photos 目录下，浏览时通过/site_media/photos/ 访问。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django drf实现第三方登录]]></title>
        <id>https://skytotwo.github.io//post/django-drf-disanfang</id>
        <link href="https://skytotwo.github.io//post/django-drf-disanfang">
        </link>
        <updated>2019-06-16T08:19:48.000Z</updated>
        <summary type="html"><![CDATA[<p>对于现在的网站来说，第三方登陆可以说是一个常用的设计了，通过授权来实现诸如qq，微信，微博等第三方平台的第三方登陆。而对于Django的drf来说，也是可以很好的嵌入第三方登陆模块的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于现在的网站来说，第三方登陆可以说是一个常用的设计了，通过授权来实现诸如qq，微信，微博等第三方平台的第三方登陆。而对于Django的drf来说，也是可以很好的嵌入第三方登陆模块的。</p>
<!--more-->
<p>第三方登录都是采用OAuth2.0规范来实现的，基本流程是：</p>
<p>1、注册相关平台的开放平台的开发者账号，从而可以新建应用来开发调试。比如说微博就是在微博开放平台；微信就是在微信开放平台，QQ就是在QQ互联。</p>
<p>2、注册完账号后就可以在相关平台注册应用了。注册应用会得到appkey和appsecrt，这是必要的两个参数，以qq为例：</p>
<ul>
<li>（1）、第一步是获取Authorization Code，通过访问文档定义的接口，传递相关必要参数如appkey和appsectrt参数，拼接参数至url，用get方式访问url。</li>
<li>（2）、第二步是会跳转至第三方登陆页面，输入账号密码登陆成功后，会重定向至预设的redirect_url，并传递回Authorization Code</li>
<li>（2）、第三步是用Authorization Code获取到Access Token，当页面重定向至设定的重定向url后（通常是网站首页），即可以调用某个接口访问第三方的接口，拼接url传入Authorization Code获取到Access Token，通过Access Token可以获取到用户信息，随后进行注册等操作。</li>
</ul>
<p>drf实现第三方登录可以使用现成的框架，如github上的social—app—django，http://python-social-auth.readthedocs.io/en/latest/。</p>
<p><strong>一般设置步骤是：</strong></p>
<ol>
<li>
<p>安装框架<br>
pip install social-auth-app-django，安装的时候会附带安装一些依赖，比如social-core等，而框架也是基于social-core开发的。</p>
</li>
<li>
<p>在settings的INSTALLED_APPS中注册<br>
INSTALLED_APPS = [<br>
。。。。。<br>
'social_django',<br>
]</p>
</li>
<li>
<p>在setting文件的DATABASES中设置数据库引擎，因为第三方登录需要的是innodb，这样做后面的migration才不会出错。</p>
</li>
</ol>
<pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': &quot;mxshop&quot;,
        'USER': 'root',
        'PASSWORD': '123456',
        'HOST': '127.0.0.1',
        'OPTIONS': {'init_command' : 'SET default_storage_engine=INNODB;'}
    }
}
</code></pre>
<ol start="4">
<li>
<p>执行migrate，需要生成三个表，而不需要makemigration的原因是在安装的social_django中已经有了ini文件，可以直接进行migrate操作生成表。</p>
</li>
<li>
<p>在setting的AUTHENTICATION_BACKENDS中配置：</p>
</li>
</ol>
<pre><code class="language-python">AUTHENTICATION_BACKENDS = (
   'social_core.backends.qq.QQOAuth2',
    'social_core.backends.weibo.WeiboOAuth2',
    'social_core.backends.weixin.WeixinOAuth2',
    'django.contrib.auth.backends.ModelBackend',
    ...
)
</code></pre>
<p>其中的qq、weibo和微信名称都是在'social_core.backends中有定义的。</p>
<ol start="6">
<li>配置TEMPLATES</li>
</ol>
<pre><code class="language-python">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')]
        ,
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
               。。。。。。
                'social_django.context_processors.backends', #第三方登录
                'social_django.context_processors.login_redirect', #第三方登录重定向
            ],
        },
    },
]
</code></pre>
<ol start="7">
<li>在urls的urlpatterns中添加访问url，该url会封装了两个url，一个是登录至第三方平台，并且传回Authorization Code回来，第二个是用code去获取Access Token拿到用户信息，然后返回本系统，如果本系统登陆了的话就会将第三方平台的账号与已登录的账号做个绑定，如果没有登录则会用第三方返回的信息在本系统生成一个账号，并完成登录。</li>
</ol>
<pre><code class="language-python">urlpatterns = [
。。。。。。
     #第三方登录url
     url('', include('social_django.urls', namespace='social')),
]
</code></pre>
<ol start="8">
<li>
<p>注意两点：<br>
（1）、如果url中之前配置过login的url，如jwt的模式<br>
url(r'^login/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><mi>o</mi><mi>b</mi><mi>t</mi><mi>a</mi><mi>i</mi><msub><mi>n</mi><mi>j</mi></msub><mi>w</mi><msub><mi>t</mi><mi>t</mi></msub><mi>o</mi><mi>k</mi><mi>e</mi><mi>n</mi><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">一</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">在</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">用</mi></mrow><annotation encoding="application/x-tex">&#x27;, obtain_jwt_token),
一定要在login后面用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.038em;vertical-align:-0.286108em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">用</span></span></span></span>终止，不然会与第三方登录的url的login方法混淆。<br>
（2）、在拿到Acces Token并拿到相关信息后重定向的页面是在开放平台设置的redict_url，建议返回首页index，地址是本机的地址，也就是服务器的地址，不管是测试还是生产环境，不同于支付宝支付的返回，这里的是浏览器发起的重定向，并不会影响跳转。</p>
</li>
<li>
<p>在settings中配置第三方登录所需要的appkey和sppsecret<br>
SOCIAL_AUTH_你的第三方名称（在social_core的backend中有）_KEY = 'appkey'<br>
SOCIAL_AUTH_你的第三方名称（在social_core的backend中有）_SECRET = 'appsecret'</p>
</li>
<li>
<p>因为social_django是适用于django，获取信息返回后，返回的用户信息是给浏览器设置sessionid，但是drf的话，则是使用Token登录，这里则需要重写返回的方法，再返回的时候设置用户“name”和“token”，具体修改的代码位于socia_core的actions.py文件中的do_complete里，方法最后会将返回url，可以先将整个social_core拷贝至新建好的目录下。修改代码如下：</p>
</li>
</ol>
<pre><code class="language-python">from rest_framework_jwt.serializers import jwt_encode_handler, jwt_payload_handler

def do_complete(backend, login, user=None, redirect_name='next', *args, **kwargs):
	response = backend.strategy.redirect(url)
	payload = jwt_payload_handler(user)
	response.set_cookie(&quot;name&quot;, user.name if user.name else user.username, max_age=24*3600)
	response.set_cookie(&quot;token&quot;, jwt_encode_handler(payload))
	return response
</code></pre>
<p>特别需要注意的是cookie一定要设置过期时间，如上所示。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[asyncio 简介]]></title>
        <id>https://skytotwo.github.io//post/asyncio-jian-jie</id>
        <link href="https://skytotwo.github.io//post/asyncio-jian-jie">
        </link>
        <updated>2019-06-14T13:30:12.000Z</updated>
        <summary type="html"><![CDATA[<p>一直对asyncio这个库比较感兴趣，毕竟这是官网也非常推荐的一个实现高并发的一个模块，python也是在python 3.4中引入了协程的概念。也通过这次整理更加深刻理解这个模块的使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>一直对asyncio这个库比较感兴趣，毕竟这是官网也非常推荐的一个实现高并发的一个模块，python也是在python 3.4中引入了协程的概念。也通过这次整理更加深刻理解这个模块的使用</p>
<!--more-->
<h3 id="asyncio-是干什么的">asyncio 是干什么的？</h3>
<h4 id="异步网络操作">异步网络操作</h4>
<ul>
<li>并发</li>
<li>协程</li>
</ul>
<p>python3.0时代，标准库里的异步网络模块：select(非常底层) python3.0时代，第三方异步网络库：Tornado python3.4时代，asyncio：支持TCP,子进程。</p>
<p>现在的asyncio，有了很多的模块已经在支持：aiohttp,aiodns,aioredis等等 https://github.com/aio-libs 这里列出了已经支持的内容，并在持续更新</p>
<p>当然到目前为止实现协程的不仅仅只有asyncio,tornado和gevent都实现了类似功能</p>
<hr>
<p><strong>关于asyncio的一些关键字的说明：</strong></p>
<ul>
<li>
<p>event_loop 事件循环：程序开启一个无限循环，把一些函数注册到事件循环上，当满足事件发生的时候，调用相应的协程函数</p>
</li>
<li>
<p>coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</p>
</li>
<li>
<p>task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含了任务的各种状态</p>
</li>
<li>
<p>future: 代表将来执行或没有执行的任务的结果。它和task上没有本质上的区别</p>
</li>
<li>
<p>async/await 关键字：python3.5用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。</p>
</li>
</ul>
<p>看了上面这些关键字，你可能扭头就走了，其实一开始了解和研究asyncio这个模块有种抵触，自己也不知道为啥，这也导致很长一段时间，这个模块自己也基本就没有关注和使用，但是随着工作上用python遇到各种性能问题的时候，自己告诉自己还是要好好学习学习这个模块。</p>
<hr>
<h4 id="定义一个协程"><strong>定义一个协程</strong></h4>
<pre><code class="language-python">import time
import asyncio


now = lambda : time.time()


async def do_some_work(x):
    print(&quot;waiting:&quot;, x)

start = now()
# 这里是一个协程对象，这个时候do_some_work函数并没有执行
coroutine = do_some_work(2)
print(coroutine)
#  创建一个事件loop
loop = asyncio.get_event_loop()
# 将协程加入到事件循环loop
loop.run_until_complete(coroutine)

print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>在上面带中我们通过async关键字定义一个协程（coroutine）,当然协程不能直接运行，需要将协程加入到事件循环loop中</p>
<p>**asyncio.get_event_loop：**创建一个事件循环，然后使用run_until_complete将协程注册到事件循环，并启动事件循环</p>
<hr>
<h4 id="创建一个task"><strong>创建一个task</strong></h4>
<p>协程对象不能直接运行，在注册事件循环的时候，其实是run_until_complete方法将协程包装成为了一个任务（task）对象. task对象是Future类的子类，保存了协程运行后的状态，用于未来获取协程的结果</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()


async def do_some_work(x):
    print(&quot;waiting:&quot;, x)

start = now()

coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = loop.create_task(coroutine)
print(task)
loop.run_until_complete(task)
print(task)
print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>结果为：</p>
<pre><code class="language-python">&lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex2.py:13&gt;&gt;
waiting: 2
&lt;Task finished coro=&lt;do_some_work() done, defined at /app/py_code/study_asyncio/simple_ex2.py:13&gt; result=None&gt;
Time: 0.0003514289855957031
</code></pre>
<p>创建task后，在task加入事件循环之前为pending状态，当完成后，状态为finished</p>
<p>关于上面通过loop.create_task(coroutine)创建task,同样的可以通过 asyncio.ensure_future(coroutine)创建task</p>
<p>关于这两个命令的官网解释： https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future</p>
<pre><code class="language-python">asyncio.ensure_future(coro_or_future, *, loop=None)
Schedule the execution of a coroutine object: wrap it in a future. Return a Task object.

If the argument is a Future, it is returned directly.
</code></pre>
<p>https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task</p>
<pre><code class="language-python">AbstractEventLoop.create_task(coro)
Schedule the execution of a coroutine object: wrap it in a future. Return a Task object.

Third-party event loops can use their own subclass of Task for interoperability. In this case, the result type is a subclass of Task.

This method was added in Python 3.4.2. Use the async() function to support also older Python versions
</code></pre>
<hr>
<h4 id="绑定回调"><strong>绑定回调</strong></h4>
<p>绑定回调，在task执行完成的时候可以获取执行的结果，回调的最后一个参数是future对象，通过该对象可以获取协程返回值。</p>
<pre><code class="language-python">import time
import asyncio


now = lambda : time.time()


async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    return &quot;Done after {}s&quot;.format(x)


def callback(future):
    print(&quot;callback:&quot;,future.result())


start = now()
coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(coroutine)
print(task)
task.add_done_callback(callback)
print(task)
loop.run_until_complete(task)

print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>结果为：</p>
<pre><code class="language-python">&lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex3.py:13&gt;&gt;
&lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex3.py:13&gt; cb=[callback() at /app/py_code/study_asyncio/simple_ex3.py:18]&gt;
waiting: 2
callback: Done after 2s
Time: 0.00039196014404296875
</code></pre>
<p>通过add_done_callback方法给task任务添加回调函数，当task（也可以说是coroutine）执行完成的时候,就会调用回调函数。并通过参数future获取协程执行的结果。这里我们创建 的task和回调里的future对象实际上是同一个对象</p>
<hr>
<h4 id="阻塞和await"><strong>阻塞和await</strong></h4>
<p>使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行</p>
<p>耗时的操作一般是一些IO操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。</p>
<pre><code class="language-python">import asyncio
import time



now = lambda :time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    # await 后面就是调用耗时的操作
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)


start = now()

coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(coroutine)
loop.run_until_complete(task)

print(&quot;Task ret:&quot;, task.result())
print(&quot;Time:&quot;, now() - start)
</code></pre>
<p>在await asyncio.sleep(x)，因为这里sleep了，模拟了阻塞或者耗时操作，这个时候就会让出控制权。 即当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出,以便loop调用其他的协程。</p>
<hr>
<h4 id="并发和并行"><strong>并发和并行</strong></h4>
<ul>
<li>
<p>并发：指的是一段时间内执行多想任务</p>
</li>
<li>
<p>并行：指的是用同一个时间点执行多个任务。</p>
</li>
</ul>
<p>下面这个例子非常形象：</p>
<p>并发情况下是一个老师在同一时间段辅助不同的人功课。并行则是好几个老师分别同时辅助多个学生功课。简而言之就是一个人同时吃三个馒头还是三个人同时分别吃一个的情况，吃一个馒头算一个任务</p>
<pre><code class="language-python">import asyncio
import time


now = lambda :time.time()


async def do_some_work(x):
    print(&quot;Waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

start = now()

coroutine1 = do_some_work(1)
coroutine2 = do_some_work(2)
coroutine3 = do_some_work(4)

tasks = [
    asyncio.ensure_future(coroutine1),
    asyncio.ensure_future(coroutine2),
    asyncio.ensure_future(coroutine3)
]

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))

for task in tasks:
    print(&quot;Task ret:&quot;,task.result())

print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-python">Waiting: 1
Waiting: 2
Waiting: 4
Task ret: Done after 1s
Task ret: Done after 2s
Task ret: Done after 4s
Time: 4.004154920578003
</code></pre>
<p>总时间为4s左右。4s的阻塞时间，足够前面两个协程执行完毕。如果是同步顺序的任务，那么至少需要7s。此时我们使用了aysncio实现了并发。asyncio.wait(tasks) 也可以使用 asyncio.gather(*tasks) ,前者接受一个task列表，后者接收一堆task。</p>
<p>关于asyncio.gather和asyncio.wait官网的说明：</p>
<p>https://docs.python.org/3/library/asyncio-task.html#asyncio.gather</p>
<pre><code class="language-python">Return a future aggregating results from the given coroutine objects or futures.

All futures must share the same event loop. If all the tasks are done successfully, the returned future’s result is the list of results (in the order of the original sequence, not necessarily the order of results arrival). If return_exceptions is true, exceptions in the tasks are treated the same as successful results, and gathered in the result list; otherwise, the first raised exception will be immediately propagated to the returned future.
</code></pre>
<p>https://docs.python.org/3/library/asyncio-task.html#asyncio.wait</p>
<pre><code class="language-python">Wait for the Futures and coroutine objects given by the sequence futures to complete. Coroutines will be wrapped in Tasks. Returns two sets of Future: (done, pending).

The sequence futures must not be empty.

timeout can be used to control the maximum number of seconds to wait before returning. timeout can be an int or float. If timeout is not specified or None, there is no limit to the wait time.

return_when indicates when this function should return.
</code></pre>
<hr>
<h4 id="协程嵌套"><strong>协程嵌套</strong></h4>
<p>使用async可以定义协程，协程用于耗时的io操作，我们也可以封装更多的io操作过程，这样就实现了嵌套的协程，即一个协程中await了另外一个协程，如此连接起来。</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]

    dones, pendings = await asyncio.wait(tasks)
    for task in dones:
        print(&quot;Task ret:&quot;, task.result())

    # results = await asyncio.gather(*tasks)
    # for result in results:
    #     print(&quot;Task ret:&quot;,result)


start = now()

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>如果我们把上面代码中的：</p>
<pre><code class="language-python">    dones, pendings = await asyncio.wait(tasks)
    for task in dones:
        print(&quot;Task ret:&quot;, task.result())
</code></pre>
<p>替换为：</p>
<pre><code class="language-python">results = await asyncio.gather(*tasks)
 for result in results:
     print(&quot;Task ret:&quot;,result)
</code></pre>
<p>这样得到的就是一个结果的列表</p>
<p>不在main协程函数里处理结果，直接返回await的内容，那么最外层的run_until_complete将会返回main协程的结果。 将上述的代码更改为：</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    return await asyncio.gather(*tasks)

start = now()

loop = asyncio.get_event_loop()
results = loop.run_until_complete(main())
for result in results:
    print(&quot;Task ret:&quot;,result)

print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>或者返回使用asyncio.wait方式挂起协程。</p>
<p>将代码更改为：</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    return await asyncio.wait(tasks)

start = now()

loop = asyncio.get_event_loop()
done,pending = loop.run_until_complete(main())
for task in done:
    print(&quot;Task ret:&quot;,task.result())

print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>也可以使用asyncio的as_completed方法</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    for task in asyncio.as_completed(tasks):
        result = await task
        print(&quot;Task ret: {}&quot;.format(result))

start = now()

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>从上面也可以看出，协程的调用和组合非常灵活，主要体现在对于结果的处理：如何返回，如何挂起</p>
<hr>
<h4 id="协程的停止"><strong>协程的停止</strong></h4>
<p>future对象有几个状态：</p>
<ul>
<li>Pending</li>
<li>Running</li>
<li>Done</li>
<li>Cacelled<br>
创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task</li>
</ul>
<pre><code class="language-python">import asyncio
import time


now = lambda :time.time()


async def do_some_work(x):
    print(&quot;Waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

coroutine1 =do_some_work(1)
coroutine2 =do_some_work(2)
coroutine3 =do_some_work(2)

tasks = [
    asyncio.ensure_future(coroutine1),
    asyncio.ensure_future(coroutine2),
    asyncio.ensure_future(coroutine3),
]

start = now()

loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(asyncio.wait(tasks))
except KeyboardInterrupt as e:
    print(asyncio.Task.all_tasks())
    for task in asyncio.Task.all_tasks():
        print(task.cancel())
    loop.stop()
    loop.run_forever()
finally:
    loop.close()

print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>启动事件循环之后，马上ctrl+c，会触发run_until_complete的执行异常 KeyBorardInterrupt。然后通过循环asyncio.Task取消future。可以看到输出如下：</p>
<pre><code class="language-python">Waiting: 1
Waiting: 2
Waiting: 2
^C{&lt;Task finished coro=&lt;do_some_work() done, defined at /app/py_code/study_asyncio/simple_ex10.py:13&gt; result='Done after 1s'&gt;, &lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex10.py:15&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /usr/local/lib/python3.5/asyncio/tasks.py:428]&gt;, &lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex10.py:15&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /usr/local/lib/python3.5/asyncio/tasks.py:428]&gt;, &lt;Task pending coro=&lt;wait() running at /usr/local/lib/python3.5/asyncio/tasks.py:361&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt;&gt;}
False
True
True
True
Time: 1.0707225799560547
</code></pre>
<p>True表示cannel成功，loop stop之后还需要再次开启事件循环，最后在close，不然还会抛出异常</p>
<p>循环task，逐个cancel是一种方案，可是正如上面我们把task的列表封装在main函数中，main函数外进行事件循环的调用。这个时候，main相当于最外出的一个task，那么处理包装的main函数即可。</p>
<hr>
<h4 id="不同线程的事件循环"><strong>不同线程的事件循环</strong></h4>
<p>很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环，然后在新建一个线程，在新线程中启动事件循环。当前线程不会被block。</p>
<pre><code class="language-python">import asyncio
from threading import Thread
import time

now = lambda :time.time()

def start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

def more_work(x):
    print('More work {}'.format(x))
    time.sleep(x)
    print('Finished more work {}'.format(x))

start = now()
new_loop = asyncio.new_event_loop()
t = Thread(target=start_loop, args=(new_loop,))
t.start()
print('TIME: {}'.format(time.time() - start))

new_loop.call_soon_threadsafe(more_work, 6)
new_loop.call_soon_threadsafe(more_work, 3)
</code></pre>
<p>启动上述代码之后，当前线程不会被block，新线程中会按照顺序执行call_soon_threadsafe方法注册的more_work方法， 后者因为time.sleep操作是同步阻塞的，因此运行完毕more_work需要大致6 + 3</p>
<hr>
<h4 id="新线程协程"><strong>新线程协程</strong></h4>
<pre><code class="language-python">import asyncio
import time
from threading import Thread

now = lambda :time.time()


def start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

async def do_some_work(x):
    print('Waiting {}'.format(x))
    await asyncio.sleep(x)
    print('Done after {}s'.format(x))

def more_work(x):
    print('More work {}'.format(x))
    time.sleep(x)
    print('Finished more work {}'.format(x))

start = now()
new_loop = asyncio.new_event_loop()
t = Thread(target=start_loop, args=(new_loop,))
t.start()
print('TIME: {}'.format(time.time() - start))

asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop)
asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop)
</code></pre>
<p>上述的例子，主线程中创建一个new_loop，然后在另外的子线程中开启一个无限事件循环。 主线程通过run_coroutine_threadsafe新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被block。一共执行的时间大概在6s左右。</p>
]]></content>
    </entry>
</feed>