<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skytotwo.github.io/</id>
    <title>Totoro の Home</title>
    <updated>2019-08-26T08:22:57.616Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skytotwo.github.io/"/>
    <link rel="self" href="https://skytotwo.github.io//atom.xml"/>
    <subtitle>空杯心态，每天进步</subtitle>
    <logo>https://skytotwo.github.io//images/avatar.png</logo>
    <icon>https://skytotwo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Totoro の Home</rights>
    <entry>
        <title type="html"><![CDATA[谈谈python中的深拷贝和浅拷贝]]></title>
        <id>https://skytotwo.github.io//post/python-copy</id>
        <link href="https://skytotwo.github.io//post/python-copy">
        </link>
        <updated>2019-08-26T08:19:53.000Z</updated>
        <summary type="html"><![CDATA[<p>原文链接：谈谈python中的深拷贝和浅拷贝<a href="https://www.jianshu.com/p/efa9dd51f5cc">https://www.jianshu.com/p/efa9dd51f5cc</a></p>
<p>最近面试被问到python中深拷贝和浅拷贝的知识<br>
这里进行下总结，以便今后复习<br>
python中的深拷贝和浅拷贝和java里面的概念是一样的，所谓浅拷贝就是对引用的拷贝，所谓深拷贝就是对对象的资源的拷贝。</p>
]]></summary>
        <content type="html"><![CDATA[<p>原文链接：谈谈python中的深拷贝和浅拷贝<a href="https://www.jianshu.com/p/efa9dd51f5cc">https://www.jianshu.com/p/efa9dd51f5cc</a></p>
<p>最近面试被问到python中深拷贝和浅拷贝的知识<br>
这里进行下总结，以便今后复习<br>
python中的深拷贝和浅拷贝和java里面的概念是一样的，所谓浅拷贝就是对引用的拷贝，所谓深拷贝就是对对象的资源的拷贝。</p>
 <!-- more -->
<p><strong>首先，对赋值操作我们要有以下认识：</strong></p>
<ol>
<li>赋值是将一个对象的地址赋值给一个变量，让变量指向该地址（ 旧瓶装旧酒 ）。</li>
<li>修改不可变对象（str、tuple）需要开辟新的空间</li>
<li>修改可变对象（list等）不需要开辟新的空间<br>
浅拷贝仅仅复制了容器中元素的地址</li>
</ol>
<pre><code class="language-python">&gt;&gt;&gt; a=['hello',[1,2,3]]
&gt;&gt;&gt; b=a[:]
&gt;&gt;&gt; [id(x) for x in a]
[55792504, 6444104]
&gt;&gt;&gt; [id(x) for x in b]
[55792504, 6444104]
&gt;&gt;&gt; a[0]='world'
&gt;&gt;&gt; a[1].append(4)
&gt;&gt;&gt; print(a)
['world', [1, 2, 3, 4]]
&gt;&gt;&gt; print(b)
['hello', [1, 2, 3, 4]]
</code></pre>
<p>这里可以看出，未修改前，a和b中元素的地址都是相同的，不可变的hello<br>
和可变的list地址都一样，说明浅拷贝知识将容器内的元素的地址复制了一份。这可以通过修改后，b中字符串没改变，但是list元素随着a相应改变得到验证。</p>
<ul>
<li>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。</li>
</ul>
<p>深拷贝，完全拷贝了一个副本，容器内部元素地址都不一样</p>
<pre><code class="language-python">&gt;&gt;&gt; from copy import deepcopy
&gt;&gt;&gt; a=['hello',[1,2,3]]
&gt;&gt;&gt; b=deepcopy(a)
&gt;&gt;&gt; [id(x) for x in a]
[55792504, 55645000]
&gt;&gt;&gt; [id(x) for x in b]
[55792504, 58338824]
&gt;&gt;&gt; a[0]='world'
&gt;&gt;&gt; a[1].append(4)
&gt;&gt;&gt; 
&gt;&gt;&gt; print(a)
['world', [1, 2, 3, 4]]
&gt;&gt;&gt; print(b)
['hello', [1, 2, 3]]
</code></pre>
<p>这里可以看出，深拷贝后，a和b的地址以及a和b中的元素地址均不同，这是完全拷贝的一个副本，修改a后，发现b没有发生任何改变，因为b是一个完全的副本，元素地址与a均不同，a修改不影响b。</p>
<ul>
<li>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说（ 新瓶装新酒 ）。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask中url_for的参数解释]]></title>
        <id>https://skytotwo.github.io//post/flask-url_for</id>
        <link href="https://skytotwo.github.io//post/flask-url_for">
        </link>
        <updated>2019-08-26T08:17:44.000Z</updated>
        <summary type="html"><![CDATA[<p>url_for函数的作用是：通过给定的endpoint端点和额外参数，结合请求上下文和应用上下文，生成一个url地址并返回。</p>
]]></summary>
        <content type="html"><![CDATA[<p>url_for函数的作用是：通过给定的endpoint端点和额外参数，结合请求上下文和应用上下文，生成一个url地址并返回。</p>
<!-- more --> 
<p>其中的额外参数有：<br>
_external: 是否使用绝对路径<br>
_scheme：使用http还是https，设置这个参数时，必须使_external=True<br>
_anchor：锚点，可以定位到html中的某一个位置<br>
_method：http方法,post、get等</p>
<p>endpoint其实又叫做端点，默认情况下是视图函数名，也可以自定义端点名，主要是用作url_for反向寻找视图的一个标记，如：</p>
<pre><code class="language-python">{{ url_for('login') }}
</code></pre>
<p>login就是endpoint端点名。</p>
<p>url_for() 函数还支持一种简写的端点形式，在蓝本中可以省略蓝本名，例如url_for('.<br>
index')。在这种写法中，命名空间是当前请求所在的蓝本。这意味着同一蓝本中的重定向<br>
可以使用简写形式，但跨蓝本的重定向必须使用带有命名空间的端点名。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单页面应用程序和多页面应用程序（网站）的区别]]></title>
        <id>https://skytotwo.github.io//post/single&amp;mutipage</id>
        <link href="https://skytotwo.github.io//post/single&amp;mutipage">
        </link>
        <updated>2019-08-26T08:13:52.000Z</updated>
        <summary type="html"><![CDATA[<p>单页面和双页面应用的区别：</p>
<ul>
<li>1、单页面应用程序的数据渲染是在客户端进行的；而多页面应用程序的数据渲染则是在服务端进行的。</li>
<li>2、单页面应用程序的数据请求等是在js中通过ajax完成的；多页面应用程序则是在服务端试图函数中完成的。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>单页面和双页面应用的区别：</p>
<ul>
<li>1、单页面应用程序的数据渲染是在客户端进行的；而多页面应用程序的数据渲染则是在服务端进行的。</li>
<li>2、单页面应用程序的数据请求等是在js中通过ajax完成的；多页面应用程序则是在服务端试图函数中完成的。</li>
</ul>
<h2 id="-more-"><!-- more --></h2>
<h3 id="单页面应用singlepage-web-applicationspa"><strong>单页面应用（SinglePage Web Application，SPA）</strong></h3>
<p>只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次，常用于PC端官网、购物等网站<br>
如图：<br>
<img src="/attached/image/20180508/20180508223839_750.png" alt=""></p>
<h3 id="多页面应用multipage-applicationmpa"><strong>多页面应用（MultiPage Application，MPA）</strong></h3>
<p>多页面跳转刷新所有资源，每个公共资源(js、css等)需选择性重新加载，常用于 app 或 客户端等</p>
<p>如图：<br>
<img src="/attached/image/20180508/20180508223908_626.png" alt=""></p>
<p>具体对比分析：</p>
<p><img src="/attached/image/20180508/20180508223927_729.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python的with上下文要点]]></title>
        <id>https://skytotwo.github.io//post/python-with-context</id>
        <link href="https://skytotwo.github.io//post/python-with-context">
        </link>
        <updated>2019-08-26T08:09:49.000Z</updated>
        <summary type="html"><![CDATA[<p>python的的with上下文其实可以自己实现，只要该对象实现了__enter__和__exit__方法，就实现了一个with上下文，可以用with来处理该对象，如下：</p>
]]></summary>
        <content type="html"><![CDATA[<p>python的的with上下文其实可以自己实现，只要该对象实现了__enter__和__exit__方法，就实现了一个with上下文，可以用with来处理该对象，如下：</p>
<!-- more -->
<pre><code class="language-python">class MyResource:
	def __enter__(self):
		return self
	
	def __exit__(self, exc_type, exc_value, tb):
		if tb:
			print('proccess exception')
		else:
			print('no exception')
		print('close resource connection')
		
	def query(self):
		print('query data')
		

with MyResource() as resource:
	resource.query()
</code></pre>
<p>注意：<br>
1、任何实现了__enter__和__exit__魔法方法的对象都能用with处理<br>
2、with实例化对象后用as赋给一个变量，变量为__enter__所返回的值，上面代码中__enter__返回的是实例对象。<br>
3、调用的顺序是__enter__，然后with里的逻辑，最后是__exit__方法。<br>
4、<strong>exit</strong> 方法包含4个参数，分别是(self, exc_type, exc_value, tb)，第一个是实例对象，后面三个分别为异常类型、异常值和异常堆栈信息。这里主要是为了捕获异常，只要是逻辑处理中危险异常，都会在这里捕获，并退出。<br>
5、<strong>exit</strong> 方法是有返回的，如果return值是Ture的话，就代表捕获了异常，不会抛出；如果返回值为空或者返回False，就代表异常会继续抛出。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[详解flask上下文与出入栈]]></title>
        <id>https://skytotwo.github.io//post/flask-content</id>
        <link href="https://skytotwo.github.io//post/flask-content">
        </link>
        <updated>2019-08-26T08:04:10.000Z</updated>
        <summary type="html"><![CDATA[<p>在flask中，上下文算是核心中的核心了，其作用于请求的访问处理，多线程隔离的实现等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在flask中，上下文算是核心中的核心了，其作用于请求的访问处理，多线程隔离的实现等。</p>
 <!-- more --> 
<h4 id="flask的上下文">flask的上下文：</h4>
<p>1、应用上下文 （AppContent）<br>
2、请求上下文 （Request Context）</p>
<p>如图所示：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180506181132_533.jpg" alt="20180506181132_533.jpg"></p>
<p>应用上下文是对当前应用实例app的封装<br>
请求上下文是对当前请求Request的封装</p>
<p>1、当每一个请求进入系统的时候，都会将当前的应用上下文和请求上下文进行入栈操作，所代表的栈对象分别是_app_ctx_stack和_request_ctx_stack。<br>
2、栈对象进入栈顶的顺序是，先应用上下文的栈对象先进入栈顶，然后才是请求上下文的栈对象进入栈顶</p>
<h4 id="注意">注意：</h4>
<p>1、当一个请求进来时，也就是在请求的逻辑中要获取应用上下文，flask会先判断应用上下文的栈顶是否有该应用实例栈对象，没有的话会自动帮着将当前的应用上下文栈对象推入栈中。也就是说，在请求的逻辑视图处理中，是可以获取到当前的应用上下文的。<br>
2、通过current_app和request获取当前应用上下文和请求上下文，其实都是经过了flask的封装，该方法是localproxy，都是分别去各自的栈顶获取栈对象，然后再取出app和request这个属性。</p>
<p>3、在不是请求视图中要获取当前的应用上下文，是需要自己将当前的应用栈对象push到栈中的，然后才能通过current_app来获取到当前应用实例。通常在离线应用和单元测试场景上会使用到。<br>
具体代码如下：</p>
<pre><code class="language-python">app = Flask(__name__)

ctx = app.app_content()
ctx.push()

然后使用完了需要将其在栈中去除
ctx.pop()
</code></pre>
<h4 id="所有名词解释">所有名词解释</h4>
<p>1、以线程ID号作为key的字典-&gt;Local-&gt;LocalStack<br>
（local是通过点来实现线程隔离的，localstack则是封装了local通过push()、pop()和top成为线程隔离对象(栈)）<br>
2、AppContext RequestContext -&gt; LocalStack<br>
（AppContext是应用上下文，RequestContext是请求上下文，分别依次推入各自的线程隔离对象中）<br>
3、Flask -&gt; AppContext   Request -&gt; RequestContext<br>
（AppContext封装的是Flask的应用核心对象，RequestContext封装的是本次请求的Request对象）<br>
4、current_app -&gt;(LocalStack.top = AppContext top.app=Flask)<br>
（current_app指的是线程隔离对象栈顶的元素（应用上下文）的app属性（核心对象））<br>
5、request -&gt;(LocalStack.top = RequestContext top.request= Request)<br>
（request指的是线程隔离对象栈顶元素（请求上下文）的request属性（当前request对象））</p>
<p>注意：app，也就是当前应用核心对象只有一个，因为它是在主线程中生成的，而request则是每次请求都会生成一个，所以需要线程隔离。app的话，因为作为字典存在的线程隔离，都是同一个value是没有意义的，所以app并没有被线程隔离</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos系统下nginx 相关命令]]></title>
        <id>https://skytotwo.github.io//post/centos-nginx</id>
        <link href="https://skytotwo.github.io//post/centos-nginx">
        </link>
        <updated>2019-08-26T08:01:26.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">linux（centos）系统下nginx 服务器重启，关闭的命令。

nginx -s reload  ：修改配置后重新加载生效

nginx -s reopen  ：重新打开日志文件

nginx -t 测试nginx配置文件是否正确

nginx -t -c /path/to/nginx.conf 测试nginx配置文件是否正确

关闭nginx：

nginx -s stop  : 快速停止nginx
         quit  : 完整有序的停止nginx

其他的停止 nginx 方式：

ps -ef | grep nginx

kill -QUIT 主进程号     ：从容停止Nginx

kill -TERM 主进程号     ：快速停止Nginx

pkill -9 nginx         :强制停止Nginx

启动nginx:

nginx -c /path/to/nginx.conf

平滑重启nginx：

kill -HUP 主进程号
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7 环境下部署flask网站步骤]]></title>
        <id>https://skytotwo.github.io//post/centos7-flask-env</id>
        <link href="https://skytotwo.github.io//post/centos7-flask-env">
        </link>
        <updated>2019-08-26T07:53:41.000Z</updated>
        <summary type="html"><![CDATA[<p>自己之前做了一个flask项目，完成后部署在腾讯云，过程由踩一点坑，这里记录下过程。在部署之前，需要先配置centos7环境，具体链接为：<br>
<a href="https://totoro.site/post/centos7-python-env/" title="centos7 环境配置">centos7 环境配置</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>自己之前做了一个flask项目，完成后部署在腾讯云，过程由踩一点坑，这里记录下过程。在部署之前，需要先配置centos7环境，具体链接为：<br>
<a href="https://totoro.site/post/centos7-python-env/" title="centos7 环境配置">centos7 环境配置</a></p>
 <!-- more --> 
<p>1、安装依赖包<br>
在虚拟环境中安装好所有包，例如：</p>
<pre><code class="language-python">pip install -r requements.txt
</code></pre>
<p>2、关闭调试模式 app.debug = False，并且安装flask-script插件来进行命令行启动项目，如下：</p>
<pre><code class="language-python">pip install flask-script
from flask_script import Manager

manage = Manager(app)

if __name__ == &quot;__main__&quot;:
    manage.run()
</code></pre>
<p>3、在init文件中修改mysql数据库连接（ip地址等），然后在navicat中远程连接到服务器的mysql，进行数据传输，这样是最省时的。<br>
4、配置nginx 反向代理<br>
nginx配置文件：</p>
<pre><code class="language-python">worker_processes 4;
events {
    worker_connections 262140;
}
http {
    include mime.types;
    default_type application/octet-stream;
    sendfile on;
    keepalive_timeout 65;
    limit_conn_zone $binary_remote_addr zone=addr:5m;
    upstream movie {
		server 127.0.0.1:5000;
        server 127.0.0.1:5001;
        server 127.0.0.1:5002;
        server 127.0.0.1:5003;
        server 127.0.0.1:5004;
    }
    server {
        listen 80;
        server_name localhost;
        location / {
            root html;
            index index.html index.htm;
            proxy_pass http://movie;
        }
        location ~ \.flv$ {
            flv;
            limit_conn addr 4;
            limit_rate 1024k;
            rewrite ^/static/uploads/movies/(.+?).flv$ /flask_movie/app/static/uploads/movies/$1.flv permanent;
        }
        location ~ \.mp4$ {
            mp4;
            limit_conn addr 4;
            limit_rate 1024k;
            rewrite ^/static/uploads/movies/(.+?).mp4$ /flask_movie/app/static/uploads/movies/$1.mp4 permanent;
        }
        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            root html;
        }
    }
}

</code></pre>
<p>然后将配置文件拷贝至nginx目录中，覆盖原有配置文件：</p>
<pre><code class="language-python">cp nginx.conf /usr/local/nginx/conf/
ubuntu: cp nginx.conf /etc/nginx/conf.d
</code></pre>
<p>将项目拷贝到nginx的html目录：</p>
<pre><code class="language-python">cp -r movie_project /usr/local/nginx/html

</code></pre>
<p>然后重启nginx：</p>
<pre><code class="language-python">nginx -s stop
nginx
nginx -s reload
</code></pre>
<p>启动项目：</p>
<pre><code class="language-python">cd /usr/local/nginx/html/movie_project

python manage.py runserver
</code></pre>
<p>5、开启多个端口后台运行</p>
<pre><code class="language-python">nohup python manage.py runserver -h 127.0.0.1 -p 5001 &amp;

然后 ctr + c

nohup python manage.py runserver -h 127.0.0.1 -p 5002 &amp;

然后 ctr + c

nohup python manage.py runserver -h 127.0.0.1 -p 5003 &amp;

然后 ctr + c

nohup python manage.py runserver -h 127.0.0.1 -p 5004 &amp;
</code></pre>
<p>这样就开启了四个端口，输入如下命令可以查看：</p>
<pre><code class="language-python">netstat -anptu | grep 500*
</code></pre>
<p>6、流媒体访问限制<br>
限制单个ip能发起的连接: limit_conn addr 1;<br>
限制视频速率: limit_rate 1024k;<br>
刷新nginx nginx -s reload</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7 部署python应用相关配置]]></title>
        <id>https://skytotwo.github.io//post/centos7-python-env</id>
        <link href="https://skytotwo.github.io//post/centos7-python-env">
        </link>
        <updated>2019-08-26T07:47:31.000Z</updated>
        <summary type="html"><![CDATA[<p>在centos上部署python环境需要的步骤很多，包括nginx，python版本安装，mysql的安装配置，虚拟环境的安装配置等，过程比较繁琐，有许多小细节要注意，以下是相关步骤。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在centos上部署python环境需要的步骤很多，包括nginx，python版本安装，mysql的安装配置，虚拟环境的安装配置等，过程比较繁琐，有许多小细节要注意，以下是相关步骤。</p>
<!-- more -->
<h3 id="1-安装python36"><strong>1. 安装python3.6</strong></h3>
<p>编译环境准备：</p>
<pre><code class="language-python"> yum groupinstall 'Development Tools'
 yum install zlib-devel bzip2-devel openssl-devel ncurese-devel
 yum -y install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel
</code></pre>
<p>1 . 获取</p>
<pre><code class="language-python">wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz
tar -xzvf Python-3.6.3.tgz -C  /tmp
cd  /tmp/Python-3.6.3/
</code></pre>
<p>2 . 把Python3.6安装到 /usr/local 目录</p>
<pre><code class="language-python">./configure --prefix=/usr/local
make
make altinstall
</code></pre>
<p>3 . 更改/usr/bin/python链接</p>
<pre><code class="language-python">ln -s /usr/local/bin/python3.6 /usr/bin/python3
</code></pre>
<p>替换旧Python，将默认安装的python2软链接指向python：</p>
<pre><code class="language-python">mv /usr/bin/python /usr/bin/old_python
</code></pre>
<p>再将/usr/bin/python指向python3：</p>
<pre><code class="language-python">ln -s /usr/local/bin/python3.6 /usr/bin/python
</code></pre>
<p>这样输入/usr/bin/python出来的就是python3了。这也是后面安装virtualenvwrapper，配置路径不会出错的前提。<br>
删除软连接：rm -rf  /home/zhenwx/htccode（示例）</p>
<p>4 .使得输入python系统默认为python3</p>
<pre><code class="language-python">cd /usr/bin/
ls yum*
vim yum
</code></pre>
<p>修改第一行尾python2</p>
<pre><code class="language-python">vim yum-config-manager
</code></pre>
<p>修改第一行尾python2</p>
<pre><code class="language-python">vim yum-debug-restore
vim yum-groups-manager
vim yum-build-dep
vim yum-debug-dump
vim yumdownloader
vim /usr/libexec/urlgrabber-ext-down
</code></pre>
<p>修改第一行尾python2</p>
<p>此时输入python就是3.6的python了。</p>
<h3 id="2-maridb"><strong>2. maridb</strong></h3>
<ol>
<li>
<p>安装</p>
<pre><code class="language-python"></code></pre>
</li>
</ol>
<p>sudo yum install mariadb-server</p>
<pre><code>2. 启动， 重启

    ```python
sudo systemctl start mariadb
sudo systemctl restart mariadb
</code></pre>
<ol start="3">
<li>设置bind-ip</li>
</ol>
<pre><code class="language-python">vim /etc/my.cnf
</code></pre>
<p>在 [mysqld]:下面加一行</p>
<pre><code class="language-python">bind-address = 0.0.0.0
</code></pre>
<p>4 . 设置外部ip可以访问</p>
<p>先进入mysql才能运行下面命令:mysql 直接进入就行</p>
<pre><code class="language-python">GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;
</code></pre>
<pre><code class="language-python">FLUSH PRIVILEGES;
</code></pre>
<p>5 . 设置阿里云、腾讯云的对外端口<br>
在对应服务器控制面板中，添加安全组规则，开放端口3306</p>
<p>6 . 安装mysqlclient出问题</p>
<pre><code>centos 7：
    yum install python-devel mariadb-devel -y

ubuntu：
    sudo apt-get install libmysqlclient-dev

然后：
    pip install mysqlclient
</code></pre>
<h3 id="3-安装nginx"><strong>3. 安装nginx</strong></h3>
<p>1、拷贝我们的nginx安装包到服务器<br>
2、安装依赖包</p>
<pre><code class="language-python">yum -y install gcc gcc-c++ openssl-devel pcre-devel httpd-tools
</code></pre>
<p>3、编译安装</p>
<pre><code class="language-python">tar -zxf nginx.tar.gz
cd nginx/

useradd nginx
./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_mp4_module --with-http_flv_module

make &amp;&amp; make install

ln -s /usr/local/nginx/sbin/nginx /usr/sbin/
</code></pre>
<h3 id="4-安装virtualenvwrapper"><strong>4. 安装virtualenvwrapper</strong></h3>
<pre><code class="language-python">yum install python-setuptools python-devel
pip install virtualenvwrapper
</code></pre>
<p>编辑.bashrc文件</p>
<pre><code class="language-python">vim ~/.bashrc
</code></pre>
<pre><code class="language-python">export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh
</code></pre>
<p>重新加载.bashrc文件</p>
<pre><code class="language-python">source  ~/.bashrc
</code></pre>
<p>新建虚拟环境</p>
<pre><code class="language-python">mkvirtualenv mxonline
</code></pre>
<p>进入虚拟环境</p>
<pre><code class="language-python">workon mxonline
</code></pre>
<p>安装pip包<br>
我们可以通过 pip freeze &gt; requirements.txt 将本地的虚拟环境安装包相信信息导出来</p>
<p>然后将requirements.txt文件上传到服务器之后运行：</p>
<pre><code class="language-python">pip install -r requirements.txt
</code></pre>
<p>安装依赖包</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python装饰器详解]]></title>
        <id>https://skytotwo.github.io//post/python-decorator</id>
        <link href="https://skytotwo.github.io//post/python-decorator">
        </link>
        <updated>2019-08-26T07:31:47.000Z</updated>
        <summary type="html"><![CDATA[<p>讲 Python 装饰器前，我想先举个例子，以便能更贴切的解释装饰器。</p>
]]></summary>
        <content type="html"><![CDATA[<p>讲 Python 装饰器前，我想先举个例子，以便能更贴切的解释装饰器。</p>
 <!-- more --> 
<p>每个人都有的内裤主要功能是用来遮羞，但是到了冬天它没法为我们防风御寒，咋办？我们想到的一个办法就是把内裤改造一下，让它变得更厚更长，这样一来，它不仅有遮羞功能，还能提供保暖，不过有个问题，这个内裤被我们改造成了长裤后，虽然还有遮羞功能，但本质上它不再是一条真正的内裤了。于是聪明的人们发明长裤，在不影响内裤的前提下，直接把长裤套在了内裤外面，这样内裤还是内裤，有了长裤后宝宝再也不冷了。装饰器就像我们这里说的长裤，在不影响内裤作用的前提下，给我们的身子提供了保暖的功效。</p>
<p>谈装饰器前，还要先要明白一件事，Python 中的函数和 Java、C++不太一样，Python 中的函数可以像普通变量一样当做参数传递给另外一个函数，例如：</p>
<pre><code class="language-python">def foo():
    print(&quot;foo&quot;)

def bar(func):
func()

bar(foo)
</code></pre>
<p>正式回到我们的主题。装饰器本质上是一个 Python 函数或类，它可以让其他函数或类在不需要做任何代码修改的前提下增加额外功能，装饰器的返回值也是一个函数/类对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景，装饰器是解决这类问题的绝佳设计。有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码到装饰器中并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。</p>
<p>先来看一个简单例子，虽然实际代码可能比这复杂很多：</p>
<pre><code class="language-python">def foo():
    print('i am foo')
</code></pre>
<p>现在有一个新的需求，希望可以记录下函数的执行日志，于是在代码中添加日志代码：</p>
<pre><code class="language-python">def foo():
    print('i am foo')
    logging.info(&quot;foo is running&quot;)
</code></pre>
<p>如果函数 bar()、bar2() 也有类似的需求，怎么做？再写一个 logging 在 bar 函数里？这样就造成大量雷同的代码，为了减少重复写代码，我们可以这样做，重新定义一个新的函数：专门处理日志 ，日志处理完之后再执行真正的业务代码</p>
<pre><code class="language-python">def use_logging(func):
    logging.warn(&quot;%s is running&quot; % func.__name__)
    func()

def foo():
    print('i am foo')

use_logging(foo)
</code></pre>
<p>这样做逻辑上是没问题的，功能是实现了，但是我们调用的时候不再是调用真正的业务逻辑 foo 函数，而是换成了 use_logging 函数，这就破坏了原有的代码结构， 现在我们不得不每次都要把原来的那个 foo 函数作为参数传递给 use_logging 函数，那么有没有更好的方式的呢？当然有，答案就是装饰器。</p>
<pre><code class="language-python">简单装饰器
def use_logging(func):

    def wrapper():
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func()   # 把 foo 当做参数传递进来时，执行func()就相当于执行foo()
    return wrapper

def foo():
    print('i am foo')

foo = use_logging(foo)  # 因为装饰器 use_logging(foo) 返回的时函数对象 wrapper，这条语句相当于  foo = wrapper
foo()                   # 执行foo()就相当于执行 wrapper()
</code></pre>
<p>use_logging 就是一个装饰器，它一个普通的函数，它把执行真正业务逻辑的函数 func 包裹在其中，看起来像 foo 被 use_logging 装饰了一样，use_logging 返回的也是一个函数，这个函数的名字叫 wrapper。在这个例子中，函数进入和退出时 ，被称为一个横切面，这种编程方式被称为面向切面的编程。</p>
<h3 id="语法糖"><strong>@ 语法糖</strong></h3>
<p>如果你接触 Python 有一段时间了的话，想必你对 @ 符号一定不陌生了，没错 @ 符号就是装饰器的语法糖，它放在函数开始定义的地方，这样就可以省略最后一步再次赋值的操作。</p>
<pre><code class="language-python">def use_logging(func):

    def wrapper():
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func()
    return wrapper

@use_logging
def foo():
    print(&quot;i am foo&quot;)

foo()
</code></pre>
<p>如上所示，有了 @ ，我们就可以省去foo = use_logging(foo)这一句了，直接调用 foo() 即可得到想要的结果。你们看到了没有，foo() 函数不需要做任何修改，只需在定义的地方加上装饰器，调用的时候还是和以前一样，如果我们有其他的类似函数，我们可以继续调用装饰器来修饰函数，而不用重复修改函数或者增加新的封装。这样，我们就提高了程序的可重复利用性，并增加了程序的可读性。</p>
<p>装饰器在 Python 使用如此方便都要归因于 Python 的函数能像普通的对象一样能作为参数传递给其他函数，可以被赋值给其他变量，可以作为返回值，可以被定义在另外一个函数内。</p>
<h3 id="args-kwargs">*args、**kwargs</h3>
<p>可能有人问，如果我的业务逻辑函数 foo 需要参数怎么办？比如：</p>
<pre><code class="language-python">def foo(name):
    print(&quot;i am %s&quot; % name)
我们可以在定义 wrapper 函数的时候指定参数：

def wrapper(name):
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func(name)
    return wrapper
</code></pre>
<p>这样 foo 函数定义的参数就可以定义在 wrapper 函数中。这时，又有人要问了，如果 foo 函数接收两个参数呢？三个参数呢？更有甚者，我可能传很多个。当装饰器不知道 foo 到底有多少个参数时，我们可以用 *args 来代替：</p>
<pre><code class="language-python">def wrapper(*args):
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func(*args)
    return wrapper
</code></pre>
<p>如此一来，甭管 foo 定义了多少个参数，我都可以完整地传递到 func 中去。这样就不影响 foo 的业务逻辑了。这时还有读者会问，如果 foo 函数还定义了一些关键字参数呢？比如：</p>
<pre><code class="language-python">def foo(name, age=None, height=None):
    print(&quot;I am %s, age %s, height %s&quot; % (name, age, height))
</code></pre>
<p>这时，你就可以把 wrapper 函数指定关键字函数：</p>
<pre><code class="language-python">def wrapper(*args, **kwargs):
        # args是一个数组，kwargs一个字典
        logging.warn(&quot;%s is running&quot; % func.__name__)
        return func(*args, **kwargs)
    return wrapper
</code></pre>
<h3 id="带参数的装饰器"><strong>带参数的装饰器</strong></h3>
<p>装饰器还有更大的灵活性，例如带参数的装饰器，在上面的装饰器调用中，该装饰器接收唯一的参数就是执行业务的函数 foo 。装饰器的语法允许我们在调用时，提供其它参数，比如@decorator(a)。这样，就为装饰器的编写和使用提供了更大的灵活性。比如，我们可以在装饰器中指定日志的等级，因为不同业务函数可能需要的日志级别是不一样的。</p>
<pre><code class="language-python">def use_logging(level):
    def decorator(func):
        def wrapper(*args, **kwargs):
            if level == &quot;warn&quot;:
                logging.warn(&quot;%s is running&quot; % func.__name__)
            elif level == &quot;info&quot;:
                logging.info(&quot;%s is running&quot; % func.__name__)
            return func(*args)
        return wrapper

    return decorator

@use_logging(level=&quot;warn&quot;)
def foo(name='foo'):
    print(&quot;i am %s&quot; % name)

foo()
</code></pre>
<p>上面的 use_logging 是允许带参数的装饰器。它实际上是对原有装饰器的一个函数封装，并返回一个装饰器。我们可以将它理解为一个含有参数的闭包。当我 们使用@use_logging(level=&quot;warn&quot;)调用的时候，Python 能够发现这一层的封装，并把参数传递到装饰器的环境中。</p>
<p><strong>@use_logging(level=&quot;warn&quot;)等价于@decorator</strong></p>
<h3 id="类装饰器"><strong>类装饰器</strong></h3>
<p>没错，装饰器不仅可以是函数，还可以是类，相比函数装饰器，类装饰器具有灵活度大、高内聚、封装性等优点。使用类装饰器主要依靠类的__call__方法，当使用 @ 形式将装饰器附加到函数上时，就会调用此方法。</p>
<pre><code class="language-python">class Foo(object):
    def __init__(self, func):
        self._func = func

    def __call__(self):
        print ('class decorator runing')
        self._func()
        print ('class decorator ending')

@Foo
def bar():
    print ('bar')

bar()
</code></pre>
<h3 id="functoolswraps"><strong>functools.wraps</strong></h3>
<p>使用装饰器极大地复用了代码，但是他有一个缺点就是原函数的元信息不见了，比如函数的docstring、<strong>name</strong>、参数列表，先看例子：</p>
<pre><code class="language-python"># 装饰器
def logged(func):
    def with_logging(*args, **kwargs):
        print func.__name__      # 输出 'with_logging'
        print func.__doc__       # 输出 None
        return func(*args, **kwargs)
    return with_logging

# 函数
@logged
def f(x):
   &quot;&quot;&quot;does some math&quot;&quot;&quot;
   return x + x * x

logged(f)
</code></pre>
<p>不难发现，函数 f 被with_logging取代了，当然它的docstring，__name__就是变成了with_logging函数的信息了。好在我们有functools.wraps，wraps本身也是一个装饰器，它能把原函数的元信息拷贝到装饰器里面的 func 函数中，这使得装饰器里面的 func 函数也有和原函数 foo 一样的元信息了。</p>
<pre><code class="language-python">from functools import wraps
def logged(func):
    @wraps(func)
    def with_logging(*args, **kwargs):
        print func.__name__      # 输出 'f'
        print func.__doc__       # 输出 'does some math'
        return func(*args, **kwargs)
    return with_logging

@logged
def f(x):
   &quot;&quot;&quot;does some math&quot;&quot;&quot;
   return x + x * x
</code></pre>
<h3 id="装饰器顺序"><strong>装饰器顺序</strong></h3>
<p>一个函数还可以同时定义多个装饰器，比如：</p>
<pre><code class="language-python">@a
@b
@c
def f ():
    pass
</code></pre>
<p>它的执行顺序是从里到外，最先调用最里层的装饰器，最后调用最外层的装饰器，它等效于</p>
<pre><code class="language-python">f = a(b(c(f)))
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SqlAlchemy relationship函数 之 backref参数反向引用的理解]]></title>
        <id>https://skytotwo.github.io//post/sqlalchemy-relationship</id>
        <link href="https://skytotwo.github.io//post/sqlalchemy-relationship">
        </link>
        <updated>2019-08-26T07:29:45.000Z</updated>
        <summary type="html"><![CDATA[<p>简单来说, relationship函数是sqlalchemy对关系之间提供的一种便利的调用方式, backref参数则对关系提供反向引用的声明。</p>
]]></summary>
        <content type="html"><![CDATA[<p>简单来说, relationship函数是sqlalchemy对关系之间提供的一种便利的调用方式, backref参数则对关系提供反向引用的声明。</p>
<!-- more --> 
<p>如下例子：</p>
<pre><code class="language-python"># 电影
class Movie(db.Model):
    __tablename__ = &quot;movie&quot;
    id = db.Column(db.Integer, primary_key=True)  # 编号
    title = db.Column(db.String(255), unique=True)  # 标题
    url = db.Column(db.String(255), unique=True)  # 地址
    info = db.Column(db.Text)  # 电影简介
    logo = db.Column(db.String(255), unique=True)  # 封面
    star = db.Column(db.SmallInteger)  # 星级
    playnum = db.Column(db.BigInteger)  # 播放量
    commentnum = db.Column(db.BigInteger)  # 评论量
    #  （设置外键第一步）
    tag_id = db.Column(db.Integer, db.ForeignKey('tag.id'))  # 所属标签
    area = db.Column(db.String(255))  # 上映地区
    release_time = db.Column(db.Date)  # 上映时间
    length = db.Column(db.String(100))  # 播放时间
    addtime = db.Column(db.DateTime, index=True, default=datetime.now)  # 添加时间
    comments = db.relationship(&quot;Comment&quot;, backref='movie')  # 评论外键关系关联
    moviecols = db.relationship(&quot;Moviecol&quot;, backref='movie')  # 收藏外键关系关联

    def __repr__(self):
        return &quot;&lt;Movie %r&gt;&quot; % self.title

</code></pre>
<pre><code class="language-python"># 评论
class Comment(db.Model):
    __tablename__ = &quot;comment&quot;
    id = db.Column(db.Integer, primary_key=True)  # 编号
    content = db.Column(db.Text)  # 评论内容
    # 关联外键第一步，还要去user表和movie表进行第二步
    movie_id = db.Column(db.Integer, db.ForeignKey('movie.id'))  # 所属电影
    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))  # 所属用户
    addtime = db.Column(db.DateTime, index=True, default=datetime.now)  # 添加时间

    def __repr__(self):
        return &quot;&lt;Comment %r&gt;&quot; % self.id
</code></pre>
<p>如果在Movie中使用relationship定义comment属性的话，就可以实例化Movie对象的时候调用comment属性，如下所示：</p>
<pre><code class="language-python">movie = Movie.query.get_or_404(int(id))
comment = movie.comment
</code></pre>
<p>注意，这里的到的comment，可以取出comment表中的所有属性字段，如果有外键，甚至外键的所属的表数据也能找到。</p>
<p>而定义的backref参数则对关系提供反向引用的声明。意思就是电影中relationship函数定义了backref，然后实例化Comment后，该对象可以反向找到backref指向的表，具体如下：</p>
<pre><code class="language-python">comment = Comment.query.get_or_404(int(id))
movie = comment.movie
</code></pre>
<p>除了可以拿到movie表所有字段，还能拿到完成度的relationship指向的comments中comment表数据。</p>
<p>例子示例2：<br>
一对多：一个父亲可能有多个孩子</p>
<pre><code class="language-python">1     class Father(……): 
2         id = …… 
3         children = db.relationship('Children', backref='father') 
4
5     class Children(……): 
6         # ……
7         father_id = …… ForeignKey('father.id'))
</code></pre>
<pre><code class="language-python">1 我是爸爸
2 我是身份证号
3 我有一些孩子登记在Children表上。上面的每一个children都可以通过 . father找到我。backref是我给孩子们的名片（上面是身份证号）。
5 我们是孩子们 
7 我拿着爸爸的身份证号

</code></pre>
<p>当我们需要在父表中添加子表关系时使用 relationship，外键通常是父表的主键</p>
]]></content>
    </entry>
</feed>