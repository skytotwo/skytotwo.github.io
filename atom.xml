<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skytotwo.github.io/</id>
    <title>Totoro ã® home</title>
    <updated>2019-06-14T14:28:31.330Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skytotwo.github.io/"/>
    <link rel="self" href="https://skytotwo.github.io//atom.xml"/>
    <subtitle>ç©ºæ¯å¿ƒæ€ï¼Œæ¯å¤©è¿›æ­¥</subtitle>
    <logo>https://skytotwo.github.io//images/avatar.png</logo>
    <icon>https://skytotwo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Totoro ã® home</rights>
    <entry>
        <title type="html"><![CDATA[asyncio ç®€ä»‹]]></title>
        <id>https://skytotwo.github.io//post/asyncio-jian-jie</id>
        <link href="https://skytotwo.github.io//post/asyncio-jian-jie">
        </link>
        <updated>2019-06-14T13:30:12.000Z</updated>
        <summary type="html"><![CDATA[<p>ä¸€ç›´å¯¹asyncioè¿™ä¸ªåº“æ¯”è¾ƒæ„Ÿå…´è¶£ï¼Œæ¯•ç«Ÿè¿™æ˜¯å®˜ç½‘ä¹Ÿéå¸¸æ¨èçš„ä¸€ä¸ªå®ç°é«˜å¹¶å‘çš„ä¸€ä¸ªæ¨¡å—ï¼Œpythonä¹Ÿæ˜¯åœ¨python 3.4ä¸­å¼•å…¥äº†åç¨‹çš„æ¦‚å¿µã€‚ä¹Ÿé€šè¿‡è¿™æ¬¡æ•´ç†æ›´åŠ æ·±åˆ»ç†è§£è¿™ä¸ªæ¨¡å—çš„ä½¿ç”¨</p>
]]></summary>
        <content type="html"><![CDATA[<p>ä¸€ç›´å¯¹asyncioè¿™ä¸ªåº“æ¯”è¾ƒæ„Ÿå…´è¶£ï¼Œæ¯•ç«Ÿè¿™æ˜¯å®˜ç½‘ä¹Ÿéå¸¸æ¨èçš„ä¸€ä¸ªå®ç°é«˜å¹¶å‘çš„ä¸€ä¸ªæ¨¡å—ï¼Œpythonä¹Ÿæ˜¯åœ¨python 3.4ä¸­å¼•å…¥äº†åç¨‹çš„æ¦‚å¿µã€‚ä¹Ÿé€šè¿‡è¿™æ¬¡æ•´ç†æ›´åŠ æ·±åˆ»ç†è§£è¿™ä¸ªæ¨¡å—çš„ä½¿ç”¨</p>
<!--more-->
<p>ä¸€ç›´å¯¹asyncioè¿™ä¸ªåº“æ¯”è¾ƒæ„Ÿå…´è¶£ï¼Œæ¯•ç«Ÿè¿™æ˜¯å®˜ç½‘ä¹Ÿéå¸¸æ¨èçš„ä¸€ä¸ªå®ç°é«˜å¹¶å‘çš„ä¸€ä¸ªæ¨¡å—ï¼Œpythonä¹Ÿæ˜¯åœ¨python 3.4ä¸­å¼•å…¥äº†åç¨‹çš„æ¦‚å¿µã€‚ä¹Ÿé€šè¿‡è¿™æ¬¡æ•´ç†æ›´åŠ æ·±åˆ»ç†è§£è¿™ä¸ªæ¨¡å—çš„ä½¿ç”¨</p>
<h3 id="asyncio-æ˜¯å¹²ä»€ä¹ˆçš„">asyncio æ˜¯å¹²ä»€ä¹ˆçš„ï¼Ÿ</h3>
<h4 id="å¼‚æ­¥ç½‘ç»œæ“ä½œ">å¼‚æ­¥ç½‘ç»œæ“ä½œ</h4>
<ul>
<li>å¹¶å‘</li>
<li>åç¨‹</li>
</ul>
<p>python3.0æ—¶ä»£ï¼Œæ ‡å‡†åº“é‡Œçš„å¼‚æ­¥ç½‘ç»œæ¨¡å—ï¼šselect(éå¸¸åº•å±‚) python3.0æ—¶ä»£ï¼Œç¬¬ä¸‰æ–¹å¼‚æ­¥ç½‘ç»œåº“ï¼šTornado python3.4æ—¶ä»£ï¼Œasyncioï¼šæ”¯æŒTCP,å­è¿›ç¨‹ã€‚</p>
<p>ç°åœ¨çš„asyncioï¼Œæœ‰äº†å¾ˆå¤šçš„æ¨¡å—å·²ç»åœ¨æ”¯æŒï¼šaiohttp,aiodns,aioredisç­‰ç­‰ https://github.com/aio-libs è¿™é‡Œåˆ—å‡ºäº†å·²ç»æ”¯æŒçš„å†…å®¹ï¼Œå¹¶åœ¨æŒç»­æ›´æ–°</p>
<p>å½“ç„¶åˆ°ç›®å‰ä¸ºæ­¢å®ç°åç¨‹çš„ä¸ä»…ä»…åªæœ‰asyncio,tornadoå’Œgeventéƒ½å®ç°äº†ç±»ä¼¼åŠŸèƒ½</p>
<hr>
<p><strong>å…³äºasyncioçš„ä¸€äº›å…³é”®å­—çš„è¯´æ˜ï¼š</strong></p>
<ul>
<li>
<p>event_loop äº‹ä»¶å¾ªç¯ï¼šç¨‹åºå¼€å¯ä¸€ä¸ªæ— é™å¾ªç¯ï¼ŒæŠŠä¸€äº›å‡½æ•°æ³¨å†Œåˆ°äº‹ä»¶å¾ªç¯ä¸Šï¼Œå½“æ»¡è¶³äº‹ä»¶å‘ç”Ÿçš„æ—¶å€™ï¼Œè°ƒç”¨ç›¸åº”çš„åç¨‹å‡½æ•°</p>
</li>
<li>
<p>coroutine åç¨‹ï¼šåç¨‹å¯¹è±¡ï¼ŒæŒ‡ä¸€ä¸ªä½¿ç”¨asyncå…³é”®å­—å®šä¹‰çš„å‡½æ•°ï¼Œå®ƒçš„è°ƒç”¨ä¸ä¼šç«‹å³æ‰§è¡Œå‡½æ•°ï¼Œè€Œæ˜¯ä¼šè¿”å›ä¸€ä¸ªåç¨‹å¯¹è±¡ã€‚åç¨‹å¯¹è±¡éœ€è¦æ³¨å†Œåˆ°äº‹ä»¶å¾ªç¯ï¼Œç”±äº‹ä»¶å¾ªç¯è°ƒç”¨ã€‚</p>
</li>
<li>
<p>task ä»»åŠ¡ï¼šä¸€ä¸ªåç¨‹å¯¹è±¡å°±æ˜¯ä¸€ä¸ªåŸç”Ÿå¯ä»¥æŒ‚èµ·çš„å‡½æ•°ï¼Œä»»åŠ¡åˆ™æ˜¯å¯¹åç¨‹è¿›ä¸€æ­¥å°è£…ï¼Œå…¶ä¸­åŒ…å«äº†ä»»åŠ¡çš„å„ç§çŠ¶æ€</p>
</li>
<li>
<p>future: ä»£è¡¨å°†æ¥æ‰§è¡Œæˆ–æ²¡æœ‰æ‰§è¡Œçš„ä»»åŠ¡çš„ç»“æœã€‚å®ƒå’Œtaskä¸Šæ²¡æœ‰æœ¬è´¨ä¸Šçš„åŒºåˆ«</p>
</li>
<li>
<p>async/await å…³é”®å­—ï¼špython3.5ç”¨äºå®šä¹‰åç¨‹çš„å…³é”®å­—ï¼Œasyncå®šä¹‰ä¸€ä¸ªåç¨‹ï¼Œawaitç”¨äºæŒ‚èµ·é˜»å¡çš„å¼‚æ­¥è°ƒç”¨æ¥å£ã€‚</p>
</li>
</ul>
<p>çœ‹äº†ä¸Šé¢è¿™äº›å…³é”®å­—ï¼Œä½ å¯èƒ½æ‰­å¤´å°±èµ°äº†ï¼Œå…¶å®ä¸€å¼€å§‹äº†è§£å’Œç ”ç©¶asyncioè¿™ä¸ªæ¨¡å—æœ‰ç§æŠµè§¦ï¼Œè‡ªå·±ä¹Ÿä¸çŸ¥é“ä¸ºå•¥ï¼Œè¿™ä¹Ÿå¯¼è‡´å¾ˆé•¿ä¸€æ®µæ—¶é—´ï¼Œè¿™ä¸ªæ¨¡å—è‡ªå·±ä¹ŸåŸºæœ¬å°±æ²¡æœ‰å…³æ³¨å’Œä½¿ç”¨ï¼Œä½†æ˜¯éšç€å·¥ä½œä¸Šç”¨pythoné‡åˆ°å„ç§æ€§èƒ½é—®é¢˜çš„æ—¶å€™ï¼Œè‡ªå·±å‘Šè¯‰è‡ªå·±è¿˜æ˜¯è¦å¥½å¥½å­¦ä¹ å­¦ä¹ è¿™ä¸ªæ¨¡å—ã€‚</p>
<hr>
<h4 id="å®šä¹‰ä¸€ä¸ªåç¨‹"><strong>å®šä¹‰ä¸€ä¸ªåç¨‹</strong></h4>
<pre><code class="language-python">import time
import asyncio


now = lambda : time.time()


async def do_some_work(x):
    print(&quot;waiting:&quot;, x)

start = now()
# è¿™é‡Œæ˜¯ä¸€ä¸ªåç¨‹å¯¹è±¡ï¼Œè¿™ä¸ªæ—¶å€™do_some_workå‡½æ•°å¹¶æ²¡æœ‰æ‰§è¡Œ
coroutine = do_some_work(2)
print(coroutine)
#  åˆ›å»ºä¸€ä¸ªäº‹ä»¶loop
loop = asyncio.get_event_loop()
# å°†åç¨‹åŠ å…¥åˆ°äº‹ä»¶å¾ªç¯loop
loop.run_until_complete(coroutine)

print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>åœ¨ä¸Šé¢å¸¦ä¸­æˆ‘ä»¬é€šè¿‡asyncå…³é”®å­—å®šä¹‰ä¸€ä¸ªåç¨‹ï¼ˆcoroutineï¼‰,å½“ç„¶åç¨‹ä¸èƒ½ç›´æ¥è¿è¡Œï¼Œéœ€è¦å°†åç¨‹åŠ å…¥åˆ°äº‹ä»¶å¾ªç¯loopä¸­</p>
<p>**asyncio.get_event_loopï¼š**åˆ›å»ºä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼Œç„¶åä½¿ç”¨run_until_completeå°†åç¨‹æ³¨å†Œåˆ°äº‹ä»¶å¾ªç¯ï¼Œå¹¶å¯åŠ¨äº‹ä»¶å¾ªç¯</p>
<hr>
<h4 id="åˆ›å»ºä¸€ä¸ªtask"><strong>åˆ›å»ºä¸€ä¸ªtask</strong></h4>
<p>åç¨‹å¯¹è±¡ä¸èƒ½ç›´æ¥è¿è¡Œï¼Œåœ¨æ³¨å†Œäº‹ä»¶å¾ªç¯çš„æ—¶å€™ï¼Œå…¶å®æ˜¯run_until_completeæ–¹æ³•å°†åç¨‹åŒ…è£…æˆä¸ºäº†ä¸€ä¸ªä»»åŠ¡ï¼ˆtaskï¼‰å¯¹è±¡. taskå¯¹è±¡æ˜¯Futureç±»çš„å­ç±»ï¼Œä¿å­˜äº†åç¨‹è¿è¡Œåçš„çŠ¶æ€ï¼Œç”¨äºæœªæ¥è·å–åç¨‹çš„ç»“æœ</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()


async def do_some_work(x):
    print(&quot;waiting:&quot;, x)

start = now()

coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = loop.create_task(coroutine)
print(task)
loop.run_until_complete(task)
print(task)
print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>ç»“æœä¸ºï¼š</p>
<pre><code class="language-python">&lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex2.py:13&gt;&gt;
waiting: 2
&lt;Task finished coro=&lt;do_some_work() done, defined at /app/py_code/study_asyncio/simple_ex2.py:13&gt; result=None&gt;
Time: 0.0003514289855957031
</code></pre>
<p>åˆ›å»ºtaskåï¼Œåœ¨taskåŠ å…¥äº‹ä»¶å¾ªç¯ä¹‹å‰ä¸ºpendingçŠ¶æ€ï¼Œå½“å®Œæˆåï¼ŒçŠ¶æ€ä¸ºfinished</p>
<p>å…³äºä¸Šé¢é€šè¿‡loop.create_task(coroutine)åˆ›å»ºtask,åŒæ ·çš„å¯ä»¥é€šè¿‡ asyncio.ensure_future(coroutine)åˆ›å»ºtask</p>
<p>å…³äºè¿™ä¸¤ä¸ªå‘½ä»¤çš„å®˜ç½‘è§£é‡Šï¼š https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future</p>
<pre><code class="language-python">asyncio.ensure_future(coro_or_future, *, loop=None)
Schedule the execution of a coroutine object: wrap it in a future. Return a Task object.

If the argument is a Future, it is returned directly.
</code></pre>
<p>https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task</p>
<pre><code class="language-python">AbstractEventLoop.create_task(coro)
Schedule the execution of a coroutine object: wrap it in a future. Return a Task object.

Third-party event loops can use their own subclass of Task for interoperability. In this case, the result type is a subclass of Task.

This method was added in Python 3.4.2. Use the async() function to support also older Python versions
</code></pre>
<hr>
<h4 id="ç»‘å®šå›è°ƒ"><strong>ç»‘å®šå›è°ƒ</strong></h4>
<p>ç»‘å®šå›è°ƒï¼Œåœ¨taskæ‰§è¡Œå®Œæˆçš„æ—¶å€™å¯ä»¥è·å–æ‰§è¡Œçš„ç»“æœï¼Œå›è°ƒçš„æœ€åä¸€ä¸ªå‚æ•°æ˜¯futureå¯¹è±¡ï¼Œé€šè¿‡è¯¥å¯¹è±¡å¯ä»¥è·å–åç¨‹è¿”å›å€¼ã€‚</p>
<pre><code class="language-python">import time
import asyncio


now = lambda : time.time()


async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    return &quot;Done after {}s&quot;.format(x)


def callback(future):
    print(&quot;callback:&quot;,future.result())


start = now()
coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(coroutine)
print(task)
task.add_done_callback(callback)
print(task)
loop.run_until_complete(task)

print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>ç»“æœä¸ºï¼š</p>
<pre><code class="language-python">&lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex3.py:13&gt;&gt;
&lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex3.py:13&gt; cb=[callback() at /app/py_code/study_asyncio/simple_ex3.py:18]&gt;
waiting: 2
callback: Done after 2s
Time: 0.00039196014404296875
</code></pre>
<p>é€šè¿‡add_done_callbackæ–¹æ³•ç»™taskä»»åŠ¡æ·»åŠ å›è°ƒå‡½æ•°ï¼Œå½“taskï¼ˆä¹Ÿå¯ä»¥è¯´æ˜¯coroutineï¼‰æ‰§è¡Œå®Œæˆçš„æ—¶å€™,å°±ä¼šè°ƒç”¨å›è°ƒå‡½æ•°ã€‚å¹¶é€šè¿‡å‚æ•°futureè·å–åç¨‹æ‰§è¡Œçš„ç»“æœã€‚è¿™é‡Œæˆ‘ä»¬åˆ›å»º çš„taskå’Œå›è°ƒé‡Œçš„futureå¯¹è±¡å®é™…ä¸Šæ˜¯åŒä¸€ä¸ªå¯¹è±¡</p>
<hr>
<h4 id="é˜»å¡å’Œawait"><strong>é˜»å¡å’Œawait</strong></h4>
<p>ä½¿ç”¨asyncå¯ä»¥å®šä¹‰åç¨‹å¯¹è±¡ï¼Œä½¿ç”¨awaitå¯ä»¥é’ˆå¯¹è€—æ—¶çš„æ“ä½œè¿›è¡ŒæŒ‚èµ·ï¼Œå°±åƒç”Ÿæˆå™¨é‡Œçš„yieldä¸€æ ·ï¼Œå‡½æ•°è®©å‡ºæ§åˆ¶æƒã€‚åç¨‹é‡åˆ°awaitï¼Œäº‹ä»¶å¾ªç¯å°†ä¼šæŒ‚èµ·è¯¥åç¨‹ï¼Œæ‰§è¡Œåˆ«çš„åç¨‹ï¼Œç›´åˆ°å…¶ä»–çš„åç¨‹ä¹ŸæŒ‚èµ·æˆ–è€…æ‰§è¡Œå®Œæ¯•ï¼Œå†è¿›è¡Œä¸‹ä¸€ä¸ªåç¨‹çš„æ‰§è¡Œ</p>
<p>è€—æ—¶çš„æ“ä½œä¸€èˆ¬æ˜¯ä¸€äº›IOæ“ä½œï¼Œä¾‹å¦‚ç½‘ç»œè¯·æ±‚ï¼Œæ–‡ä»¶è¯»å–ç­‰ã€‚æˆ‘ä»¬ä½¿ç”¨asyncio.sleepå‡½æ•°æ¥æ¨¡æ‹ŸIOæ“ä½œã€‚åç¨‹çš„ç›®çš„ä¹Ÿæ˜¯è®©è¿™äº›IOæ“ä½œå¼‚æ­¥åŒ–ã€‚</p>
<pre><code class="language-python">import asyncio
import time



now = lambda :time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    # await åé¢å°±æ˜¯è°ƒç”¨è€—æ—¶çš„æ“ä½œ
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)


start = now()

coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(coroutine)
loop.run_until_complete(task)

print(&quot;Task ret:&quot;, task.result())
print(&quot;Time:&quot;, now() - start)
</code></pre>
<p>åœ¨await asyncio.sleep(x)ï¼Œå› ä¸ºè¿™é‡Œsleepäº†ï¼Œæ¨¡æ‹Ÿäº†é˜»å¡æˆ–è€…è€—æ—¶æ“ä½œï¼Œè¿™ä¸ªæ—¶å€™å°±ä¼šè®©å‡ºæ§åˆ¶æƒã€‚ å³å½“é‡åˆ°é˜»å¡è°ƒç”¨çš„å‡½æ•°çš„æ—¶å€™ï¼Œä½¿ç”¨awaitæ–¹æ³•å°†åç¨‹çš„æ§åˆ¶æƒè®©å‡º,ä»¥ä¾¿loopè°ƒç”¨å…¶ä»–çš„åç¨‹ã€‚</p>
<hr>
<h4 id="å¹¶å‘å’Œå¹¶è¡Œ"><strong>å¹¶å‘å’Œå¹¶è¡Œ</strong></h4>
<ul>
<li>
<p>å¹¶å‘ï¼šæŒ‡çš„æ˜¯ä¸€æ®µæ—¶é—´å†…æ‰§è¡Œå¤šæƒ³ä»»åŠ¡</p>
</li>
<li>
<p>å¹¶è¡Œï¼šæŒ‡çš„æ˜¯ç”¨åŒä¸€ä¸ªæ—¶é—´ç‚¹æ‰§è¡Œå¤šä¸ªä»»åŠ¡ã€‚</p>
</li>
</ul>
<p>ä¸‹é¢è¿™ä¸ªä¾‹å­éå¸¸å½¢è±¡ï¼š</p>
<p>å¹¶å‘æƒ…å†µä¸‹æ˜¯ä¸€ä¸ªè€å¸ˆåœ¨åŒä¸€æ—¶é—´æ®µè¾…åŠ©ä¸åŒçš„äººåŠŸè¯¾ã€‚å¹¶è¡Œåˆ™æ˜¯å¥½å‡ ä¸ªè€å¸ˆåˆ†åˆ«åŒæ—¶è¾…åŠ©å¤šä¸ªå­¦ç”ŸåŠŸè¯¾ã€‚ç®€è€Œè¨€ä¹‹å°±æ˜¯ä¸€ä¸ªäººåŒæ—¶åƒä¸‰ä¸ªé¦’å¤´è¿˜æ˜¯ä¸‰ä¸ªäººåŒæ—¶åˆ†åˆ«åƒä¸€ä¸ªçš„æƒ…å†µï¼Œåƒä¸€ä¸ªé¦’å¤´ç®—ä¸€ä¸ªä»»åŠ¡</p>
<pre><code class="language-python">import asyncio
import time


now = lambda :time.time()


async def do_some_work(x):
    print(&quot;Waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

start = now()

coroutine1 = do_some_work(1)
coroutine2 = do_some_work(2)
coroutine3 = do_some_work(4)

tasks = [
    asyncio.ensure_future(coroutine1),
    asyncio.ensure_future(coroutine2),
    asyncio.ensure_future(coroutine3)
]

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))

for task in tasks:
    print(&quot;Task ret:&quot;,task.result())

print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>è¿è¡Œç»“æœï¼š</p>
<pre><code class="language-python">Waiting: 1
Waiting: 2
Waiting: 4
Task ret: Done after 1s
Task ret: Done after 2s
Task ret: Done after 4s
Time: 4.004154920578003
</code></pre>
<p>æ€»æ—¶é—´ä¸º4så·¦å³ã€‚4sçš„é˜»å¡æ—¶é—´ï¼Œè¶³å¤Ÿå‰é¢ä¸¤ä¸ªåç¨‹æ‰§è¡Œå®Œæ¯•ã€‚å¦‚æœæ˜¯åŒæ­¥é¡ºåºçš„ä»»åŠ¡ï¼Œé‚£ä¹ˆè‡³å°‘éœ€è¦7sã€‚æ­¤æ—¶æˆ‘ä»¬ä½¿ç”¨äº†aysncioå®ç°äº†å¹¶å‘ã€‚asyncio.wait(tasks) ä¹Ÿå¯ä»¥ä½¿ç”¨ asyncio.gather(*tasks) ,å‰è€…æ¥å—ä¸€ä¸ªtaskåˆ—è¡¨ï¼Œåè€…æ¥æ”¶ä¸€å †taskã€‚</p>
<p>å…³äºasyncio.gatherå’Œasyncio.waitå®˜ç½‘çš„è¯´æ˜ï¼š</p>
<p>https://docs.python.org/3/library/asyncio-task.html#asyncio.gather</p>
<pre><code class="language-python">Return a future aggregating results from the given coroutine objects or futures.

All futures must share the same event loop. If all the tasks are done successfully, the returned futureâ€™s result is the list of results (in the order of the original sequence, not necessarily the order of results arrival). If return_exceptions is true, exceptions in the tasks are treated the same as successful results, and gathered in the result list; otherwise, the first raised exception will be immediately propagated to the returned future.
</code></pre>
<p>https://docs.python.org/3/library/asyncio-task.html#asyncio.wait</p>
<pre><code class="language-python">Wait for the Futures and coroutine objects given by the sequence futures to complete. Coroutines will be wrapped in Tasks. Returns two sets of Future: (done, pending).

The sequence futures must not be empty.

timeout can be used to control the maximum number of seconds to wait before returning. timeout can be an int or float. If timeout is not specified or None, there is no limit to the wait time.

return_when indicates when this function should return.
</code></pre>
<hr>
<h4 id="åç¨‹åµŒå¥—"><strong>åç¨‹åµŒå¥—</strong></h4>
<p>ä½¿ç”¨asyncå¯ä»¥å®šä¹‰åç¨‹ï¼Œåç¨‹ç”¨äºè€—æ—¶çš„ioæ“ä½œï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å°è£…æ›´å¤šçš„ioæ“ä½œè¿‡ç¨‹ï¼Œè¿™æ ·å°±å®ç°äº†åµŒå¥—çš„åç¨‹ï¼Œå³ä¸€ä¸ªåç¨‹ä¸­awaitäº†å¦å¤–ä¸€ä¸ªåç¨‹ï¼Œå¦‚æ­¤è¿æ¥èµ·æ¥ã€‚</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]

    dones, pendings = await asyncio.wait(tasks)
    for task in dones:
        print(&quot;Task ret:&quot;, task.result())

    # results = await asyncio.gather(*tasks)
    # for result in results:
    #     print(&quot;Task ret:&quot;,result)


start = now()

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>å¦‚æœæˆ‘ä»¬æŠŠä¸Šé¢ä»£ç ä¸­çš„ï¼š</p>
<pre><code class="language-python">    dones, pendings = await asyncio.wait(tasks)
    for task in dones:
        print(&quot;Task ret:&quot;, task.result())
</code></pre>
<p>æ›¿æ¢ä¸ºï¼š</p>
<pre><code class="language-python">results = await asyncio.gather(*tasks)
 for result in results:
     print(&quot;Task ret:&quot;,result)
</code></pre>
<p>è¿™æ ·å¾—åˆ°çš„å°±æ˜¯ä¸€ä¸ªç»“æœçš„åˆ—è¡¨</p>
<p>ä¸åœ¨mainåç¨‹å‡½æ•°é‡Œå¤„ç†ç»“æœï¼Œç›´æ¥è¿”å›awaitçš„å†…å®¹ï¼Œé‚£ä¹ˆæœ€å¤–å±‚çš„run_until_completeå°†ä¼šè¿”å›mainåç¨‹çš„ç»“æœã€‚ å°†ä¸Šè¿°çš„ä»£ç æ›´æ”¹ä¸ºï¼š</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    return await asyncio.gather(*tasks)

start = now()

loop = asyncio.get_event_loop()
results = loop.run_until_complete(main())
for result in results:
    print(&quot;Task ret:&quot;,result)

print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>æˆ–è€…è¿”å›ä½¿ç”¨asyncio.waitæ–¹å¼æŒ‚èµ·åç¨‹ã€‚</p>
<p>å°†ä»£ç æ›´æ”¹ä¸ºï¼š</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    return await asyncio.wait(tasks)

start = now()

loop = asyncio.get_event_loop()
done,pending = loop.run_until_complete(main())
for task in done:
    print(&quot;Task ret:&quot;,task.result())

print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>ä¹Ÿå¯ä»¥ä½¿ç”¨asyncioçš„as_completedæ–¹æ³•</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    for task in asyncio.as_completed(tasks):
        result = await task
        print(&quot;Task ret: {}&quot;.format(result))

start = now()

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>ä»ä¸Šé¢ä¹Ÿå¯ä»¥çœ‹å‡ºï¼Œåç¨‹çš„è°ƒç”¨å’Œç»„åˆéå¸¸çµæ´»ï¼Œä¸»è¦ä½“ç°åœ¨å¯¹äºç»“æœçš„å¤„ç†ï¼šå¦‚ä½•è¿”å›ï¼Œå¦‚ä½•æŒ‚èµ·</p>
<hr>
<h4 id="åç¨‹çš„åœæ­¢"><strong>åç¨‹çš„åœæ­¢</strong></h4>
<p>futureå¯¹è±¡æœ‰å‡ ä¸ªçŠ¶æ€ï¼š</p>
<ul>
<li>Pending</li>
<li>Running</li>
<li>Done</li>
<li>Cacelled
åˆ›å»ºfutureçš„æ—¶å€™ï¼Œtaskä¸ºpendingï¼Œäº‹ä»¶å¾ªç¯è°ƒç”¨æ‰§è¡Œçš„æ—¶å€™å½“ç„¶å°±æ˜¯runningï¼Œè°ƒç”¨å®Œæ¯•è‡ªç„¶å°±æ˜¯doneï¼Œå¦‚æœéœ€è¦åœæ­¢äº‹ä»¶å¾ªç¯ï¼Œå°±éœ€è¦å…ˆæŠŠtaskå–æ¶ˆã€‚å¯ä»¥ä½¿ç”¨asyncio.Taskè·å–äº‹ä»¶å¾ªç¯çš„task</li>
</ul>
<pre><code class="language-python">import asyncio
import time


now = lambda :time.time()


async def do_some_work(x):
    print(&quot;Waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

coroutine1 =do_some_work(1)
coroutine2 =do_some_work(2)
coroutine3 =do_some_work(2)

tasks = [
    asyncio.ensure_future(coroutine1),
    asyncio.ensure_future(coroutine2),
    asyncio.ensure_future(coroutine3),
]

start = now()

loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(asyncio.wait(tasks))
except KeyboardInterrupt as e:
    print(asyncio.Task.all_tasks())
    for task in asyncio.Task.all_tasks():
        print(task.cancel())
    loop.stop()
    loop.run_forever()
finally:
    loop.close()

print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>å¯åŠ¨äº‹ä»¶å¾ªç¯ä¹‹åï¼Œé©¬ä¸Šctrl+cï¼Œä¼šè§¦å‘run_until_completeçš„æ‰§è¡Œå¼‚å¸¸ KeyBorardInterruptã€‚ç„¶åé€šè¿‡å¾ªç¯asyncio.Taskå–æ¶ˆfutureã€‚å¯ä»¥çœ‹åˆ°è¾“å‡ºå¦‚ä¸‹ï¼š</p>
<pre><code class="language-python">Waiting: 1
Waiting: 2
Waiting: 2
^C{&lt;Task finished coro=&lt;do_some_work() done, defined at /app/py_code/study_asyncio/simple_ex10.py:13&gt; result='Done after 1s'&gt;, &lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex10.py:15&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /usr/local/lib/python3.5/asyncio/tasks.py:428]&gt;, &lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex10.py:15&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /usr/local/lib/python3.5/asyncio/tasks.py:428]&gt;, &lt;Task pending coro=&lt;wait() running at /usr/local/lib/python3.5/asyncio/tasks.py:361&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt;&gt;}
False
True
True
True
Time: 1.0707225799560547
</code></pre>
<p>Trueè¡¨ç¤ºcannelæˆåŠŸï¼Œloop stopä¹‹åè¿˜éœ€è¦å†æ¬¡å¼€å¯äº‹ä»¶å¾ªç¯ï¼Œæœ€ååœ¨closeï¼Œä¸ç„¶è¿˜ä¼šæŠ›å‡ºå¼‚å¸¸</p>
<p>å¾ªç¯taskï¼Œé€ä¸ªcancelæ˜¯ä¸€ç§æ–¹æ¡ˆï¼Œå¯æ˜¯æ­£å¦‚ä¸Šé¢æˆ‘ä»¬æŠŠtaskçš„åˆ—è¡¨å°è£…åœ¨mainå‡½æ•°ä¸­ï¼Œmainå‡½æ•°å¤–è¿›è¡Œäº‹ä»¶å¾ªç¯çš„è°ƒç”¨ã€‚è¿™ä¸ªæ—¶å€™ï¼Œmainç›¸å½“äºæœ€å¤–å‡ºçš„ä¸€ä¸ªtaskï¼Œé‚£ä¹ˆå¤„ç†åŒ…è£…çš„mainå‡½æ•°å³å¯ã€‚</p>
<hr>
<h4 id="ä¸åŒçº¿ç¨‹çš„äº‹ä»¶å¾ªç¯"><strong>ä¸åŒçº¿ç¨‹çš„äº‹ä»¶å¾ªç¯</strong></h4>
<p>å¾ˆå¤šæ—¶å€™ï¼Œæˆ‘ä»¬çš„äº‹ä»¶å¾ªç¯ç”¨äºæ³¨å†Œåç¨‹ï¼Œè€Œæœ‰çš„åç¨‹éœ€è¦åŠ¨æ€çš„æ·»åŠ åˆ°äº‹ä»¶å¾ªç¯ä¸­ã€‚ä¸€ä¸ªç®€å•çš„æ–¹å¼å°±æ˜¯ä½¿ç”¨å¤šçº¿ç¨‹ã€‚å½“å‰çº¿ç¨‹åˆ›å»ºä¸€ä¸ªäº‹ä»¶å¾ªç¯ï¼Œç„¶ååœ¨æ–°å»ºä¸€ä¸ªçº¿ç¨‹ï¼Œåœ¨æ–°çº¿ç¨‹ä¸­å¯åŠ¨äº‹ä»¶å¾ªç¯ã€‚å½“å‰çº¿ç¨‹ä¸ä¼šè¢«blockã€‚</p>
<pre><code class="language-python">import asyncio
from threading import Thread
import time

now = lambda :time.time()

def start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

def more_work(x):
    print('More work {}'.format(x))
    time.sleep(x)
    print('Finished more work {}'.format(x))

start = now()
new_loop = asyncio.new_event_loop()
t = Thread(target=start_loop, args=(new_loop,))
t.start()
print('TIME: {}'.format(time.time() - start))

new_loop.call_soon_threadsafe(more_work, 6)
new_loop.call_soon_threadsafe(more_work, 3)
</code></pre>
<p>å¯åŠ¨ä¸Šè¿°ä»£ç ä¹‹åï¼Œå½“å‰çº¿ç¨‹ä¸ä¼šè¢«blockï¼Œæ–°çº¿ç¨‹ä¸­ä¼šæŒ‰ç…§é¡ºåºæ‰§è¡Œcall_soon_threadsafeæ–¹æ³•æ³¨å†Œçš„more_workæ–¹æ³•ï¼Œ åè€…å› ä¸ºtime.sleepæ“ä½œæ˜¯åŒæ­¥é˜»å¡çš„ï¼Œå› æ­¤è¿è¡Œå®Œæ¯•more_workéœ€è¦å¤§è‡´6 + 3</p>
<hr>
<h4 id="æ–°çº¿ç¨‹åç¨‹"><strong>æ–°çº¿ç¨‹åç¨‹</strong></h4>
<pre><code class="language-python">import asyncio
import time
from threading import Thread

now = lambda :time.time()


def start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

async def do_some_work(x):
    print('Waiting {}'.format(x))
    await asyncio.sleep(x)
    print('Done after {}s'.format(x))

def more_work(x):
    print('More work {}'.format(x))
    time.sleep(x)
    print('Finished more work {}'.format(x))

start = now()
new_loop = asyncio.new_event_loop()
t = Thread(target=start_loop, args=(new_loop,))
t.start()
print('TIME: {}'.format(time.time() - start))

asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop)
asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop)
</code></pre>
<p>ä¸Šè¿°çš„ä¾‹å­ï¼Œä¸»çº¿ç¨‹ä¸­åˆ›å»ºä¸€ä¸ªnew_loopï¼Œç„¶ååœ¨å¦å¤–çš„å­çº¿ç¨‹ä¸­å¼€å¯ä¸€ä¸ªæ— é™äº‹ä»¶å¾ªç¯ã€‚ ä¸»çº¿ç¨‹é€šè¿‡run_coroutine_threadsafeæ–°æ³¨å†Œåç¨‹å¯¹è±¡ã€‚è¿™æ ·å°±èƒ½åœ¨å­çº¿ç¨‹ä¸­è¿›è¡Œäº‹ä»¶å¾ªç¯çš„å¹¶å‘æ“ä½œï¼ŒåŒæ—¶ä¸»çº¿ç¨‹åˆä¸ä¼šè¢«blockã€‚ä¸€å…±æ‰§è¡Œçš„æ—¶é—´å¤§æ¦‚åœ¨6så·¦å³ã€‚</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[æµ‹è¯•]]></title>
        <id>https://skytotwo.github.io//post/ce-shi</id>
        <link href="https://skytotwo.github.io//post/ce-shi">
        </link>
        <updated>2019-06-14T13:13:11.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p>####3æµ‹è¯•</p>
<p>â€”â€”â€”â€”</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://skytotwo.github.io//post/hello-gridea</id>
        <link href="https://skytotwo.github.io//post/hello-gridea">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>ğŸ‘  æ¬¢è¿ä½¿ç”¨ <strong>Gridea</strong> ï¼<br>
âœï¸  <strong>Gridea</strong> ä¸€ä¸ªé™æ€åšå®¢å†™ä½œå®¢æˆ·ç«¯ã€‚ä½ å¯ä»¥ç”¨å®ƒæ¥è®°å½•ä½ çš„ç”Ÿæ´»ã€å¿ƒæƒ…ã€çŸ¥è¯†ã€ç¬”è®°ã€åˆ›æ„... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="http://hvenotes.fehey.com/">Gridea ä¸»é¡µ</a><br>
<a href="http://fehey.com/">ç¤ºä¾‹ç½‘ç«™</a></p>
<h2 id="ç‰¹æ€§">ç‰¹æ€§ğŸ‘‡</h2>
<p>ğŸ“  ä½ å¯ä»¥ä½¿ç”¨æœ€é…·çš„ <strong>Markdown</strong> è¯­æ³•ï¼Œè¿›è¡Œå¿«é€Ÿåˆ›ä½œ</p>
<p>ğŸŒ‰  ä½ å¯ä»¥ç»™æ–‡ç« é…ä¸Šç²¾ç¾çš„å°é¢å›¾å’Œåœ¨æ–‡ç« ä»»æ„ä½ç½®æ’å…¥å›¾ç‰‡</p>
<p>ğŸ·ï¸  ä½ å¯ä»¥å¯¹æ–‡ç« è¿›è¡Œæ ‡ç­¾åˆ†ç»„</p>
<p>ğŸ“‹  ä½ å¯ä»¥è‡ªå®šä¹‰èœå•ï¼Œç”šè‡³å¯ä»¥åˆ›å»ºå¤–éƒ¨é“¾æ¥èœå•</p>
<p>ğŸ’»  ä½ å¯ä»¥åœ¨ <strong>ğ–¶ğ—‚ğ—‡ğ–½ğ—ˆğ—ğ—Œ</strong> æˆ– <strong>ğ–¬ğ–ºğ–¼ğ–®ğ–²</strong> è®¾å¤‡ä¸Šä½¿ç”¨æ­¤å®¢æˆ·ç«¯</p>
<p>ğŸŒ  ä½ å¯ä»¥ä½¿ç”¨ <strong>ğ–¦ğ—‚ğ—ğ—ğ—ğ–» ğ–¯ğ–ºğ—€ğ–¾ğ—Œ</strong> æˆ– <strong>Coding Pages</strong> å‘ä¸–ç•Œå±•ç¤ºï¼Œæœªæ¥å°†æ”¯æŒæ›´å¤šå¹³å°</p>
<p>ğŸ’¬  ä½ å¯ä»¥è¿›è¡Œç®€å•çš„é…ç½®ï¼Œæ¥å…¥ <a href="https://github.com/gitalk/gitalk">Gitalk</a> æˆ– <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> è¯„è®ºç³»ç»Ÿ</p>
<p>ğŸ‡¬ğŸ‡§  ä½ å¯ä»¥ä½¿ç”¨<strong>ä¸­æ–‡ç®€ä½“</strong>æˆ–<strong>è‹±è¯­</strong></p>
<p>ğŸŒ  ä½ å¯ä»¥ä»»æ„ä½¿ç”¨åº”ç”¨å†…é»˜è®¤ä¸»é¢˜æˆ–ä»»æ„ç¬¬ä¸‰æ–¹ä¸»é¢˜ï¼Œå¼ºå¤§çš„ä¸»é¢˜è‡ªå®šä¹‰èƒ½åŠ›</p>
<p>ğŸ–¥  ä½ å¯ä»¥è‡ªå®šä¹‰æºæ–‡ä»¶å¤¹ï¼Œåˆ©ç”¨ OneDriveã€ç™¾åº¦ç½‘ç›˜ã€iCloudã€Dropbox ç­‰è¿›è¡Œå¤šè®¾å¤‡åŒæ­¥</p>
<p>ğŸŒ± å½“ç„¶ <strong>Gridea</strong> è¿˜å¾ˆå¹´è½»ï¼Œæœ‰å¾ˆå¤šä¸è¶³ï¼Œä½†è¯·ç›¸ä¿¡ï¼Œå®ƒä¼šä¸åœå‘å‰ğŸƒ</p>
<p>æœªæ¥ï¼Œå®ƒä¸€å®šä¼šæˆä¸ºä½ ç¦»ä¸å¼€çš„ä¼™ä¼´</p>
<p>å°½æƒ…å‘æŒ¥ä½ çš„æ‰åå§ï¼</p>
<p>ğŸ˜˜ Enjoy~</p>
]]></content>
    </entry>
</feed>