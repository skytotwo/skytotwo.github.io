<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skytotwo.github.io/</id>
    <title>Totoro の Home</title>
    <updated>2019-10-26T02:09:03.142Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skytotwo.github.io/"/>
    <link rel="self" href="https://skytotwo.github.io//atom.xml"/>
    <subtitle>空杯心态，每天进步</subtitle>
    <logo>https://skytotwo.github.io//images/avatar.png</logo>
    <icon>https://skytotwo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Totoro の Home</rights>
    <entry>
        <title type="html"><![CDATA[用自签名SSL证书配合 CloudFlare 免费SSL构建全站HTTPS加密]]></title>
        <id>https://skytotwo.github.io//post/diy-ssl-cloudflare</id>
        <link href="https://skytotwo.github.io//post/diy-ssl-cloudflare">
        </link>
        <updated>2019-10-26T01:47:48.000Z</updated>
        <summary type="html"><![CDATA[<p>CloudFlare有免费的SSL证书，如果仅仅是在CloudFlare后台中开启它的话，并不能做到全站加密，只能开启Flexible模式，而不是Full模式。</p>
]]></summary>
        <content type="html"><![CDATA[<p>CloudFlare有免费的SSL证书，如果仅仅是在CloudFlare后台中开启它的话，并不能做到全站加密，只能开启Flexible模式，而不是Full模式。</p>
<!-- more -->
<p>进入CloudFlare后台-&gt;SSL/TLS，可以看到第一项就是免费提供的SSL。这里有4种模式可选：Off（关闭SSL）、Flexible（视情况而定）、Full（全部加密，需要在服务器上部署证书，但CloudFlare不会检查证书的有效性）、Full(Strict)（严格模式，也就是全部加密，而且CloudFlare会检查服务器上的证书是否有效）。<br>
<img src="https://picture.totoro.site/images/2019/10/26/ssl.png" alt="ssl.png"></p>
<p>在这里，我们的目标是开启Full模式，实现方式是：首先自签一个泛域名的证书，然后在Nginx中设置通过HTTPS访问网站，最后到CloudFlare中设置一下SSL模式。</p>
<p>当然，如果你是个强迫症患者，非要开启Full(Strict)模式，也是可以的，但服务器上就不能部署自签名的证书了，而需要一个有效机构颁发的证书，例如letsencrypt的证书。然而缺点显而易见：需要定期续期。使用自签名证书就不存在这个问题了，你想签多长时间的有效期就可以签多长时间，更换服务器时，也仅需要把证书文件拷到新服务器上。</p>
<h3 id="准备工作"><strong>准备工作</strong></h3>
<p>第一步，当然是确保你的DNS是CloudFlare的！</p>
<p>第二步，安装签发证书工具：OpenSSL</p>
<p>dpkg系：</p>
<pre><code class="language-shell">apt-get install openssl
</code></pre>
<p>rhel系：</p>
<pre><code class="language-shell">yum install openssl
</code></pre>
<h3 id="签发证书"><strong>签发证书</strong></h3>
<p>首先建立一个制作、存放证书的目录：</p>
<pre><code class="language-shell">mkdir certificate
</code></pre>
<p>进入该目录，然后签发一个根域名的CA证书，第一步创建一个私钥ca.key：</p>
<pre><code class="language-shell">openssl genrsa -des3 -out ca.key 2048
</code></pre>
<p>第二步，生成CA根证书（公钥）：</p>
<pre><code class="language-shell">openssl req -new -x509 -days 7305 -key ca.key -out ca.crt
</code></pre>
<p>命令中，-days后面的7305是指证书的有效期，以天为单位，这里设置成了20年，手动滑稽。<br>
执行命令后会让你填一堆地区、组织什么的东西，随便填就好，但注意期间会让你填写common name，也就是域名，这里填入的是你的根域名，例如eaimty.com。最后，你就得到了一个根域的CA证书。</p>
<p>之后生成一个给泛域名用的私钥：</p>
<pre><code class="language-shell">openssl genrsa -des3 -out yourdomain.com.pem 1024
</code></pre>
<p>解密私钥：</p>
<pre><code class="language-shell">openssl rsa -in yourdomain.com.pem -out yourdomain.com.key
</code></pre>
<p>生成签名请求：</p>
<pre><code class="language-shell">openssl req -new -key yourdomain.com.pem -out yourdomain.com.csr
</code></pre>
<p>这一步中common name要填入泛域名，如*.eaimty.com，这样生成的证书可以供所有子域使用。</p>
<p>下一步还不能直接执行签名，否则会报错，要先修改一下openssl的配置文件：</p>
<pre><code class="language-shell">vi /etc/pki/tls/openssl.cnf
</code></pre>
<p>找到其中的dir = ，把值改成./ca。</p>
<p>然后在你签发证书的工作目录中：</p>
<pre><code class="language-shell">mkdir -p ca/newcerts

touch ca/index.txt

touch ca/serial

echo &quot;01&quot; &gt; ca/serial
</code></pre>
<p>这样就可以正常执行签名了：</p>
<pre><code class="language-shell">openssl ca -policy policy_anything -days 7305 -cert ca.crt -keyfile ca.key -in yourdomain.com.csr -out yourdomain.com.crt
</code></pre>
<p>这一步中的参数和上一步中的意义相同。<br>
最后你会得到一个yourdomain.com.crt文件，把ca.crt中的内容粘贴到yourdomain.com.crt的最后，证书就签发完成了。</p>
<p>准备好yourdomain.com.crt（网站证书）和yourdomain.com.key（网站私钥），开始配置Nginx！</p>
<h3 id="配置nginx"><strong>配置Nginx</strong></h3>
<p>这一步很简单，找到你的网站（所签发泛域名的所有子域名都可以用）的Nginx配置文件（通常是/etc/nginx/conf.d/下的XXX.conf），<br>
修改server{}段listen 443 ssl;，添加ssl_certificate /path/to/yourdomain.com.crt;和ssl_certificate_key /path/to/yourdomain.com.key;两行。</p>
<p>测试Nginx的配置文件是否有错：</p>
<pre><code class="language-shell">nginx -t
</code></pre>
<p>注意看是否报错。<br>
重启Nginx：</p>
<p>systemd发行版：# systemctl restart nginx<br>
init.d发行版：# service nginx restart</p>
<p>如果不确定是哪种发行版的话两个命令都试一试。</p>
<h3 id="设置cloudflare"><strong>设置CloudFlare</strong></h3>
<p>进入CloudFlare管理界面，将Crypto-&gt;SSL改为“Full”。</p>
<p>现在通过浏览器进入https://你的网站/，你就会发现小绿锁出现了！就说明我们成功了！</p>
<p>最后设置一下http自动跳转至https，全站SSL就实现了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux各发行版安装docker教程]]></title>
        <id>https://skytotwo.github.io//post/linux-docker-setup</id>
        <link href="https://skytotwo.github.io//post/linux-docker-setup">
        </link>
        <updated>2019-09-02T01:35:46.000Z</updated>
        <summary type="html"><![CDATA[<p>docker是当下十分流行的容器，因为其部署简单而使用广泛，不同的linux发行版安装docker的步骤操作是不一样的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>docker是当下十分流行的容器，因为其部署简单而使用广泛，不同的linux发行版安装docker的步骤操作是不一样的。</p>
<!-- more -->
<h3 id="centos"><strong>Centos</strong></h3>
<p>1.先移除旧版本docker文件</p>
<pre><code class="language-shell">yum remove docker  
                  docker-client 
                  docker-client-latest 
                  docker-common 
                  docker-latest 
                  docker-latest-logrotate 
                  docker-logrotate 
                  docker-engine
</code></pre>
<p>2.安装必要依赖</p>
<pre><code class="language-shell">yum install -y yum-utils 
  device-mapper-persistent-data 
  lvm2
</code></pre>
<p>3.设置docker稳定版文件</p>
<pre><code class="language-shell">yum-config-manager 
    --add-repo 
    https://download.docker.com/linux/centos/docker-ce.repo
</code></pre>
<p>4.安装docker社区版</p>
<pre><code class="language-shell">yum install docker-ce docker-ce-cli containerd.io
</code></pre>
<p>5.启动docker</p>
<pre><code class="language-shell">systemctl start docker
</code></pre>
<p>6.测试</p>
<pre><code class="language-shell">docker run hello-world
</code></pre>
<h3 id="debian"><strong>Debian</strong></h3>
<p>1.先移除旧版本docker文件</p>
<pre><code class="language-shell">apt-get remove docker docker-engine docker.io containerd runc
</code></pre>
<p>2.更新文件</p>
<pre><code class="language-shell">apt-get update
</code></pre>
<p>3.安装必要依赖</p>
<pre><code class="language-shell">apt-get install 
    apt-transport-https 
    ca-certificates 
    curl 
    gnupg2 
    software-properties-common
</code></pre>
<p>4.设置docker稳定版文件</p>
<pre><code class="language-shell">add-apt-repository 
   &quot;deb [arch=amd64] https://download.docker.com/linux/debian 
   $(lsb_release -cs) 
   stable&quot;
</code></pre>
<p>5.安装docker社区版</p>
<pre><code class="language-shell">apt-get install docker-ce docker-ce-cli containerd.io
</code></pre>
<p>6.测试</p>
<pre><code class="language-shell">docker run hello-world
</code></pre>
<h3 id="ubantu"><strong>Ubantu</strong></h3>
<p>1.先移除旧版本docker文件</p>
<pre><code class="language-shell">apt-get remove docker docker-engine docker.io containerd runc
</code></pre>
<p>2.更新文件</p>
<pre><code class="language-shell">apt-get update
</code></pre>
<p>3.安装必要依赖</p>
<pre><code class="language-shell">apt-get install 
    apt-transport-https 
    ca-certificates 
    curl 
    gnupg-agent 
    software-properties-common
</code></pre>
<p>4.设置docker稳定版文件</p>
<pre><code class="language-shell">add-apt-repository 
   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu 
   $(lsb_release -cs) 
   stable&quot;
</code></pre>
<p>5.安装docker社区版</p>
<pre><code class="language-shell">apt-get install docker-ce docker-ce-cli containerd.io
</code></pre>
<p>6.测试</p>
<pre><code class="language-shell">docker run hello-world
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信支付统一下单失败，返回金额invalid total_fee]]></title>
        <id>https://skytotwo.github.io//post/wechat-invalid-total_fee</id>
        <link href="https://skytotwo.github.io//post/wechat-invalid-total_fee">
        </link>
        <updated>2019-09-01T08:41:55.000Z</updated>
        <summary type="html"><![CDATA[<p>这里是因为微信支付金额是以分为单位的，而支付宝是以元为单位的，这是两者的区别。在下单部分，需要将金额做一下处理，将元转化成分，下面是python的实现：</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里是因为微信支付金额是以分为单位的，而支付宝是以元为单位的，这是两者的区别。在下单部分，需要将金额做一下处理，将元转化成分，下面是python的实现：</p>
<!-- more -->
<pre><code class="language-python">def trans_yuan_to_cent(total_fee):
    &quot;&quot;&quot;微信支付时，需要将元转为分&quot;&quot;&quot;
    total_fee = str(total_fee)
    index = total_fee.find('.')
    length = len(total_fee)

    if index == -1:  # 当不存在小数点时候，也就是分，直接乘以100，这里是加两个0
        fee = int(total_fee + '00')
    elif length - index &gt;= 3:  # 当传入金额待两位小数以上的时候
        fee = int(total_fee[0:index+3].replace('.', ''))
    elif length - index == 2:  # 当传入金额待一位小数时候
        fee = int(total_fee[0:index+2].replace('.', '')+'0')
    else:  # 当传入金额带一个小数点时候
        fee = int(total_fee[0:index+1].replace('.', '')+'00')

    return fee
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于服务器端口转发的两种常见方法]]></title>
        <id>https://skytotwo.github.io//post/linux-resend</id>
        <link href="https://skytotwo.github.io//post/linux-resend">
        </link>
        <updated>2019-09-01T08:36:13.000Z</updated>
        <summary type="html"><![CDATA[<p>很多时候，访问国外服务器时，网络质量是很影响体验的，当我们有一台普通线路的国外服务器，日常使用没有太大要求其实也能满足自身需要，但是如果想要让体验更佳，那就可以尝试使用服务器端口转发。</p>
]]></summary>
        <content type="html"><![CDATA[<p>很多时候，访问国外服务器时，网络质量是很影响体验的，当我们有一台普通线路的国外服务器，日常使用没有太大要求其实也能满足自身需要，但是如果想要让体验更佳，那就可以尝试使用服务器端口转发。</p>
 <!-- more -->
<p>端口转发的原理是用一台国内的服务器来做跳转，利用国内服务器优质的线路，使得访问国外服务器速度更快更稳定。常见的转发有rinetd、Haproxy、iptables、socat，前面2种只能转发TCP，后面TCP/UDP都可以转发，这里介绍iptables、socat，下面来看看两种转发方式。</p>
<h3 id="一-socat转发"><strong>一、socat转发</strong></h3>
<p>一键脚本<br>
脚本说明：脚本默认开启UDP、TCP转发，带开机自启功能，且一次只能转发单个端口，如果想转发多个端口请重复运行本脚本</p>
<p>使用root运行以下命令：</p>
<pre><code class="language-shell">wget https://www.moerats.com/usr/shell/socat.sh &amp;&amp; bash socat.sh
</code></pre>
<p>按要求输入以下信息：</p>
<p>如果你要用本地服务器的3333端口转发IP为1.1.1.1服务器的6666端口，那就依次填入指定参数。<br>
请输入本地端口:3333<br>
请输入远程端口:6666<br>
请输入远程IP:1.1.1.1<br>
输入后直到配置完成</p>
<h3 id="二-iptables转发"><strong>二、iptables转发</strong></h3>
<h4 id="21一键脚本"><strong>2.1一键脚本</strong></h4>
<pre><code class="language-shell">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/skytotwo/master/iptables-pf.sh &amp;&amp; chmod +x iptables-pf.sh &amp;&amp; bash iptables-pf.sh
</code></pre>
<p>下载并运行脚本后，先选择 1. 安装 iptables ，会检测是否安装 iptables 同时也会进行 iptables 防火墙开机启动加载等配置。</p>
<p>使用方法</p>
<pre><code class="language-shell">./iptables-pf.sh
</code></pre>
<p>运行脚本后，会显示菜单：</p>
<pre><code class="language-shell"> iptables 端口转发一键管理脚本 [vx.x.x]
 -- Toyo | doub.io/wlzy-20 --
 
 0. 升级脚本
————————————
 1. 安装 iptables
 2. 清空 iptables 端口转发
————————————
 3. 查看 iptables 端口转发
 4. 添加 iptables 端口转发
 5. 删除 iptables 端口转发
————————————
注意：初次使用前请请务必执行 1. 安装 iptables(不仅仅是安装)
 
 请输入数字 [0-5]:
</code></pre>
<p>选择 4. 添加 iptables 端口转发 后，会提示你依次输入 欲转发IP、欲转发端口、本地监听端口、本地IP、转发类型：</p>
<pre><code class="language-shell">请输入 iptables 欲转发至的 远程端口 [1-65535] (支持端口段 如 2333-6666, 被转发服务器):10000-11000
 
 欲转发端口 : 10000-11000
 
请输入 iptables 欲转发至的 远程IP(被转发服务器):2.2.2.2
 
 欲转发服务器IP : 2.2.2.2
 
请输入 iptables 本地监听端口 [1-65535] (支持端口段 如 2333-6666)
(默认端口: 10000-11000):
 
 本地监听端口 : 10000-11000
 
请输入 本服务器的 公网IP网卡IP(注意是网卡绑定的IP，而不仅仅是公网IP，回车自动检测):
 
 本服务器IP : 1.1.1.1
 
请输入数字 来选择 iptables 转发类型:
 1. TCP
 2. UDP
 3. TCP+UDP
 
(默认: TCP+UDP):
 
——————————————————————————————
 请检查 iptables 端口转发规则配置是否有误 !
 
 本地监听端口 : 10000-11000
 服务器 IP : 2.2.2.2
 
 欲转发的端口 : 10000-11000
 欲转发 IP : 1.1.1.1
 转发类型 : TCP+UDP
——————————————————————————————
</code></pre>
<p>最后会提示你确认配置是否有误，如果没有问题就按任意键继续，启动成功后就会提示：</p>
<pre><code class="language-shell">——————————————————————————————
 iptables 端口转发规则配置完成 !
 
 本地监听端口 : 10000:11000
 服务器 IP : 1.1.1.1
 
 欲转发的端口 : 10000:11000
 欲转发 IP : 2.2.2.2
 转发类型 : TCP+UDP
——————————————————————————————
</code></pre>
<p>选择 3. 查看 iptables 端口转发 后，会显示如下：</p>
<pre><code class="language-shell">当前有 2 个 iptables 端口转发规则。
1. 类型: tcp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000
2. 类型: udp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000
</code></pre>
<p>选择 5. 删除 iptables 端口转发 后，也会显示列表，然后让你选择 要删除的端口转发规则序号。</p>
<p><strong>Shadowsocks客户端说明</strong><br>
假设你的海外服务器(被中转)中搭建的Shadowsocks服务端的IP是 2.2.2.2  ，SS端口是 10000 。</p>
<p>假设中转服务器的IP是 1.1.1.1 ，本地监听端口和SS端口不一致，本地监听端口是 20000 。</p>
<p>那么，你的Shadowsocks客户端，添加Shadowsocks服务器，IP填写 1.1.1.1 ，端口填写 20000 ，其他的 密码/加密方式/协议/混淆等等 全部和原Shadowsocks账号一样！</p>
<p><strong>其他说明</strong><br>
CentOS 7 默认的防火墙是 firewall，要使用本脚本，请先卸载或关闭 firewall 服务器，并安装 iptables 全套软件。</p>
<p>关于国内腾讯云等服务器转发失败解释<br>
国内的很多服务器，例如腾讯云，在VPS网卡上面绑定的都是内网IP，这样的话，如果你用脚本自动检测外网IP，会转发失败，需要在添加转发规则的时候，本服务器IP手动写你的服务器 网卡上面绑定的IP。</p>
<h4 id="22手动添加"><strong>2.2手动添加</strong></h4>
<p>在使用iptables转发流量之前请执行如下命令：</p>
<pre><code class="language-shell">sed -i 's/net.ipv4.ip_forward = 0/net.ipv4.ip_forward = 1/g' /etc/sysctl.conf
sysctl -p
</code></pre>
<p>然后我们清除下所有默认的iptables表：</p>
<pre><code class="language-shell">iptables -F
iptables -t nat -F
service iptables save
</code></pre>
<p>iptables相同端口转发命令：</p>
<pre><code class="language-shell">iptables -t nat -A PREROUTING -p tcp --dport [端口号] -j DNAT --to-destination [目标IP]
iptables -t nat -A PREROUTING -p udp --dport [端口号] -j DNAT --to-destination [目标IP]
iptables -t nat -A POSTROUTING -p tcp -d [目标IP] --dport [端口号] -j SNAT --to-source [中转服务器IP]
iptables -t nat -A POSTROUTING -p udp -d [目标IP] --dport [端口号] -j SNAT --to-source [中转服务器IP]
</code></pre>
<p>不同端口：</p>
<pre><code class="language-shell">iptables -t nat -A PREROUTING -p tcp --dport [源端口号] -j DNAT --to-destination [目标IP:目标端口号]
iptables -t nat -A PREROUTING -p udp --dport [源端口号] -j DNAT --to-destination [目标IP:目标端口号]
iptables -t nat -A POSTROUTING -p tcp -d [目标IP] --dport [目标端口号] -j SNAT --to-source [中转服务器IP]
iptables -t nat -A POSTROUTING -p udp -d [目标IP] --dport [目标端口号] -j SNAT --to-source [中转服务器IP]
</code></pre>
<p><strong>注意：执行完毕后，必须进行保存 请使用 service iptables save 进行保存。</strong></p>
<p>以下是一个实例（这里我们的应用端口为50020~50029，我们使用520022测试转发另外一个IP的6053端口，我们的主IP为：192.168.5.2，转发服务器IP为：1.1.1.1）：</p>
<pre><code class="language-shell">iptables -t nat -A PREROUTING -p tcp --dport 50022 -j DNAT --to-destination 1.1.1.1:6053
iptables -t nat -A PREROUTING -p udp --dport 50022 -j DNAT --to-destination 1.1.1.1:6053
iptables -t nat -A POSTROUTING -p tcp -d 1.1.1.1 --dport 6053 -j SNAT --to-source 192.168.5.2
iptables -t nat -A POSTROUTING -p udp -d 1.1.1.1 --dport 6053 -j SNAT --to-source 192.168.5.2
service iptables save
</code></pre>
<h3 id="三-iptables和socat的优劣"><strong>三、iptables和socat的优劣</strong></h3>
<p>实际体验中iptables会好一点，socat当转发数多了就会炸，推荐使用iptables转发。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一款强大好用的个人图床：chevereto安装教程]]></title>
        <id>https://skytotwo.github.io//post/chevereto-setup</id>
        <link href="https://skytotwo.github.io//post/chevereto-setup">
        </link>
        <updated>2019-09-01T08:27:49.000Z</updated>
        <summary type="html"><![CDATA[<p>说明：chevereto是目前最好的图床之一了。功能也非常强大。其免费版和收费版的区别，在于收费版多了硬盘扩展，社交分享功能和技术支持。硬盘扩展指的是你可以通过sftp等方式把上传的文件储存在其他服务器上。所以个人觉得，这个免费版已经足够使用了。而且chevereto的安装也非常简单，并且支持中文。网上很多教程都写得不是很清楚，这里就发个详细安装教程吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>说明：chevereto是目前最好的图床之一了。功能也非常强大。其免费版和收费版的区别，在于收费版多了硬盘扩展，社交分享功能和技术支持。硬盘扩展指的是你可以通过sftp等方式把上传的文件储存在其他服务器上。所以个人觉得，这个免费版已经足够使用了。而且chevereto的安装也非常简单，并且支持中文。网上很多教程都写得不是很清楚，这里就发个详细安装教程吧。</p>
 <!-- more --> 
<p>官网：https://chevereto.com/<br>
DEMO：https://demo.chevereto.com/</p>
<p>如下：<br>
<a href="http://picture.totoro.site/image/VWCR"><img src="http://picture.totoro.site/images/2019/04/18/WX20190418-1642542x.png" alt="WX20190418-1642542x.png"></a></p>
<h4 id="安装"><strong>安装</strong></h4>
<p><strong>环境要求：Apache/Nginx、PHP 5.5+、MySQL 5.0+</strong></p>
<h4 id="1-搭建web环境"><strong>1、搭建web环境</strong></h4>
<p>我们可以用lnmp、lamp一键包或者宝塔之类的面板来搭建web环境。<br>
lnmp安装方法可参考：</p>
<pre><code class="language-shell">wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp
</code></pre>
<h3 id="2-上传chevereto程序"><strong>2、上传chevereto程序</strong></h3>
<p>搭建好web环境后，添加网站并解析，再上传chevereto程序到网站目录，chevereto下载地址：https://github.com/Chevereto/Chevereto-Free。<br>
这里以lnmp为例，执行命令：</p>
<pre><code class="language-shell">cd /home/wwwroot/
mkdir chevereto
cd chevereto
wget https://github.com/Chevereto/Chevereto-Free/archive/1.0.9.tar.gz
tar zvxf 1.0.9.tar.gz
</code></pre>
<p>赋权限</p>
<p>再执行非常重要的一步：</p>
<pre><code class="language-shell">chown www:www -R /home/wwwroot/chevereto
</code></pre>
<p><strong>创建settings.php文件</strong></p>
<p>在app目录新建settings.php文件并给予可写入权限:</p>
<pre><code class="language-shell">cd /home/wwwroot/chevereto/app
touch settings.php
chmod -R 777 settings.php
</code></pre>
<p><strong>修改nginx配置文件</strong></p>
<p>修改网站配置文件/usr/local/nginx/conf/nginx.conf,在server中添加以下代码:</p>
<pre><code class="language-shell">location / {
try_files $uri $uri/ /index.php?$query_string;
}
</code></pre>
<p>再将程序根路径指向chevereto文件夹：</p>
<pre><code class="language-shell">root /home/wwwroot/chevereto;
</code></pre>
<p>然后重启Nginx，使用命令:</p>
<pre><code class="language-shell">/etc/init.d/nginx restart
#或
lnmp restart
#或
lnmp nginx restart
</code></pre>
<h3 id="3-生成chevereto图床所需的数据库"><strong>3、生成chevereto图床所需的数据库</strong></h3>
<p>将安装lnmp自动生成的default文件夹中phpmyadmin拷贝到chevereto文件夹里</p>
<pre><code class="language-shell">cp -R /home/wwwroot/default/phpmyadmin /home/wwwroot/chevereto
</code></pre>
<p>浏览器访问http://IP/phpmyadmin, 登录。<br>
新增chevereto数据库<br>
新增chevereto用户，并且赋权限</p>
<h3 id="4-开始安装chevereto"><strong>4、开始安装chevereto</strong></h3>
<p>浏览器访问http://IP/<br>
然后开始填写数据库信息：<br>
<img src="http://picture.totoro.site/images/2019/04/18/chevereto03.png" alt="chevereto03.png"></p>
<p>随后安装成功！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS重启后resolv.conf被重置的解决方案]]></title>
        <id>https://skytotwo.github.io//post/centos-resolvconf-dns</id>
        <link href="https://skytotwo.github.io//post/centos-resolvconf-dns">
        </link>
        <updated>2019-09-01T08:21:20.000Z</updated>
        <summary type="html"><![CDATA[<p>近期在修改一台CentOS服务器的dns时发现只要重启服务器DNS就会被强制还原，解决方案如下：</p>
]]></summary>
        <content type="html"><![CDATA[<p>近期在修改一台CentOS服务器的dns时发现只要重启服务器DNS就会被强制还原，解决方案如下：</p>
 <!-- more -->
<p><strong>1、首先在网卡设置中修改NM_CONTROLLED的值：</strong><br>
修改文件/etc/sysconfig/network-scripts/ifcfg-eth0的内容：</p>
<pre><code class="language-shell">NM_CONTROLLED=&quot;no&quot;  //是否允许Network Manager管理，设置为no
</code></pre>
<p>默认允许Network Manager管理DNS，所以首先设置为no，然后操作DNS设置</p>
<p><strong>2、设置DNS内容：</strong><br>
修改DNS可以有如下两种方案：</p>
<p>①、修改网卡设置：<br>
在/etc/sysconfig/network-scripts/ifcfg-eth0中修改内容：</p>
<pre><code class="language-shell">PEERDNS=&quot;yes&quot;
DNS1=&quot;xxx.xxx.xxx.xxx&quot;
DNS2=&quot;xxx.xxx.xxx.xxx&quot;
</code></pre>
<p>这种设置方案是以网卡中设置的DNS为主，resolv.conf中按照网卡设置的DNS内容自动生成，以后想修改DNS，必须修改网卡中的设置才不会在服务器重启之后出现DNS设置失效的问题。</p>
<p>②、直接修改/etc/resolv.conf的值：<br>
PS.需要注意的是，若要使直接修改的DNS内容不会在服务器重启之后丢失，需要设置网卡中PEERDNS的值为no：</p>
<pre><code class="language-shell">nameserver xxx.xxx.xxx.xxx
nameserver xxx.xxx.xxx.xxx
</code></pre>
<p><strong>3、修改完毕之后重启网卡：</strong></p>
<pre><code class="language-shell">service network restart
</code></pre>
<p>按照上面任意一种方案修改DNS设置之后都不会出现重启服务器DNS设置复原的情况，适用于dhcp启动的机器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python中的单例模式]]></title>
        <id>https://skytotwo.github.io//post/python-singelton</id>
        <link href="https://skytotwo.github.io//post/python-singelton">
        </link>
        <updated>2019-09-01T07:50:50.000Z</updated>
        <summary type="html"><![CDATA[<p>单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p>
]]></summary>
        <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p>
<!-- more -->
<h3 id="单例模式">单例模式</h3>
<p>比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。</p>
<p>在 Python 中，我们可以用多种方法来实现单例模式：</p>
<ul>
<li>使用模块</li>
<li>使用 <strong>new</strong></li>
<li>使用装饰器（decorator）</li>
<li>使用元类（metaclass）</li>
</ul>
<h4 id="使用模块"><strong>使用模块</strong></h4>
<p>其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：</p>
<pre><code class="language-python"># mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass

my_singleton = My_Singleton()
</code></pre>
<p>将上面的代码保存在文件 mysingleton.py 中，然后这样使用：</p>
<pre><code class="language-python">from mysingleton import my_singleton

my_singleton.foo()
</code></pre>
<h4 id="使用-new"><strong>使用 <strong>new</strong></strong></h4>
<p>为了使类只能出现一个实例，我们可以使用 <strong>new</strong> 来控制实例的创建过程，代码如下：</p>
<pre><code class="language-python">class Singleton(object):
    _instance = None
    def __new__(cls, *args, **kw):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kw)  
        return cls._instance  

class MyClass(Singleton):  
    a = 1
</code></pre>
<p>在上面的代码中，我们将类的实例和一个类变量 _instance 关联起来，如果 cls._instance 为 None 则创建实例，否则直接返回 cls._instance。</p>
<p>执行情况如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; one = MyClass()
&gt;&gt;&gt; two = MyClass()
&gt;&gt;&gt; one == two
True
&gt;&gt;&gt; one is two
True
&gt;&gt;&gt; id(one), id(two)
(4303862608, 4303862608)
</code></pre>
<h4 id="使用装饰器"><strong>使用装饰器</strong></h4>
<p>我们知道，装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：</p>
<pre><code class="language-python">from functools import wraps

def singleton(cls):
    instances = {}
    @wraps(cls)
    def getinstance(*args, **kw):
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance

@singleton
class MyClass(object):
    a = 1
</code></pre>
<p>在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 getinstance，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，cls(*args, **kw) 作为 value 存到 instances 中，否则，直接返回 instances[cls]。</p>
<h4 id="使用-metaclass"><strong>使用 metaclass</strong></h4>
<p>元类（metaclass）可以控制类的创建过程，它主要做三件事：</p>
<ol>
<li>拦截类的创建</li>
<li>修改类的定义</li>
<li>返回修改后的类<br>
使用元类实现单例模式的代码如下：</li>
</ol>
<pre><code class="language-python">class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

# Python2
class MyClass(object):
    __metaclass__ = Singleton

# Python3
# class MyClass(metaclass=Singleton):
#    pass
</code></pre>
<h4 id="小结"><strong>小结</strong></h4>
<p><strong>Python 的模块是天然的单例模式，这在大部分情况下应该是够用的，当然，我们也可以使用装饰器、元类等方法</strong></p>
<p>转载至：http://python.jobbole.com/87294/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用openOffice实现word、excel等转pdf功能]]></title>
        <id>https://skytotwo.github.io//post/openoffice</id>
        <link href="https://skytotwo.github.io//post/openoffice">
        </link>
        <updated>2019-08-26T14:31:25.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在公司项目中需要实现Excel转pdf的功能，一开始我自己写了工具类来实现转换，实现方式是将目标文件读流，再读出每个sheet，再将sheet数组一个个遍历取当页的数据，读数据的时候又需要每行每行的遍历，再将每个sheet拼接起来成为一个pdf。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在公司项目中需要实现Excel转pdf的功能，一开始我自己写了工具类来实现转换，实现方式是将目标文件读流，再读出每个sheet，再将sheet数组一个个遍历取当页的数据，读数据的时候又需要每行每行的遍历，再将每个sheet拼接起来成为一个pdf。</p>
<!-- more -->
<p>本来自己想着简单，确实也实现了功能，但是还是存在很多小问题自己无法控制，比如说对excel的页面布局格式之类的需要严格控制调整，这样弄得很烦，所以想着另找出路。这时候想到了Appache的openOffice。<br>
openOffice其实是一个服务，可以安装在windows、mac和linux下，用命令启动后，程序调用该端口，就能调用本机安装的office软件或者wps软件进行转格式，原理就是这样的。<br>
接下来我们来看下怎么使用。</p>
<hr>
<h4 id="一下载安装"><strong>一.下载安装</strong></h4>
<p>这是一个开源程序，下载地址是：<br>
<a href="https://www.openoffice.org/download/" title="https://www.openoffice.org/download/">https://www.openoffice.org/download/</a><br>
进入下载页面，多个系统程序包可以选择，如图下：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180916103231_367.png" alt="20180916103231_367.png"><br>
这里介绍windows系统和linux系统的安装，因为开发环境西药先测试，然后是要部署至生产环境的，因为公司生产环境用的是redhat红帽系统，所以会针对性的介绍下。</p>
<p><strong>windows</strong><br>
windows安装其实很简单，就是一步步点下一步就好了，安装完成后，我们需要记住相应的启动命令来启动程序。如下图：<br>
打开cmd进入openoffice安装目录：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180916103716_95.png" alt="20180916103716_95.png"><br>
在program文件夹下输入启动命令，soffice.exe -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;,然后回车就启动了<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180916103856_647.png" alt="20180916103856_647.png"></p>
<p><strong>linux</strong><br>
linux下安装会复杂一点，这里以redhat为例，我们先下载对应的安装包，红帽系统需要选择rpm格式的，我们下载64位的，如下图：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180916104119_512.png" alt="20180916104119_512.png"><br>
然后安装过程如下：</p>
<pre><code class="language-shell">一、安装openOffice
1.使用tar -xzvf xxxx.tar.gz解压缩后，会得到对应的解压文件 /zh-CN

目录。
2.进入/zh-CN//RPMS/目录
3.执行　rpm –ivh *rpm（安装所有rpm文件）
4.进入到desktop-integration目录　cd desktop-integration
5.执行　rpm -ivh openoffice.org3.2-redhat-menus-3.2-9472.noarch.rpm

这时openOffice己经安装完成，默认会安装在/opt下

二、启动openOffice服务　
1.进入opt目录：cd /opt
2.进入openoffice.org3目录：　cd openoffice.org3
3.进入cd program目录
4.执行　soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot; -nofirststartwizard &amp; 

三、停止openOffice服务

ps -aux | grep oppenoffice 查看是否openoffice服务是否已启动；
</code></pre>
<p>至此，openOffice的安装我们已经搞定了，接下来就是程序的编写了</p>
<h4 id="二转换程序编写"><strong>二.转换程序编写</strong></h4>
<p>首先我们需要在项目里导入相应的jar包，所需jar包如下：</p>
<pre><code class="language-java">jodconverter-2.2.2.jar
ridl-3.2.1.jar
org.apache.commons.io.jar
juh.jar
jurt.jar
unoil.jar
slf4j-api-1.7.13.jar
slf4j-jdk14-1.7.13.jar
xstream-1.4.1.jar

</code></pre>
<p>转换的java方法我这边直接拿项目里用到的方法来讲，其实也很简单</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.ConnectException;

import com.artofsolving.jodconverter.DocumentConverter;
import com.artofsolving.jodconverter.openoffice.connection.OpenOfficeConnection;
import com.artofsolving.jodconverter.openoffice.connection.SocketOpenOfficeConnection;
import com.artofsolving.jodconverter.openoffice.converter.OpenOfficeDocumentConverter;

public class Converter {
	 /** 
     * 将Office文档转换为PDF. 运行该函数需要用到OpenOffice, OpenOffice下载地址为 
     * http://www.openoffice.org/ 
     *  
     * &lt;pre&gt; 
     * 方法示例: 
     * String sourcePath = &quot;F:\\office\\source.doc&quot;; 
     * String destFile = &quot;F:\\pdf\\dest.pdf&quot;; 
     * Converter.office2PDF(sourcePath, destFile); 
     * &lt;/pre&gt; 
     *  
     * @param sourceFile 
     *            源文件, 绝对路径. 可以是Office2003-2007全部格式的文档, Office2010的没测试. 包括.doc, 
     *            .docx, .xls, .xlsx, .ppt, .pptx等. 示例: F:\\office\\source.doc 
     * @param destFile 
     *            目标文件. 绝对路径. 示例: F:\\pdf\\dest.pdf 
     * @return 操作成功与否的提示信息. 如果返回 -1, 表示找不到源文件, 或url.properties配置错误; 如果返回 0, 
     *         则表示操作成功; 返回1, 则表示转换失败 
     */  
    public static int office2PDF(String sourceFile, String destFile) {  
        try {  
            File inputFile = new File(sourceFile);  
            if (!inputFile.exists()) {  
                return -1;// 找不到源文件, 则返回-1  
            }  
  
            // 如果目标路径不存在, 则新建该路径  
            File outputFile = new File(destFile);  
         
            //String OpenOffice_HOME = &quot;D:\\Program Files\\OpenOffice.org 4&quot;;//这里是OpenOffice的安装目录, 在我的项目中,为了便于拓展接口,没有直接写成这个样子,但是这样是绝对没问题的  
            String OpenOffice_HOME = &quot;C:\\Program Files (x86)\\OpenOffice 4&quot;;
            // 如果从文件中读取的URL地址最后一个字符不是 '\'，则添加'\'  
            if (OpenOffice_HOME.charAt(OpenOffice_HOME.length() - 1) != '\\') {  
                OpenOffice_HOME += &quot;\\&quot;;  
            }  
            // 启动OpenOffice的服务  
            String command = OpenOffice_HOME  
                    + &quot;program\\soffice.exe -headless -accept=\&quot;socket,host=127.0.0.1,port=8100;urp;\&quot;&quot;;
            //注意：linux系统的服务是已经启动好的，不需要另启动服务，下面这句本地需要，服务器不需要
            Process pro = Runtime.getRuntime().exec(command);  
            // connect to an OpenOffice.org instance running on port 8100  
            OpenOfficeConnection connection = new SocketOpenOfficeConnection(  
                    &quot;127.0.0.1&quot;, 8100);  
            connection.connect();  
  
            // convert  
            DocumentConverter converter = new OpenOfficeDocumentConverter(  
                    connection);  
            converter.convert(inputFile, outputFile);  
  
            // close the connection  
            connection.disconnect();  
            //注意：关闭OpenOffice服务的进程 ，下面这句本地需要，服务器不需要
            pro.destroy();  
  
            return 0;  
        } catch (ConnectException e) {  
            e.printStackTrace();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
  
        return 1;  
    }
}
</code></pre>
<p>这里很好理解，就是拿到文件，连接openOffice服务，调用转换方法。</p>
<p>其实开发和部署还是很顺利的，需要注意的是jar包不能少，不然会报错在服务器上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django自定义xadmin插件之导入excel]]></title>
        <id>https://skytotwo.github.io//post/django-xadmin-excel</id>
        <link href="https://skytotwo.github.io//post/django-xadmin-excel">
        </link>
        <updated>2019-08-26T14:17:13.000Z</updated>
        <summary type="html"><![CDATA[<p>xadmin的厉害之处在于它允许使用者自定义插件，使用者编写自己需要的插件并注册到xadmin中，以便xadmin实现自己所需要的功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>xadmin的厉害之处在于它允许使用者自定义插件，使用者编写自己需要的插件并注册到xadmin中，以便xadmin实现自己所需要的功能。</p>
<!-- more -->
<p>xadmin是如何能够实现插件的自定义呢？其实在xadmin使用文档上可以找到答案，如下所示：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902134855_643.png" alt="20180902134855_643.png"></p>
<hr>
<p>这里拿制作excel导入插件为例。最终实现的效果是在xadmin中某类别下能够出现导入excel按钮，并且能够实现excel的导入，如下图所示：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902135157_751.png" alt="20180902135157_751.png"><br>
点击导入excel选项：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902135226_545.png" alt="20180902135226_545.png"></p>
<p>并且最终实现悬着好excel文件后，点击确认，能够将导入逻辑相应到后台进行处理。</p>
<h4 id="一编写excel插件"><strong>一.编写excel插件</strong></h4>
<p>要编写excel插件，首先需要认识xadmin的目录结构，这里建议将xadmin下载至本地并放置在项目中，这样才能编写插件代码，下载地址是：<br>
<a href="https://github.com/sshwsfc/xadmin" title="点我下载">点我下载</a><br>
下载后得到的xadmin文件结构如下：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902135714_712.png" alt="20180902135714_712.png"><br>
我们需要做的是在plugins模块中编写插件，plugins模块中已经有很多的插件了，如下：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902135841_910.png" alt="20180902135841_910.png"><br>
这里已经有许多可以直接用的插件。<br>
直接在里面新建文件，命名为excel.py代码如下：</p>
<pre><code class="language-python"># coding:utf-8

import xadmin
from xadmin.views import BaseAdminPlugin, ListAdminView
from django.template import loader


#excel 导入
class ListImportExcelPlugin(BaseAdminPlugin):
    import_excel = False

    def init_request(self, *args, **kwargs):
        return bool(self.import_excel)#返回bool值，excel显示权限

    def block_top_toolbar(self, context, nodes):
        nodes.append(loader.render_to_string('xadmin/excel/model_list.top_toolbar.import.html'))


xadmin.site.register_plugin(ListImportExcelPlugin, ListAdminView)
</code></pre>
<p><strong>解读：</strong></p>
<ul>
<li>自定义的ListImportExcelPlugin类需要继承BaseAdminPlugin类，这是固定写法。然后定义的init_request方法，是为了确定xadmin中excel导入按钮的显示权限，这里返回一个bool值，为Ture则为显示，False则不显示，这里顶一个了一个import_excel = False变量，默认值为False，其实可以在model对应adminx类中指定import_excel的值，因为xadmin展示的时候回默认加载这个变量，这样就能达到按钮显示权限了。</li>
<li>而block_top_toolbar方法则是必须要重写的方法，这方法作用是将选项按钮固定在toolbar上，并直接nodes.append即可，参数是一个html页面，这个就是点击导入excel后出现的弹窗悬着excel页面。</li>
</ul>
<p>然后需要将自己编写的excel插件文件注册到xadmin中，直接在plugins模块的init文件中PLUGINS配置文件中添加“excel”即可，注意，excelwei插件的文件名，如下：</p>
<pre><code class="language-python">PLUGINS = (
    ...
	'excel'
)
</code></pre>
<h4 id="二后台逻辑"><strong>二.后台逻辑</strong></h4>
<p>当选择了excel文件并且点击了确定后，需要将excel文件传至后台接收处理，这里该怎么做呢？<br>
其实只需要在对应的model关联的adminx类中定义post方法即可，如下：</p>
<pre><code class="language-python">#用于在课程页面导入excel页面后，对导入的excel做后台逻辑
    def post(self, request, *args, **kwargs):
        if 'excel' in request.FILES:
            pass
        return super().post(request, args, kwargs) #最后一定要调用父类CourseAdmin的post方法返回
</code></pre>
<p>这样就能后将excel传至后台，并且编写我们的解析excel逻辑了，这里需要注意的是，post方法一定要返回父类的post方法，这是固定写法，不然的话会报错，连最起码的xadmin保存都会出错。</p>
<p>至此，自己编写的导入excel插件就安装成功啦，类似的其他功能实现方式也差不多，都是这个套路~</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django中xadmin的学习与记录总结]]></title>
        <id>https://skytotwo.github.io//post/django-xadmin</id>
        <link href="https://skytotwo.github.io//post/django-xadmin">
        </link>
        <updated>2019-08-26T14:15:10.000Z</updated>
        <summary type="html"><![CDATA[<p>xadmin是Django中admin后台的进阶插件，它包含了admin的基本功能，并在此基础上进行进一步的升级，使得成为一个功能完善的后台管理系统，像瑞士军刀一样拥有各种功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>xadmin是Django中admin后台的进阶插件，它包含了admin的基本功能，并在此基础上进行进一步的升级，使得成为一个功能完善的后台管理系统，像瑞士军刀一样拥有各种功能。</p>
<h2 id="-more-"><!-- more --></h2>
<h3 id="一xadmin的安装与简单使用"><strong>一.xadmin的安装与简单使用</strong></h3>
<h4 id="1安装"><strong>1.安装</strong></h4>
<p>xadmin有两种方式，一种是通过pip的方式安装，如下：</p>
<pre><code class="language-python">pip install xadmin
</code></pre>
<p>但也可以直接进入github下载，xadmin的下载地址是：<br>
<a href="https://github.com/sshwsfc/xadmin" title="点我进入下载链接">点我进入下载链接</a><br>
并将其直接放置在项目目录下。<br>
采用直接下载方式的原因是直接下载的源码包含更多没有发布至pypi上面的新功能，然后有了源码，后面可以直接更改源码，增加自己的功能，这样其实更方便扩展。</p>
<h4 id="2注册xadmin"><strong>2.注册xadmin</strong></h4>
<p>在settings.py的INSTALLED_APPS中增加如下：</p>
<pre><code class="language-python">'xadmin',
'crispy_forms'
</code></pre>
<p>然后把urls中默认admin指向xadmin:</p>
<pre><code class="language-python">#导入xadmin，替换admin
import xadmin
urlpatterns = [
    url(r'^xadmin/', xadmin.site.urls),
]
</code></pre>
<h4 id="3生成xadmin数据表"><strong>3.生成xadmin数据表</strong></h4>
<p>点击Tools 菜单下 Run manage.py Task：</p>
<pre><code class="language-python">makemigrations
migrate
</code></pre>
<h4 id="4注册model"><strong>4.注册model</strong></h4>
<p>简单的注册一个model看一下效果，如下：</p>
<pre><code class="language-python">
from .models import UserInfo
import xadmin
 
 
class UserInfoAdmin(object):
	list_display = ['user_name', 'user_email', 'user_mobile']  # 默认显示
    search_fields = ['user_name', 'user_email', 'user_mobile']  # 查询
    list_filter = ['user_name', 'user_email', 'user_mobile']  # 过滤筛选
 
xadmin.site.register(UserInfo, UserInfoAdmin)
</code></pre>
<p>如代码中所示，这里是将model和自定义的admin显示规则绑定注册至xadmin中，list_display、search_fields和list_filter分别表示默认显示的字段、可以查询的字段和可以过滤筛选的字段。</p>
<p>实际显示效果如下：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180901214106_476.png" alt="20180901214106_476.png"></p>
<hr>
<h3 id="二xadmin的进阶功能"><strong>二.xadmin的进阶功能</strong></h3>
<p><strong>1.一般外键关联数据在xadmin只能通过在列表选择对应外键数据跳转再去编辑，但是想在详情编辑中，可以直接编辑（只能一层嵌套）：</strong></p>
<pre><code class="language-python">class LessonInline(object):
    model = Lesson
    extra = 0

class CourseAdmin(object):
    list_display = ['name','desc','detail','degree','learn_times','students','fav_nums','image','click_num','add_time']
    search_fields = ['name','desc','detail','degree','learn_times','students','fav_nums','image','click_num']
    list_filter = ['name','desc','detail','degree','learn_times','students','fav_nums','image','click_num','add_time']
    inlines = [LessonInline]

</code></pre>
<p><strong>2.自定义图标、自定义字段排序、自定义字段不可编辑、编辑页面自定义影藏某字段、下拉选涉及到外检选择的改为搜索选择</strong></p>
<pre><code class="language-python">class CourseAdmin(object):
    list_display = ['name','desc','detail','degree','learn_times','students','fav_nums','image','click_num','add_time']
    search_fields = ['name','desc','detail','degree','learn_times','students','fav_nums','image','click_num']
    list_filter = ['name','desc','detail','degree','learn_times','students','fav_nums','image','click_num','add_time']
    model_icon = 'fa fa-book' #自定义图标
    ordering = ['-click_num'] #显示排序
    readonly_fields = ['click_num','fav_nums']#后台不可编辑
    exclude= ['add_time']  #详情不显示add_time 此字段与readonly_fields互斥
    relfield_style='fk-ajax' #下拉筛选改为搜索
</code></pre>
<p><strong>3.一张表在后台注册成两个管理器，以课程为例，课程一张表，后台分为轮播课程、非轮播课程。</strong><br>
<strong>model代码如下：</strong></p>
<pre><code class="language-python">class Course(models.Model):
    name = models.CharField(verbose_name=u'课程名',max_length=50)
    is_banner = models.BooleanField(verbose_name=u'是否轮播',default=False) #是否为轮播课程
    add_time = models.DateTimeField(verbose_name=u'添加时间',default=datetime.now)

    class Meta:
        verbose_name = u'课程'
        verbose_name_plural = verbose_name

    def __unicode__(self):
        return self.name

class BannerCourse(Course):
    '''banner课程'''
    class Meta:
        verbose_name = u'轮播课程'
        verbose_name_plural = verbose_name
        proxy = True #不会生成表

</code></pre>
<p>这样定义其实原理是，其中自定义一个model，继承自另一个model，然后关键的是自定义的马哥model，需要在Meta中声明proxy = True，这样就不会生成另一个表，实现两个model公共一个表，而两个model可以在xadmin中注册两个管理器。</p>
<p><strong>下面是adminx的代码:</strong></p>
<pre><code class="language-python">class CourseAdmin(object):
    list_display = ['name','is_banner','add_time']
    search_fields = ['name','is_banner']
    list_filter = ['name','is_banner', 'add_time']

    def queryset(self):
        qs = super().queryset()
        qs = qs.filter(is_banner=False)
        return qs

class BannerCourseAdmin(object):
    list_display = ['name', 'is_banner', 'add_time']
    search_fields = ['name', 'is_banner']
    list_filter = ['name', 'is_banner', 'add_time']

    def queryset(self):
        qs = super().queryset()
        qs = qs.filter(is_banner=True)
        return qs

xadmin.site.register(BannerCourse, BannerCourseAdmin)
xadmin.site.register(Course, CourseAdmin)
</code></pre>
<p>其中重要的是queryset方法，该方法的重写，意义在于重写父类的queryset方法，然后过滤出自定义管理器，如直接定义is_banner=True，这样，两个管理器就实现了分别管理不同的数据了。</p>
<p><strong>4.将model中的方法获取的值，在后台列表字段显示：</strong></p>
<pre><code class="language-python">#model中代码如下：
class Course(models.Model):
    name = models.CharField(verbose_name=u'课程名',max_length=50)

    class Meta:
        verbose_name = u'课程'
        verbose_name_plural = verbose_name

    def get_zj_nums(self):
        '''获取该课程章节'''
        return  self.lesson_set.all().count()
    get_zj_nums.short_description = u'章节数'   #指定后台显示列表字段名

    def __unicode__(self):
        return self.name
</code></pre>
<pre><code class="language-python">#admix中代码如下：
class CourseAdmin(object):
    list_display = ['name','get_zj_nums']
    search_fields = ['name']
    list_filter = ['name']
</code></pre>
<p>直接将在model中定义的方法，写在list_display中展示，xadmin会自动判断这是一个方法，并将方法得到的值进行展示。<br>
注意：如果需要改变该方法的字段名显示，直接方法名.short_description即可，如get_zj_nums.short_description = u'章节数'</p>
<p><strong>5.在model中定义方法，返回html，在后台以html代码形式显示：</strong></p>
<pre><code class="language-python">#model中代码：
class Course(models.Model):
    name = models.CharField(verbose_name=u'课程名',max_length=50)

    class Meta:
        verbose_name = u'课程'
        verbose_name_plural = verbose_name

    def go_to(self):
        from django.utils.safestring import mark_safe
        return mark_safe('&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;')百度&lt;/a&gt;' #如果不使用mark_safe，在后台显示的就是一段文本了
     go_to.short_description = u'跳转'  # 指定后台显示列表字段名

    def __unicode__(self):
        return self.name

# admix中代码如下：
class CourseAdmin(object):
    list_display = ['name', 'go_to']
    search_fields = ['name']
    list_filter = ['name']
</code></pre>
<p>这里关键处在于，对返回的链接的处理，这里需要使用django.utils.safestring中的mark_safe方法，因为Django有自己的保护机制，如果不使用mark_safe，在后台显示的就是一段文本了，这里需要使用mark_safe将其正确解读成一个链接。</p>
<p><strong>6.xadmin集成百度uditor编辑器</strong><br>
基本步骤：</p>
<pre><code class="language-shell">github上搜素django ueditor，找到zhangfisher/DjangoUeditor,下载并解压，
切换命令行到解压后的目录执行python setup.py install（如果是虚拟环境开发，进入虚拟环境在进入对应目录）
将 DjangoUeditor 放入到settings.py中的INSTALLED_APPS
</code></pre>
<p>配置urls.py如下：</p>
<pre><code class="language-python">urlpatterns = [
    ...
    url(r'^ueditor/', include('DjangoUeditor.urls')),
]
</code></pre>
<p>比如给课程加富文本编辑器，去Course的model中引入代码：</p>
<pre><code class="language-python">from DjangoUeditor.models import UEditorField
</code></pre>
<p>对需要添加ueditor字段的修改：</p>
<pre><code class="language-python">detail = UEditorField(u'课程详情', width=600, height=300, imagePath=&quot;course/ueditor/&quot;, filePath=&quot;course/ueditor/&quot;, upload_settings={&quot;imageMaxSize&quot;: 1204000},default='')
#imagePath：图片上传路径，跟平时写的model中的路径是一样的
#filePath:富文本中文件的路径，跟平时写的model中的路径是一样的
</code></pre>
<p>给xadmin写插件集成ueditor，在xadmin/plugin下新建ueditor.py(名字随意.py),代码如下：</p>
<pre><code class="language-python">```python
import xadmin
from xadmin.views import BaseAdminPlugin,CreateAdminView,UpdateAdminView
from DjangoUeditor.models import UEditorField
from DjangoUeditor.widgets import UEditorWidget
from django.conf import settings

class XadminUEditorWidget(UEditorWidget):
    def __init__(self,**kwargs):
        self.ueditor_options = kwargs
        self.Media.js = None
        super(XadminUEditorWidget,self).__init__(kwargs)

class UeditorPlugin(BaseAdminPlugin):
    def get_field_style(self,attrs,db_field,style,**kwargs):
        if style == 'ueditor': #这个字段与adminx中的style_fields = {'detail':'ueditor'} 字段对应
            if isinstance(db_field,UEditorField):
                widget = db_field.formfield().widget
                param = {}
                param.update(widget.ueditor_settings)
                param.update(widget.attrs)
                return {'widget':XadminUEditorWidget(**param)}
            return attrs

	def block_extrahead(self,context,nodes):
        js = '&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;' % (settings.STATIC_URL + &quot;ueditor/ueditor.config.js&quot;)
        js += '&lt;script type=&quot;text/javascript&quot; src=&quot;%s&quot;&gt;&lt;/script&gt;' % (settings.STATIC_URL + &quot;ueditor/ueditor.all.min.js&quot;)
            nodes.append(js)

xadmin.site.register_plugin(UeditorPlugin,UpdateAdminView)
xadmin.site.register_plugin(UeditorPlugin,CreateAdminView)
</code></pre>
<pre><code>在课程的adminx中CourseAdmin加入代码如下：
```python
class CourseAdmin(object):
    ....
    style_fields = {'detail':'ueditor'}
</code></pre>
<p>修改urls中的上传路由：</p>
<pre><code class="language-python">#富文本相关url(用于上传文件等)
    url(r'^ueditor/', include('DjangoUeditor.urls')),
</code></pre>
<p>前端展示，全是转义后的html，关闭django模板转义：</p>
<pre><code class="language-python">{% autoescape off%}
   {{ course.detail }}
{% endautoescape %}
</code></pre>
]]></content>
    </entry>
</feed>