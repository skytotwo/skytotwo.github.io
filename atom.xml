<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skytotwo.github.io/</id>
    <title>Totoro の Home</title>
    <updated>2019-08-12T09:10:03.046Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skytotwo.github.io/"/>
    <link rel="self" href="https://skytotwo.github.io//atom.xml"/>
    <subtitle>空杯心态，每天进步</subtitle>
    <logo>https://skytotwo.github.io//images/avatar.png</logo>
    <icon>https://skytotwo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Totoro の Home</rights>
    <entry>
        <title type="html"><![CDATA[微信小程序支付  带java后端]]></title>
        <id>https://skytotwo.github.io//post/wechat-pay-java</id>
        <link href="https://skytotwo.github.io//post/wechat-pay-java">
        </link>
        <updated>2019-08-12T09:07:43.000Z</updated>
        <summary type="html"><![CDATA[<p>话不多说，直接开撸。</p>
]]></summary>
        <content type="html"><![CDATA[<p>话不多说，直接开撸。</p>
<!-- more -->
<p>支付流程步骤：</p>
<p>1）首先调用wx.login方法获取code，通过code获取openid；</p>
<p>2）java后台调用统一下单支付接口（这里会进行第一次签名），用来获取prepay_id；</p>
<p>3）java后台再次调用签名（这里会进行第二次签名），并返回支付需要用使用的参数；</p>
<p>4）小程序前端wx.requestPayment方法发起微信支付；</p>
<p>5）java后台接收来自微信服务器的通知并处理结果。</p>
<p>详细步骤可参考：https://pay.weixin.qq.com/wiki/doc/api/wxa/wxa_api.php?chapter=7_4&amp;index=3</p>
<p>demo链接: https://pan.baidu.com/s/1v8QWUE1m2EnA4uAoAZtRRQ 密码: cgrt</p>
<p>一、获取openid，</p>
<p>这里的代码可以参考博主的另外一篇文章http://www.listenlife.cn:8080/post/34  中的3.1 代码模块，代码先贴上，如果了解更多点击链接查看</p>
<p>小程序端代码</p>
<pre><code class="language-javascript">[javascript] view plain copy
wx.login({    
  success: function (res) {    
    var service_url = 'https://???/???/weixin/api/login?code=' + res.code;//需要将服务器域名添加到小程序的request合法域名中，而且必须是https开头    
    wx.request({    
      url: l,    
      data: {},    
      method: 'GET',    
      success: function (res) {    
        console.log(res);    
        if (res.data != null &amp;&amp; res.data != undefined &amp;&amp; res.data != '') {    
          wx.setStorageSync(&quot;openid&quot;, res.data.openid);//将获取的openid存到缓存中    
        }    
      }    
    });    
  }    
});
</code></pre>
<p>java后端代码</p>
<pre><code class="language-java">[java] view plain copy
/**  
  * 小程序后台登录，向微信平台发送获取access_token请求，并返回openId  
  * @param code  
  * @return 用户凭证  
  * @throws WeixinException  
  * @throws IOException   
  * @throws JsonMappingException   
  * @throws JsonParseException   
  */    
 @RequestMapping(&quot;login&quot;)    
 @ResponseBody    
 public Map&lt;String, Object&gt; login(String code, HttpServletRequest request) throws WeixinException, JsonParseException, JsonMappingException, IOException {    
     if (code == null || code.equals(&quot;&quot;)) {    
         throw new WeixinException(&quot;invalid null, code is null.&quot;);    
     }    
         
     Map&lt;String, Object&gt; ret = new HashMap&lt;String, Object&gt;();    
     //拼接参数    
     String param = &quot;?grant_type=&quot; + grant_type + &quot;&amp;appid=&quot; + appid + &quot;&amp;secret=&quot; + secret + &quot;&amp;js_code=&quot; + code;    
         
     System.out.println(&quot;https://api.weixin.qq.com/sns/jscode2session&quot; + param);    
         
     //创建请求对象    
     HttpsClient http = new HttpsClient();    
     //调用获取access_token接口    
     Response res = http.get(&quot;https://api.weixin.qq.com/sns/jscode2session&quot; + param);    
     //根据请求结果判定，是否验证成功    
     JSONObject jsonObj = res.asJSONObject();    
     if (jsonObj != null) {    
         Object errcode = jsonObj.get(&quot;errcode&quot;);    
         if (errcode != null) {    
             //返回异常信息    
             throw new WeixinException(getCause(Integer.parseInt(errcode.toString())));    
         }    
             
         ObjectMapper mapper = new ObjectMapper();    
         OAuthJsToken oauthJsToken = mapper.readValue(jsonObj.toJSONString(),OAuthJsToken.class);    
         ret.put(&quot;openid&quot;, oauthJsToken.getOpenid());    
     }    
     return ret;    
 }
</code></pre>
<p>二、小程序调用java后端接口，生成最终签名和相关参数小程序端代码：</p>
<pre><code class="language-javascript">[javascript] view plain copy
var that = this;  
      wx.request({  
        url: service_url + 'wxPay',  
        data: { },  
        method: 'GET',  
        success: function (res) {  
          console.log(res);  
           that.doWxPay(res.data);  
        }  
      }); 
</code></pre>
<p>java端代码：</p>
<pre><code class="language-java">[java] view plain copy
/** 
     * @Description: 发起微信支付 
     * @param request 
     */  
    public Json wxPay(Integer openid, HttpServletRequest request){  
        try{  
            //生成的随机字符串  
            String nonce_str = StringUtils.getRandomStringByLength(32);  
            //商品名称  
            String body = &quot;测试商品名称&quot;;  
            //获取客户端的ip地址  
            String spbill_create_ip = IpUtil.getIpAddr(request);  
              
            //组装参数，用户生成统一下单接口的签名  
            Map&lt;String, String&gt; packageParams = new HashMap&lt;String, String&gt;();  
            packageParams.put(&quot;appid&quot;, WxPayConfig.appid);  
            packageParams.put(&quot;mch_id&quot;, WxPayConfig.mch_id);  
            packageParams.put(&quot;nonce_str&quot;, nonce_str);  
            packageParams.put(&quot;body&quot;, body);  
            packageParams.put(&quot;out_trade_no&quot;, &quot;123456789&quot;);//商户订单号  
            packageParams.put(&quot;total_fee&quot;, &quot;1&quot;);//支付金额，这边需要转成字符串类型，否则后面的签名会失败  
            packageParams.put(&quot;spbill_create_ip&quot;, spbill_create_ip);  
            packageParams.put(&quot;notify_url&quot;, WxPayConfig.notify_url);//支付成功后的回调地址  
            packageParams.put(&quot;trade_type&quot;, WxPayConfig.TRADETYPE);//支付方式  
            packageParams.put(&quot;openid&quot;, openid);  
                 
                String prestr = PayUtil.createLinkString(packageParams); // 把数组所有元素，按照“参数=参数值”的模式用“&amp;”字符拼接成字符串   
              
                //MD5运算生成签名，这里是第一次签名，用于调用统一下单接口  
                String mysign = PayUtil.sign(prestr, WxPayConfig.key, &quot;utf-8&quot;).toUpperCase();  
              
            //拼接统一下单接口使用的xml数据，要将上一步生成的签名一起拼接进去  
            String xml = &quot;&lt;xml&gt;&quot; + &quot;&lt;appid&gt;&quot; + WxPayConfig.appid + &quot;&lt;/appid&gt;&quot;   
                    + &quot;&lt;body&gt;&lt;![CDATA[&quot; + body + &quot;]]&gt;&lt;/body&gt;&quot;   
                    + &quot;&lt;mch_id&gt;&quot; + WxPayConfig.mch_id + &quot;&lt;/mch_id&gt;&quot;   
                    + &quot;&lt;nonce_str&gt;&quot; + nonce_str + &quot;&lt;/nonce_str&gt;&quot;   
                    + &quot;&lt;notify_url&gt;&quot; + WxPayConfig.notify_url + &quot;&lt;/notify_url&gt;&quot;   
                    + &quot;&lt;openid&gt;&quot; + order.getOpenId() + &quot;&lt;/openid&gt;&quot;   
                    + &quot;&lt;out_trade_no&gt;&quot; + order.getOrderNo() + &quot;&lt;/out_trade_no&gt;&quot;   
                    + &quot;&lt;spbill_create_ip&gt;&quot; + spbill_create_ip + &quot;&lt;/spbill_create_ip&gt;&quot;   
                    + &quot;&lt;total_fee&gt;&quot; + order.getPayMoney() + &quot;&lt;/total_fee&gt;&quot;  
                    + &quot;&lt;trade_type&gt;&quot; + WxPayConfig.TRADETYPE + &quot;&lt;/trade_type&gt;&quot;   
                    + &quot;&lt;sign&gt;&quot; + mysign + &quot;&lt;/sign&gt;&quot;  
                    + &quot;&lt;/xml&gt;&quot;;  
              
            System.out.println(&quot;调试模式_统一下单接口 请求XML数据：&quot; + xml);  
  
            //调用统一下单接口，并接受返回的结果  
            String result = PayUtil.httpRequest(WxPayConfig.pay_url, &quot;POST&quot;, xml);  
              
            System.out.println(&quot;调试模式_统一下单接口 返回XML数据：&quot; + result);  
              
            // 将解析结果存储在HashMap中     
            Map map = PayUtil.doXMLParse(result);  
              
            String return_code = (String) map.get(&quot;return_code&quot;);//返回状态码  
              
            Map&lt;String, Object&gt; response = new HashMap&lt;String, Object&gt;();//返回给小程序端需要的参数  
            if(return_code==&quot;SUCCESS&quot;||return_code.equals(return_code)){     
                String prepay_id = (String) map.get(&quot;prepay_id&quot;);//返回的预付单信息     
                response.put(&quot;nonceStr&quot;, nonce_str);  
                response.put(&quot;package&quot;, &quot;prepay_id=&quot; + prepay_id);  
                Long timeStamp = System.currentTimeMillis() / 1000;     
                response.put(&quot;timeStamp&quot;, timeStamp + &quot;&quot;);//这边要将返回的时间戳转化成字符串，不然小程序端调用wx.requestPayment方法会报签名错误  
                //拼接签名需要的参数  
                String stringSignTemp = &quot;appId=&quot; + WxPayConfig.appid + &quot;&amp;nonceStr=&quot; + nonce_str + &quot;&amp;package=prepay_id=&quot; + prepay_id+ &quot;&amp;signType=MD5&amp;timeStamp=&quot; + timeStamp;     
                //再次签名，这个签名用于小程序端调用wx.requesetPayment方法  
                String paySign = PayUtil.sign(stringSignTemp, WxPayConfig.key, &quot;utf-8&quot;).toUpperCase();  
                  
                response.put(&quot;paySign&quot;, paySign);  
            }  
              
            response.put(&quot;appid&quot;, WxPayConfig.appid);  
              
            return response;  
        }catch(Exception e){  
            e.printStackTrace();  
        }  
        return null;  
    }  
    /** 
     * StringUtils工具类方法 
     * 获取一定长度的随机字符串，范围0-9，a-z 
     * @param length：指定字符串长度 
     * @return 一定长度的随机字符串 
     */  
    public static String getRandomStringByLength(int length) {  
        String base = &quot;abcdefghijklmnopqrstuvwxyz0123456789&quot;;  
        Random random = new Random();  
        StringBuffer sb = new StringBuffer();  
        for (int i = 0; i &lt; length; i++) {  
            int number = random.nextInt(base.length());  
            sb.append(base.charAt(number));  
        }  
        return sb.toString();  
       }  
    /** 
     * IpUtils工具类方法 
     * 获取真实的ip地址 
     * @param request 
     * @return 
     */  
    public static String getIpAddr(HttpServletRequest request) {  
        String ip = request.getHeader(&quot;X-Forwarded-For&quot;);  
        if(StringUtils.isNotEmpty(ip) &amp;&amp; !&quot;unKnown&quot;.equalsIgnoreCase(ip)){  
             //多次反向代理后会有多个ip值，第一个ip才是真实ip  
            int index = ip.indexOf(&quot;,&quot;);  
            if(index != -1){  
                return ip.substring(0,index);  
            }else{  
                return ip;  
            }  
        }  
        ip = request.getHeader(&quot;X-Real-IP&quot;);  
        if(StringUtils.isNotEmpty(ip) &amp;&amp; !&quot;unKnown&quot;.equalsIgnoreCase(ip)){  
           return ip;  
        }  
        return request.getRemoteAddr();  
    } 
</code></pre>
<p>WxPayConfig小程序配置文件</p>
<pre><code class="language-java">[java] view plain copy
/** 
 * 小程序微信支付的配置文件 
 * @author  
 * 
 */  
public class WxPayConfig {  
    //小程序appid  
    public static final String appid = &quot;&quot;;  
    //微信支付的商户id  
    public static final String mch_id = &quot;&quot;;  
    //微信支付的商户密钥  
    public static final String key = &quot;&quot;;  
    //支付成功后的服务器回调url  
    public static final String notify_url = &quot;https://??/??/weixin/api/wxNotify&quot;;  
    //签名方式，固定值  
    public static final String SIGNTYPE = &quot;MD5&quot;;  
    //交易类型，小程序支付的固定值为JSAPI  
    public static final String TRADETYPE = &quot;JSAPI&quot;;  
    //微信统一下单接口地址  
    public static final String pay_url = &quot;https://api.mch.weixin.qq.com/pay/unifiedorder&quot;;  
}  

PayUtils工具类
[java] view plain copy
import java.io.BufferedReader;  
import java.io.ByteArrayInputStream;  
import java.io.IOException;  
import java.io.InputStream;  
import java.io.InputStreamReader;  
import java.io.OutputStream;  
import java.io.UnsupportedEncodingException;  
import java.net.HttpURLConnection;  
import java.net.URL;  
import java.security.SignatureException;  
import java.util.ArrayList;  
import java.util.Collections;  
import java.util.HashMap;  
import java.util.Iterator;  
import java.util.List;  
import java.util.Map;  
  
import org.apache.commons.codec.digest.DigestUtils;  
import org.jdom.Document;  
import org.jdom.Element;  
import org.jdom.JDOMException;  
import org.jdom.input.SAXBuilder;  
  
public class PayUtil {  
     /**   
     * 签名字符串   
     * @param text需要签名的字符串   
     * @param key 密钥   
     * @param input_charset编码格式   
     * @return 签名结果   
     */     
    public static String sign(String text, String key, String input_charset) {     
        text = text + &quot;&amp;key=&quot; + key;     
        return DigestUtils.md5Hex(getContentBytes(text, input_charset));     
    }     
    /**   
     * 签名字符串   
     *  @param text需要签名的字符串   
     * @param sign 签名结果   
     * @param key密钥   
     * @param input_charset 编码格式   
     * @return 签名结果   
     */     
    public static boolean verify(String text, String sign, String key, String input_charset) {     
        text = text + key;     
        String mysign = DigestUtils.md5Hex(getContentBytes(text, input_charset));     
        if (mysign.equals(sign)) {     
            return true;     
        } else {     
            return false;     
        }     
    }     
    /**   
     * @param content   
     * @param charset   
     * @return   
     * @throws SignatureException   
     * @throws UnsupportedEncodingException   
     */     
    public static byte[] getContentBytes(String content, String charset) {     
        if (charset == null || &quot;&quot;.equals(charset)) {     
            return content.getBytes();     
        }     
        try {     
            return content.getBytes(charset);     
        } catch (UnsupportedEncodingException e) {     
            throw new RuntimeException(&quot;MD5签名过程中出现错误,指定的编码集不对,您目前指定的编码集是:&quot; + charset);     
        }     
    }     
      
    private static boolean isValidChar(char ch) {     
        if ((ch &gt;= '0' &amp;&amp; ch &lt;= '9') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') || (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z'))     
            return true;     
        if ((ch &gt;= 0x4e00 &amp;&amp; ch &lt;= 0x7fff) || (ch &gt;= 0x8000 &amp;&amp; ch &lt;= 0x952f))     
            return true;// 简体中文汉字编码     
        return false;     
    }     
    /**   
     * 除去数组中的空值和签名参数   
     * @param sArray 签名参数组   
     * @return 去掉空值与签名参数后的新签名参数组   
     */     
    public static Map&lt;String, String&gt; paraFilter(Map&lt;String, String&gt; sArray) {     
        Map&lt;String, String&gt; result = new HashMap&lt;String, String&gt;();     
        if (sArray == null || sArray.size() &lt;= 0) {     
            return result;     
        }     
        for (String key : sArray.keySet()) {     
            String value = sArray.get(key);     
            if (value == null || value.equals(&quot;&quot;) || key.equalsIgnoreCase(&quot;sign&quot;)     
                    || key.equalsIgnoreCase(&quot;sign_type&quot;)) {     
                continue;     
            }     
            result.put(key, value);     
        }     
        return result;     
    }     
    /**   
     * 把数组所有元素排序，并按照“参数=参数值”的模式用“&amp;”字符拼接成字符串   
     * @param params 需要排序并参与字符拼接的参数组   
     * @return 拼接后字符串   
     */     
    public static String createLinkString(Map&lt;String, String&gt; params) {     
        List&lt;String&gt; keys = new ArrayList&lt;String&gt;(params.keySet());     
        Collections.sort(keys);     
        String prestr = &quot;&quot;;     
        for (int i = 0; i &lt; keys.size(); i++) {     
            String key = keys.get(i);     
            String value = params.get(key);     
            if (i == keys.size() - 1) {// 拼接时，不包括最后一个&amp;字符     
                prestr = prestr + key + &quot;=&quot; + value;     
            } else {     
                prestr = prestr + key + &quot;=&quot; + value + &quot;&amp;&quot;;     
            }     
        }     
        return prestr;     
    }     
    /**   
     *   
     * @param requestUrl请求地址   
     * @param requestMethod请求方法   
     * @param outputStr参数   
     */     
    public static String httpRequest(String requestUrl,String requestMethod,String outputStr){     
        // 创建SSLContext     
        StringBuffer buffer = null;     
        try{     
            URL url = new URL(requestUrl);     
            HttpURLConnection conn = (HttpURLConnection) url.openConnection();     
            conn.setRequestMethod(requestMethod);     
            conn.setDoOutput(true);     
            conn.setDoInput(true);     
            conn.connect();     
            //往服务器端写内容     
            if(null !=outputStr){     
                OutputStream os=conn.getOutputStream();     
                os.write(outputStr.getBytes(&quot;utf-8&quot;));     
                os.close();     
            }     
            // 读取服务器端返回的内容     
            InputStream is = conn.getInputStream();     
            InputStreamReader isr = new InputStreamReader(is, &quot;utf-8&quot;);     
            BufferedReader br = new BufferedReader(isr);     
            buffer = new StringBuffer();     
            String line = null;     
            while ((line = br.readLine()) != null) {     
                buffer.append(line);     
            }     
[java] view plain copy
                br.close();  
        }catch(Exception e){     
            e.printStackTrace();     
        }  
        return buffer.toString();  
    }       
    public static String urlEncodeUTF8(String source){     
        String result=source;     
        try {     
            result=java.net.URLEncoder.encode(source, &quot;UTF-8&quot;);     
        } catch (UnsupportedEncodingException e) {     
            // TODO Auto-generated catch block     
            e.printStackTrace();     
        }     
        return result;     
    }   
    /** 
     * 解析xml,返回第一级元素键值对。如果第一级元素有子节点，则此节点的值是子节点的xml数据。 
     * @param strxml 
     * @return 
     * @throws JDOMException 
     * @throws IOException 
     */  
    public static Map doXMLParse(String strxml) throws Exception {  
        if(null == strxml || &quot;&quot;.equals(strxml)) {  
            return null;  
        }  
          
        Map m = new HashMap();  
        InputStream in = String2Inputstream(strxml);  
        SAXBuilder builder = new SAXBuilder();  
        Document doc = builder.build(in);  
        Element root = doc.getRootElement();  
        List list = root.getChildren();  
        Iterator it = list.iterator();  
        while(it.hasNext()) {  
            Element e = (Element) it.next();  
            String k = e.getName();  
            String v = &quot;&quot;;  
            List children = e.getChildren();  
            if(children.isEmpty()) {  
                v = e.getTextNormalize();  
            } else {  
                v = getChildrenText(children);  
            }  
              
            m.put(k, v);  
        }  
          
        //关闭流  
        in.close();  
          
        return m;  
    }  
    /** 
     * 获取子结点的xml 
     * @param children 
     * @return String 
     */  
    public static String getChildrenText(List children) {  
        StringBuffer sb = new StringBuffer();  
        if(!children.isEmpty()) {  
            Iterator it = children.iterator();  
            while(it.hasNext()) {  
                Element e = (Element) it.next();  
                String name = e.getName();  
                String value = e.getTextNormalize();  
                List list = e.getChildren();  
                sb.append(&quot;&lt;&quot; + name + &quot;&gt;&quot;);  
                if(!list.isEmpty()) {  
                    sb.append(getChildrenText(list));  
                }  
                sb.append(value);  
                sb.append(&quot;&lt;/&quot; + name + &quot;&gt;&quot;);  
            }  
        }  
          
        return sb.toString();  
    }  
    public static InputStream String2Inputstream(String str) {  
        return new ByteArrayInputStream(str.getBytes());  
    }  
} 
</code></pre>
<p>三、小程序端发起最终支付，调用微信付款</p>
<pre><code class="language-javascript">[javascript] view plain copy
doWxPay(param){  
        //小程序发起微信支付  
            wx.requestPayment({  
              timeStamp: param.data.timeStamp,//记住，这边的timeStamp一定要是字符串类型的，不然会报错，我这边在java后端包装成了字符串类型了  
              nonceStr: param.data.nonceStr,  
              package: param.data.package,  
              signType: 'MD5',  
              paySign: param.data.paySign,  
              success: function (event) {  
                // success     
                console.log(event);  
                  
                wx.showToast({  
                  title: '支付成功',  
                  icon: 'success',  
                  duration: 2000  
                });  
              },  
              fail: function (error) {  
                // fail     
                console.log(&quot;支付失败&quot;)  
                console.log(error)  
              },  
              complete: function () {  
                // complete     
                console.log(&quot;pay complete&quot;)  
              }  
            });  
    } 
</code></pre>
<p>四、微信服务器通知java后端</p>
<pre><code class="language-java">[java] view plain copy
/** 
     * @Description:微信支付     
     * @return 
     * @throws Exception  
     */  
    @RequestMapping(value=&quot;/wxNotify&quot;)  
    @ResponseBody  
    public void wxNotify(HttpServletRequest request,HttpServletResponse response) throws Exception{  
        BufferedReader br = new BufferedReader(new InputStreamReader((ServletInputStream)request.getInputStream()));  
        String line = null;  
        StringBuilder sb = new StringBuilder();  
        while((line = br.readLine()) != null){  
            sb.append(line);  
        }  
[java] view plain copy
        br.close();  
        //sb为微信返回的xml  
        String notityXml = sb.toString();  
        String resXml = &quot;&quot;;  
        System.out.println(&quot;接收到的报文：&quot; + notityXml);  
      
        Map map = PayUtil.doXMLParse(notityXml);  
          
        String returnCode = (String) map.get(&quot;return_code&quot;);  
        if(&quot;SUCCESS&quot;.equals(returnCode)){  
            //验证签名是否正确  
            if(PayUtil.verify(PayUtil.createLinkString(map), (String)map.get(&quot;sign&quot;), WxPayConfig.key, &quot;utf-8&quot;)){  
                /**此处添加自己的业务逻辑代码start**/  
                  
                  
                /**此处添加自己的业务逻辑代码end**/  
                //通知微信服务器已经支付成功  
                resXml = &quot;&lt;xml&gt;&quot; + &quot;&lt;return_code&gt;&lt;![CDATA[SUCCESS]]&gt;&lt;/return_code&gt;&quot;  
                + &quot;&lt;return_msg&gt;&lt;![CDATA[OK]]&gt;&lt;/return_msg&gt;&quot; + &quot;&lt;/xml&gt; &quot;;  
            }  
        }else{  
            resXml = &quot;&lt;xml&gt;&quot; + &quot;&lt;return_code&gt;&lt;![CDATA[FAIL]]&gt;&lt;/return_code&gt;&quot;  
            + &quot;&lt;return_msg&gt;&lt;![CDATA[报文为空]]&gt;&lt;/return_msg&gt;&quot; + &quot;&lt;/xml&gt; &quot;;  
        }  
        System.out.println(resXml);  
        System.out.println(&quot;微信支付回调数据结束&quot;);  
  
  
        BufferedOutputStream out = new BufferedOutputStream(  
                response.getOutputStream());  
        out.write(resXml.getBytes());  
        out.flush();  
        out.close();  
    } 
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[css图片居中(水平居中和垂直居中)]]></title>
        <id>https://skytotwo.github.io//post/css-centered</id>
        <link href="https://skytotwo.github.io//post/css-centered">
        </link>
        <updated>2019-08-12T09:03:37.000Z</updated>
        <summary type="html"><![CDATA[<p>css图片居中分css图片水平居中和垂直居中两种情况，有时候还需要图片同时水平垂直居中，下面分几种居中情况分别介绍:</p>
]]></summary>
        <content type="html"><![CDATA[<p>css图片居中分css图片水平居中和垂直居中两种情况，有时候还需要图片同时水平垂直居中，下面分几种居中情况分别介绍:</p>
 <!-- more -->
<h4 id="css图片水平居中">css图片水平居中</h4>
<p><strong>1.利用margin: 0 auto实现图片水平居中</strong></p>
<p>利用margin: 0 auto实现图片居中就是在图片上加上css样式margin: 0 auto 如下：</p>
<pre><code class="language-javascript">&lt;div style=&quot;text-align: center; width: 500px; border: green solid 1px;&quot;&gt;
&lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; style=&quot;margin: 0 auto;&quot; /&gt;
&lt;/div&gt;
</code></pre>
<p><strong>2.利用文本的水平居中属性text-align: center</strong></p>
<p>代码如下:</p>
<pre><code class="language-javascript">&lt;div style=&quot;text-align: center; width: 500px; border: green solid 1px;&quot;&gt;
&lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; style=&quot;display: inline-block;&quot; /&gt;
&lt;/div&gt;
</code></pre>
<h4 id="css图片垂直居中">css图片垂直居中</h4>
<p><strong>1.利用高==行高实现图片垂直居中</strong></p>
<p>这种方法是要注明高度才可以使用，代码如下：</p>
<pre><code class="language-javascript">&lt;div style=&quot;text-align: center; width: 500px;height:200px; line-height:200px; border: green solid 1px;&quot;&gt;
   &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; style=&quot;display: inline-block; vertical-align: middle;&quot; /&gt;
&lt;/div&gt;
</code></pre>
<p><strong>2.利用table实现图片垂直居中</strong></p>
<p>利用table的方法是利用了table的垂直居中属性，代码如下：</p>
<p>这里使用display: table;和display: table-cell;来模拟table，这种方法并不兼容IE6/IE7，IE67不支持display: table，如果你不需要支持IE67那就可以用</p>
<p>缺点：当你设置了display: table;可能会改变你的原有布局</p>
<pre><code class="language-javascript">&lt;div style=&quot;text-align: center; width: 500px;height:200px; display: table;border: green solid 1px;&quot;&gt;
   &lt;span style=&quot;display: table-cell; vertical-align: middle; &quot;&gt;
       &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; style=&quot;display: inline-block;&quot; /&gt;
   &lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p><strong>3.利用绝对定位实现图片垂直居中</strong></p>
<p>如果已知图片的宽度和高度可以这样，代码如下：</p>
<pre><code class="language-javascript">&lt;div style=&quot;width: 500px;height:200px; position: relative; border: green solid 1px;&quot;&gt;
    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; style=&quot;width: 120px; height: 40px;position: absolute; left:50%; top: 50%; margin-left: -60px;margin-top: -20px;&quot; /&gt;
&lt;/div&gt;
</code></pre>
<p><strong>4.移动端可以利用flex布局实现css图片垂直居中</strong></p>
<p>移动端一般浏览器版本都比较高，所以可以大胆的使用flex布局，（flex布局参考css3的flex布局用法）演示代码如下：</p>
<p>css代码：</p>
<pre><code class="language-javascript">&lt;style type=&quot;text/css&quot;&gt;

        .ui-flex {
            display: -webkit-box !important;
            display: -webkit-flex !important;
            display: -ms-flexbox !important;
            display: flex !important;
            -webkit-flex-wrap: wrap;
            -ms-flex-wrap: wrap;
            flex-wrap: wrap
        }

        .ui-flex, .ui-flex *, .ui-flex :after, .ui-flex :before {
            box-sizing: border-box
        }

        .ui-flex.justify-center {
            -webkit-box-pack: center;
            -webkit-justify-content: center;
            -ms-flex-pack: center;
            justify-content: center
        }
        .ui-flex.center {
            -webkit-box-pack: center;
            -webkit-justify-content: center;
            -ms-flex-pack: center;
            justify-content: center;
            -webkit-box-align: center;
            -webkit-align-items: center;
            -ms-flex-align: center;
            align-items: center
        }
    &lt;/style&gt;
</code></pre>
<p>html代码：</p>
<pre><code class="language-javascript">&lt;div class=&quot;ui-flex justify-center center&quot; style=&quot;border: green solid 1px; width: 500px; height: 200px;&quot;&gt;
    &lt;div class=&quot;cell&quot;&gt;
    &lt;img alt=&quot;&quot; src=&quot;https://www.baidu.com/img/baidu_jgylogo3.gif&quot; style=&quot;&quot; /&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序学习记要（下）]]></title>
        <id>https://skytotwo.github.io//post/wechat-learning-2</id>
        <link href="https://skytotwo.github.io//post/wechat-learning-2">
        </link>
        <updated>2019-08-12T08:56:33.000Z</updated>
        <summary type="html"><![CDATA[<p>之前记录了微信小程序学习的上集，这次记录下下部分，内容不多，但是我觉得这些点还是需要关注下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前记录了微信小程序学习的上集，这次记录下下部分，内容不多，但是我觉得这些点还是需要关注下。</p>
<!-- more -->
<p>1、需要自定义参数传值的时候，固定格式为data-自定义名称，如：</p>
<pre><code class="language-xml">&lt;view catchtap=&quot;onPostTap&quot; data-postId='{{item.postId}}'&gt;
	&lt;!-- template--&gt;
	&lt;template is=&quot;postItem&quot; data=&quot;{{...item}}&quot;/&gt;
&lt;/view&gt;
</code></pre>
<p>一般传递参数会与事件绑定，在脚本文件js中绑定的function方法里，获取参数是靠event来获取的。</p>
<pre><code class="language-xml">onPostTap: function(event){
    var postId = event.currentTarget.dataset.postid;
    wx.navigateTo({
      url: 'post-detail/post-detail',
    })
}
</code></pre>
<p>其中获取值是在  event.currentTarget.dataset里面，里面的参数名为xml中定义的data-后面的值。后面的值不管是否带有短横线拼接，最后都会省略调横线，拼成一个变量名，注意大写字母会变成小写。如：<br>
data-postName-Id,传递过去在event.currentTarget.dataset里面会成为“postnameid”。</p>
<p>2、脚本文件js中传值直接在url后拼接参数，如下：</p>
<pre><code class="language-javascript">onPostTap: function(event){
    var postId = event.currentTarget.dataset.postid;
    wx.navigateTo({
      url: 'post-detail/post-detail?id=' + postId,
    })
}
</code></pre>
<p>跨页面js接收的话，如果是onload方法中，直接就用options获取即可，如获取id：</p>
<pre><code class="language-javascript">onLoad: function (options) {
    var postId = options.id
    var postData = postsData.postList[postId]
},
</code></pre>
<p>3、小程序中可以设置缓存，分为同步和异步缓存，api方法共有8个：</p>
<pre><code class="language-javascript">存入缓存
wx.setStorageSync('key', &quot;迈克尔杰克逊&quot;)
wx.setStorage({
	key: '',
	data: '',
})
获取缓存：
wx.getStorage(key)
wx.getStorageSync(key)

移除单个缓存：
wx.removeStorage({
	key: '',
	success: function(res) {},
})
wx.removeStorageSync(key)

移除所有缓存：
wx.clearStorage()
wx.clearStorageSync()
</code></pre>
<p>小程序的缓存即使是关闭程序也存在的，可以再调试选项中的storage中看到，上限是10M。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux下终端常用命令和vi命令修改文件及保存的使用方法]]></title>
        <id>https://skytotwo.github.io//post/linux-vi</id>
        <link href="https://skytotwo.github.io//post/linux-vi">
        </link>
        <updated>2019-08-12T08:51:48.000Z</updated>
        <summary type="html"><![CDATA[<p>这次分享的还是linux下的常用命令，以及在linux下使用vi操作，修改文件等具体方法，很多人第一次接触vi命令，会有点懵，但熟练后会发现其实很简单。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这次分享的还是linux下的常用命令，以及在linux下使用vi操作，修改文件等具体方法，很多人第一次接触vi命令，会有点懵，但熟练后会发现其实很简单。</p>
<!-- more -->
<p>首先介绍一下Ubuntu下各个目录的一般作用：</p>
<pre><code class="language-shell">/ 
这就是根目录，一台电脑有且只有一个根目录，所有的文件都是从这里开始的。举个例子：当你在终端里输入“/home”，你其实是在告诉电脑，先从/（根目录）开始，再进入到home目录。
/root 
系统管理员（root user）的目录。至于系统管理员的权限有多大我这里就不在废话了。因此，请小心使用root帐号。
/boot 
系统启动文件，所有与系统启动有关的文件都保存在这里 。
/bin
这里是存放系统的程序。
/etc 
主要存放了系统配置方面的文件。
/dev 
这里主要存放与设备（包括外设）有关的文件（unix和linux系统均把设备当成文件）。想连线打印机吗？系统就是从这个目录开始工作的。另外还有一些包括磁盘驱动、USB驱动等都放在这个目录。
/home 
这里主要存放你的个人数据。具体每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。每个用户都有自己的用户目录，位置为：/home/用户名。当然，root用户除外。
/tmp 
这是临时目录。对于某些程序来说，有些文件被用了一次两次之后，就不会再被用到，像这样的文件就放在这里。因此，千万不要把重要的数据放在这里哦。
/usr 
在这个目录下，你可以找到那些不适合放在/bin或/etc目录下的额外的工具。比如像游戏阿，一些打印工具等等。/usr目录包含了许多子目录： /usr/bin目录用于存放程序；/usr/share用于存放一些共享的数据，比如音乐文件或者图标等等；/usr/lib目录用于存放那些不能直接 运行的，但却是许多程序运行所必需的一些函数库文件。你的软件包管理器会自动帮你管理好/usr目录的。
/opt 
这里主要存放一些可选的程序。如你想尝试最新的firefox测试版吗？那就装到/opt目录下吧，这样，当你尝试完，想删掉firefox的时候，你就 可以直接删除它，而不影响系统其他任何设置。安装到/opt目录下的程序，它所有的数据、库文件等等都是放在同个目录下面。
usr/local 
这里主要存放那些手动安装的软件，即不是通过“新立得”或apt-get安装的软件。它和/usr目录具有相类似的目录结构。让软件包管理器来管理/usr目录，而把自定义的脚本（scripts）放到/usr/local目录下面。 
/media 
这个目录是用来挂载那些usb接口的移动硬盘（包括U盘）、CD/DVD驱动器等等。
</code></pre>
<h4 id="一-linux下终端常用命令">一、linux下终端常用命令</h4>
<p>ubuntu终端常用命令<br>
# ctrl + l - 清屏<br>
# ctrl + c - 终止命令<br>
# ctrl + d - 退出 shell,好像也可以表示EOF<br>
# ctrl + z - 将当前进程置于后台，fg还原。<br>
# ctrl + r - 从命令历史中找<br>
# ctrl + a - 光标移到行首<br>
# ctrl + e - 光标移到行尾<br>
# ctrl + u - 清除光标到行首的字符<br>
# ctrl + w - 清除光标之前一个单词<br>
# ctrl + k - 清除光标到行尾的字符<br>
# ctrl + t - 交换光标前两个字符<br>
# ctrl + y - 粘贴前一ctrl+u类命令删除的字符<br>
# ctrl + p - 上一条命令<br>
# ctrl + n - 下一条命令<br>
# ctrl + v - 输入控制字符 如ctrl+v ,会输入^M<br>
# ctrl + f - 光标后移一个字符<br>
# ctrl + b - 光标前移一个字符<br>
# ctrl + h - 删除光标前一个字符<br>
# N++f - 光标后移N个单词，N为1时可省略<br>
# N++b - 光标前移N个单词，N为1时可省略<br>
# ctrl + s - 挂起当前shell<br>
# ctrl + q - 重新启用<br>
+d 从光标开始处删除到行尾。挂起的shell<br>
# !! - 上一条命令<br>
# !-n - 倒数第N条历史命令<br>
# !-n:p - 打印上一条命令（不执行）<br>
# !?string?- 最新一条含有&quot;string&quot;的命令 # !-n:gs/str1/str2/ - 将倒数第N条命令的str1替换为str2,并执行（若不加g,则仅替换第一个）</p>
<h4 id="二-vi命令修改文件及保存的使用方法">二、vi命令修改文件及保存的使用方法</h4>
<p>vi编辑器是所有Unix及Linux系统下标准的编辑器，介绍一下它的用法和一小部分指令。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，因此您可以在其他任何介绍vi的地方进一步了解它。Vi也是Linux中最基本的文本编辑器，学会它后，您将在Linux的世界里畅行无阻。<br>
在所有命令执行前，先按ESC<br>
<strong>1 vi的基本概念</strong><br>
　　<strong>基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode），各模式的功能区分如下：</strong></p>
<ol>
<li>命令行模式（command mode）<br>
　　控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。</li>
<li>插入模式（Insert mode）<br>
　　只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。</li>
<li>底行模式（last line mode）<br>
　　将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。<br>
不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式（command mode）。<br>
<strong>2 vi的基本操作</strong></li>
</ol>
<pre><code class="language-shell">a) 进入vi
   　在系统提示符号输入vi及文件名称后，就进入vi全屏幕编辑画面：
　$ vi myfile
　　不过有一点要特别注意，就是您进入vi之后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。初次使用vi的人都会想先用上下左右键移动光标，结果电脑一直哔哔叫，把自己气个半死，所以进入vi后，先不要乱动，转换到「插入模式（Insert mode）」再说吧！
b) 切换至插入模式（Insert mode）编辑文件
　　在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。
c) Insert 的切换
　　您目前处于「插入模式（Insert mode）」，您就只能一直输入文字，如果您发现输错了字！想用光标键往回移动，将该字删除，就要先按一下「ESC」键转到「命令行模式（command mode）」再删除文字。
d) 退出vi及保存文件
　　在「命令行模式（command mode）」下，按一下「：」冒号键进入「Last line mode」，例如：
: w filename （输入 「w filename」将文章以指定的文件名filename保存）
: wq (输入「wq」，存盘并退出vi)
: q! (输入q!， 不存盘强制退出vi)
</code></pre>
<p><strong>3 命令行模式（command mode）功能键</strong><br>
1）. 插入模式<br>
按「i」切换进入插入模式「insert mode」，按&quot;i&quot;进入插入模式后是从光标当前位置开始输入文件；<br>
　　按「a」进入插入模式后，是从目前光标所在位置的下一个位置开始输入文字；<br>
　　按「o」进入插入模式后，是插入新的一行，从行首开始输入文字。<br>
2）. 从插入模式切换为命令行模式<br>
按「ESC」键。<br>
3）. 移动光标<br>
　　vi可以直接用键盘上的光标来上下左右移动，但正规的vi是用小写英文字母「h」、「j」、「k」、「l」，分别控制光标左、下、上、右移一格。<br>
　　按「ctrl」+「b」：屏幕往&quot;后&quot;移动一页。<br>
　　按「ctrl」+「f」：屏幕往&quot;前&quot;移动一页。<br>
　　按「ctrl」+「u」：屏幕往&quot;后&quot;移动半页。<br>
　　按「ctrl」+「d」：屏幕往&quot;前&quot;移动半页。<br>
　　按数字「0」：移到文章的开头。<br>
　　按「G」：移动到文章的最后。<br>
　　按「$」：移动到光标所在行的&quot;行尾&quot;。<br>
　　按「^」：移动到光标所在行的&quot;行首&quot;<br>
　　按「w」：光标跳到下个字的开头<br>
　　按「e」：光标跳到下个字的字尾<br>
　　按「b」：光标回到上个字的开头<br>
　　按「#l」：光标移到该行的第#个位置，如：5l,56l。<br>
4）. 删除文字<br>
　　「x」：每按一次，删除光标所在位置的&quot;后面&quot;一个字符。<br>
　　「#x」：例如，「6x」表示删除光标所在位置的&quot;后面&quot;6个字符。<br>
　　「X」：大写的X，每按一次，删除光标所在位置的&quot;前面&quot;一个字符。<br>
　　「#X」：例如，「20X」表示删除光标所在位置的&quot;前面&quot;20个字符。<br>
　　「dd」：删除光标所在行。<br>
　　「#dd」：从光标所在行开始删除#行</p>
<p>5）. 复制<br>
　　「yw」：将光标所在之处到字尾的字符复制到缓冲区中。<br>
　　「#yw」：复制#个字到缓冲区<br>
　　「yy」：复制光标所在行到缓冲区。<br>
　　「#yy」：例如，「6yy」表示拷贝从光标所在的该行&quot;往下数&quot;6行文字。<br>
　　「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与&quot;y&quot;有关的复制命令都必须与&quot;p&quot;配合才能完成复制与粘贴功能。<br>
6）. 替换<br>
　　「r」：替换光标所在处的字符。<br>
　　「R」：替换光标所到之处的字符，直到按下「ESC」键为止。<br>
7）. 回复上一次操作<br>
　　「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次&quot;u&quot;可以执行多次回复。<br>
8）. 更改<br>
　　「cw」：更改光标所在处的字到字尾处<br>
　　「c#w」：例如，「c3w」表示更改3个字<br>
9）. 跳至指定的行<br>
　　「ctrl」+「g」列出光标所在行的行号。<br>
　　「#G」：例如，「15G」，表示移动光标至文章的第15行行首。</p>
<p><strong>4 Last line mode下命令简介</strong><br>
　　在使用「last line mode」之前，请记住先按「ESC」键确定您已经处于「command mode」下后，再按「：」冒号即可进入「last line mode」。<br>
A) 列出行号<br>
　「set nu」：输入「set nu」后，会在文件中的每一行前面列出行号。<br>
B) 跳到文件中的某一行<br>
　「#」：「#」号表示一个数字，在冒号后输入一个数字，再按回车键就会跳到该行了，如输入数字15，再回车，就会跳到文章的第15行。<br>
C) 查找字符<br>
　「/关键字」：先按「/」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往后寻找到您要的关键字为止。<br>
　「?关键字」：先按「?」键，再输入您想寻找的字符，如果第一次找的关键字不是您想要的，可以一直按「n」会往前寻找到您要的关键字为止。<br>
D) 保存文件<br>
　「w」：在冒号输入字母「w」就可以将文件保存起来。<br>
E) 离开vi<br>
　「q」：按「q」就是退出，如果无法离开vi，可以在「q」后跟一个「!」强制离开vi。<br>
　「wq」：一般建议离开时，搭配「w」一起使用，这样在退出的时候还可以保存文件。</p>
<p><strong>5 vi命令列表</strong></p>
<pre><code class="language-shell">1、下表列出命令模式下的一些键的功能：
h
左移光标一个字符
l
右移光标一个字符
k
光标上移一行
j
光标下移一行
^
光标移动至行首
0
数字&quot;0&quot;，光标移至文章的开头
G
光标移至文章的最后
$
光标移动至行尾
Ctrl+f
向前翻屏
Ctrl+b
向后翻屏
Ctrl+d
向前翻半屏
Ctrl+u
向后翻半屏
i
在光标位置前插入字符
a
在光标所在位置的后一个字符开始增加
o
插入新的一行，从行首开始输入
ESC
从输入状态退至命令状态
x
删除光标后面的字符
#x
删除光标后的＃个字符
X
(大写X)，删除光标前面的字符
#X
删除光标前面的#个字符
dd
删除光标所在的行
#dd
删除从光标所在行数的#行
yw
复制光标所在位置的一个字
#yw
复制光标所在位置的#个字
yy
复制光标所在位置的一行
#yy
复制从光标所在行数的#行
p
粘贴
u
取消操作
cw
更改光标所在位置的一个字
#cw
更改光标所在位置的#个字
</code></pre>
<p>2、下表列出行命令模式下的一些指令</p>
<pre><code class="language-shell">w filename
储存正在编辑的文件为filename
wq filename
储存正在编辑的文件为filename，并退出vi
q!
放弃所有修改，退出vi
set nu
显示行号
/或?
查找，在/后输入要查找的内容
n
与/或?一起使用，如果查找的内容不是想要找的关键字，按n或向后（与/联用）或向前（与?联用）继续查找，直到找到为止。
</code></pre>
<hr>
<p>对于第一次用vi，有几点注意要提醒一下：<br>
1、用vi打开文件后，是处于「命令行模式（command mode）」，您要切换到「插入模式（Insert mode）」才能够输入文字。切换方法：在「命令行模式（command mode）」下按一下字母「i」就可以进入「插入模式（Insert mode）」，这时候你就可以开始输入文字了。<br>
2、编辑好后，需从插入模式切换为命令行模式才能对文件进行保存，切换方法：按「ESC」键。<br>
3、保存并退出文件：在命令模式下输入:wq即可！（别忘了wq前面的:）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac下android_sdk配置环境变量]]></title>
        <id>https://skytotwo.github.io//post/mac-android-env</id>
        <link href="https://skytotwo.github.io//post/mac-android-env">
        </link>
        <updated>2019-08-12T08:44:49.000Z</updated>
        <summary type="html"><![CDATA[<p>之前用mac做过安卓开发，然后安卓sdk的配置环境变量上遇到过坑，这里记录一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前用mac做过安卓开发，然后安卓sdk的配置环境变量上遇到过坑，这里记录一下。</p>
<!-- more -->
<p>1、启动Terminal终端工具<br>
2、输入cd ~/ 进入当前用户的home目录<br>
3、创建：touch .bash_profile<br>
4、打开并编辑：open .bash_profile<br>
5、在文件中写入以下内容：export PATH=${PATH}:这里是platform-tools 的绝对路径，以我的为例：/Volumes/workplace/sdk/platform-tools/<br>
6、执行如下命令：source .bash_profile<br>
7、验证：输入adb回车。如果未显示command not found，说明此命令有效，环境变量设置完成。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Linux常用命令简记]]></title>
        <id>https://skytotwo.github.io//post/linux-command</id>
        <link href="https://skytotwo.github.io//post/linux-command">
        </link>
        <updated>2019-08-12T08:38:43.000Z</updated>
        <summary type="html"><![CDATA[<p>linux下的命令繁多，熟悉相关命令对工作可以提高便利性，下面列举了一些常用的命令。</p>
]]></summary>
        <content type="html"><![CDATA[<p>linux下的命令繁多，熟悉相关命令对工作可以提高便利性，下面列举了一些常用的命令。</p>
<!-- more -->
<p>ls: 查看文件夹下文件和文件夹列表</p>
<p>ls -lah</p>
<p>-l: 列表形式显示</p>
<p>-a: 查看所有目录，包括隐藏目录</p>
<p>-h: 以易读的方式显示文件大小</p>
<p>-s: 显示文件占用的data block空间大小</p>
<p>-S: 按文件大小降序排列</p>
<p>-t: 按文件m/a/ctime降序排列</p>
<p>-r: 逆序排列</p>
<p>-R: 递归遍历</p>
<p>cp: 复制文件或目录</p>
<p>cp -ai ~/test ~/Downloads/</p>
<p>-a: 相当与 -pdr，重要参数</p>
<p>-p: 连同文件属性一起复制过去(备份时常用)</p>
<p>-d: 如果源文件为链接文件的属性，则复制后的文件为链接文件，而不是真实文件本身</p>
<p>-r: 递归的复制所有文件</p>
<p>-i: 当遇到已存在文件时，询问用户</p>
<p>top: 查看系统进程资源占用情况</p>
<p>top -d 2 -p 1234 : 将资源使用情况更新时间设为2秒，查看的进程为pid 1234</p>
<p>top中的PRI和NI是进程的优先级，其中Priority(new)=Priority(Old)+Nice, PRI越小表示进程优先级越高，用户仅可以调整NI值，所以将NI调整为负值可以提高进程优先级，</p>
<p>NI的调整范围是 -20～19</p>
<p>在top程序界面内快捷键</p>
<p>shift + p : 按cpu使用率排序</p>
<p>shift + M : 按内存使用率排序</p>
<p>r : 调整process的NICE值</p>
<p>q : 退出top</p>
<p>使用 nice 和 renice 命令调整进程优先级</p>
<p>nice -n 10 vim &amp; : 运行一个vim,并将他的nice值设置为10</p>
<p>renice -10 1234 : 将pid为1234的进程的nice值调整为-10</p>
<p>ps: 显示详细进程信息</p>
<p>常用格式: ps aux</p>
<p>a 显示所有用户进程,包括其他用户</p>
<p>u 以用户为主的格式显示进程状况</p>
<p>x 显示不受终端控制的进程</p>
<p>ps -l : 以特定格式现实当前用户shell进程</p>
<p>ps axjf : 以工作格式现实所有用户进程的树状图</p>
<p>ps -ef : 使用全格式显示所有进程</p>
<p>-e: 显示所有进程</p>
<p>-f: 使用全格式</p>
<p>mv: 移动或重命名文件或文件夹</p>
<p>常用格式: mv -f test1/ test2/</p>
<p>-f 强制模式,在移动前不询问</p>
<p>test1/ 待移动文件夹</p>
<p>test2/ 移动到的目标文件夹</p>
<p>常用格式: mv file1 file2 dir1/</p>
<p>将file1 file2 移动到 dir1</p>
<p>find: 查找文件或文件夹</p>
<p>常用格式: find / -type f -iname '*test'</p>
<p>/ 查找的目录,此处为更根目录</p>
<p>-type f,d,l 类型：普通文件，目录，链接文件</p>
<p>-iname 查找文件名,并忽略大小写</p>
<p>'*test' 要查找的文件名,此处是以test结尾的文件名</p>
<p>-mtime n/+n/-n : 指定最后修改时间在 n天前24小时内 / (n+1)天前无限小时 / n天至今 的文件 find ~/ -mtime +4 查找5天前的文件</p>
<p>-newer file: 查找mtime比 file 新的文件 find ~/ -newer test</p>
<p>df: 查看磁盘使用情况</p>
<p>常用格式: df -aTh</p>
<p>-a 显示所有文件系统的磁盘使用情况，包括0块（block）的文件系统，如/proc文件系统</p>
<p>-T 显示磁盘类型,如ext4</p>
<p>-h 根据目前磁盘空间和使用情况 以更易读的方式显示</p>
<p>cat: 显示文件内容,或合并两个文件</p>
<p>常用格式: cat myfile</p>
<p>常用格式: cat -n myfile1 &gt; myfile2</p>
<p>-n 对myfile1数据加上行号</p>
<p>myfile1 需要复制数据的文件</p>
<p>myfile2 复制数据的目标文件,会将myfile2的原数据清空</p>
<p>常用格式: cat -n myfile1 myfile2 &gt; myfile3</p>
<p>myfile1 myfile2 需要合并的文件</p>
<p>myfile3 合并后保存的文件</p>
<p>chmod: 改变文件或文件夹的权限</p>
<p>常用格式: chmod 664 myfile</p>
<p>664 文件权限码,此处为默认新建文件权限,rw-rw-r--</p>
<p>chmod u=rwx g=rwx o=rwx myfile</p>
<p>将myfile的权限改为用户为rwx,用户组为rwx,其他用户为rwx</p>
<p>chgrp: 改变文件或文件夹所属用户组</p>
<p>常用格式: chgrp root myfile</p>
<p>root 修改到的目标用户组</p>
<p>myfile 需要修改的文件名</p>
<p>chown: 改变文件或文件夹所有者</p>
<p>常用格式: chown -R lewis.mygroup filename</p>
<p>-R: 当前目录下的所有文件和文件夹</p>
<p>lewis.mygroup: 将所有者改为mygroup用户组的lewis用户</p>
<p>filename: 需要修改所有者的文件或文件夹名称</p>
<p>grep: 字符串查找,常用于其他命令的结果中的查找</p>
<p>常用格式: ls -l | grep myfile</p>
<p>myfile 需要查找的字符串</p>
<p>ls -l | grep -vi 'test'</p>
<p>查找除了test或TEST之外的内容</p>
<p>wc: 统计文件中的单词书,字节数,行数</p>
<p>常用格式: wc -wml myfile</p>
<p>-w 文件中的单词数</p>
<p>-m 文件中的字符数</p>
<p>-c 文件的字节数</p>
<p>-l 文件的行数</p>
<p>tar: 解压或压缩文件</p>
<p>常用格式: tar -zcv -f ~/Downloads/downloads.tar.gz ~/Downloads</p>
<p>将Downloads的文件压缩到一个叫downloads.tar.gz的文件</p>
<p>-z 使用gzip解压或压缩</p>
<p>-c 建立压缩文件</p>
<p>-v 显示执行过程</p>
<p>-f 需要操作的文件</p>
<p>tar -zvcp -f backup.tar.gz --exclude=/etc/*.sh /etc</p>
<p>备份etc文件夹下除了.sh结尾的所有文件到 backup.tar.gz</p>
<p>-p 压缩时保留文件原有的属性，备份常用</p>
<p>--exclude 不打包的文件</p>
<p>常用格式: tar -xjv -f ./test.tar.bz2 -C ./test/　　#解压文件到指定目录</p>
<p>-x 解压文件</p>
<p>-j 以bzip2解压或压缩</p>
<p>-C 解压到指定目录</p>
<p>常用格式: tar -zv -f ./test.tar.gz　　#查看压缩包文件</p>
<p>-t: 查看压缩包文件</p>
<p>ctrl+z: 挂起当前任务</p>
<p>jobs: 查看后台任务</p>
<p>fg: 将一个后台任务启动后调至前台执行</p>
<p>常用格式: fg %1</p>
<p>%1: 任务号,可以从jobs命令查看得到</p>
<p>bg: 将一个后台任务启动后调至后台执行</p>
<p>常用格式: bg %1</p>
<p>%1: 任务号,可以从jobs命令查看得到</p>
<p>mount: 挂载一个设备</p>
<p>mount -a</p>
<p>读取/etc/fstab文件，将未挂在的设备全都挂载上去</p>
<p>mount -n -o remount,rw /</p>
<p>-n ： 不将挂在记录写入/etc/mtab</p>
<p>在单用户模式时，将根目录重新挂载变成读写模式</p>
<p>mount -o iocharset=gb2312,ro -t ntfs /dev/sda5 /mnt/windrived</p>
<p>-o： 额外参数， iocharset: 设置编码， ro 只读</p>
<p>-t ntfs: 设置要挂载设备的文件系统，有super block信息的磁盘分区可以不需要次参数</p>
<p>/dev/sda5: 要挂载的设备路径</p>
<p>/mnt/windrived: 要挂在的目标挂载点</p>
<p>mount -o loop /home/alexis/game.iso /mnt/iso</p>
<p>挂载特殊设备，如镜像文件，文件系统文件</p>
<p>umount: 卸载一个设备</p>
<p>常用格式: umount -l /mnt/windrived</p>
<p>-l: lazy umount,等到设备空闲的时候自动卸载之</p>
<p>此外umount命令也可以使用设备名来卸载设备，例如 umount -f /dev/sda3</p>
<p>kill: 杀掉一个进程</p>
<p>常用格式: kill -9 1234</p>
<p>-9: 强制杀掉他,也可以用-SIGKILL</p>
<p>1234: 进程pid,可以有ps aux查看获得</p>
<p>进程信号：</p>
<p>1 ： 重启进程</p>
<p>9 ： 强制结束进程</p>
<p>15 ： 正常结束进程</p>
<p>17 ： 挂起进程，相当与ctrl+z</p>
<p>kill -l : 列出所有可用的进程信号量</p>
<p>killall: 杀掉同名进程</p>
<p>常用格式: killall -KILL chromium</p>
<p>-KILL: 强制终止,这里加进程信号量,和kill命令的一样</p>
<p>chromium: 要杀掉的同名进程名</p>
<p>tail: 显示文件尾部内容</p>
<p>常用格式: tail -1 /etc/passwd, tail -f /etc/passwd</p>
<p>-1: 显示最后一行内容</p>
<p>-f: 显示最后十行内容,并不断更新</p>
<p>useradd: 添加用户账号</p>
<p>常用格式: useradd testuser -u 1234 -g root -d /home/testuser -s /bin/bash</p>
<p>-u: 设置用户uid</p>
<p>-g: 设置用户组</p>
<p>-d: 设置用户根目录</p>
<p>-s: 设置用户启动shell</p>
<p>简记: 此命令会在/etc/passwd /etc/shadow中添加两条记录</p>
<p>userdel: 删除用户账号</p>
<p>常用格式: userdel -r testuser</p>
<p>-r: 删除用户相关,如用户根目录,但如果用户根目录是由其他用户创建的则不会删除</p>
<p>usermod: 修改用户属性</p>
<p>常用格式: usermod -L testuser , usermod -U testuser</p>
<p>-L: lock,禁用用户</p>
<p>-U: unlock,启用用户</p>
<p>常用格式: usermod -g mygroup testuser</p>
<p>-g: 修改用户组, 将 testuser 用户组改为mygroup</p>
<p>groupadd: 添加用户</p>
<p>常用格式: groupadd mygroup -g 1234</p>
<p>-g: 设置用户组uid</p>
<p>groupdel: 删除用户组</p>
<p>常用格式: groupdel mygroup</p>
<p>ln: 建立文件链接</p>
<p>常用格式: ln file fileln, ln -s file filesln</p>
<p>-s: 建立软链接,不加上 -s 则建立硬链接</p>
<p>注意建立链接请用绝对路径，不然链接文件会出现错误</p>
<p>seq: 生成一个序列</p>
<p>常用格式: seq -w 1 100</p>
<p>-w: 等宽序列,生成 001 002 003 ... 099 100</p>
<p>常用格式: seq -f &quot;str%03g&quot; 1 100</p>
<p>-f &quot;str%03g&quot;: 指定生成格式,此处用str拼接 1~100的序列, 1~100为3位等宽数字,不够的用0补齐,不写0则用空格补齐,如图</p>
<p>seq -f '%0.f' 10000000000 10000000000</p>
<p>seq在生成大数字会默认使用科学计数法, 这个格式可以避免使用科学计数法</p>
<p>ifconfig: 网络设备设置</p>
<p>常用格式: ifconfig -a</p>
<p>-a: 显示所有网络设备,包括未启用的网络设备</p>
<p>常用格式: ifconfig eth0 up</p>
<p>eth0 up: 激活第一块网卡</p>
<p>iwconfig: 无线网络设备设置</p>
<p>chkconfig: 管理linux daemon（包括 stand alone 和 super daemon管理的服务）</p>
<p>常用格式: chkconfig --level 0123456 network on</p>
<p>--level 0123456 network on: 在系统级别为0123456时启动network服务</p>
<p>chkconfig --add testdaemon : 加入自定义的服务，testdaemon位于/etc/init.d</p>
<p>chkconfig --del testdaemon : 删除自定义的服务</p>
<p>lspci: 查看所有pci设备</p>
<p>lsusb: 查看所有usb设备</p>
<p>scp: 远程复制命令</p>
<p>常用格式: scp -P 1234 /root/test root@192.168.3.3:/var/www/io/</p>
<p>-P 1234: 目标主机端口号</p>
<p>root@192.168.3.3:/var/www/io/: 将test文件复制到192.168.3.3的/var/www/io文件夹,使用root账号登录</p>
<p>passwd: 修改密码</p>
<p>netstat: 查看端口状态</p>
<p>常用格式: netstat -anptu</p>
<p>a: 显示所有连接的socket</p>
<p>n: 用IP代替域名</p>
<p>p: 显示连接的程序以及PID</p>
<p>t: 显示tcp连接</p>
<p>u：显示udp连接</p>
<p>du: 查看文件夹和文件大小</p>
<p>常用格式: du -sh ./*</p>
<p>./*： 统计当前文件夹下所有文件夹容量情况</p>
<p>h: 以用户友好的方式显示文件大小</p>
<p>s: 只显示顶层文件夹的容量，不显示子文件夹的容量</p>
<p>统计结果递归包括子目录下所有文件大小总和</p>
<p>du -Ssh ./</p>
<p>统计当前目录所有文件大小，统计出来的总和不包括子目录内的文件</p>
<p>make : 编译源码</p>
<p>make mrproper : 清除编译过程产生的中间文件以及配置文件</p>
<p>make clean : 仅仅清除编译过程产生的中间文件</p>
<p>fdisk: 磁盘管理工具</p>
<p>fdisk -l ： 列出磁盘分区信息</p>
<p>fdisk /dev/sda # 注意没有 sda1 或者 sda2 这个数字</p>
<p>对 /dev/sda 这块磁盘进行管理，可以增加分区，删除分区等</p>
<p>使用fdisk添加或删除分区后，执行 partprobe 让内核更新系统分区表</p>
<p>mkfs: 分区格式化，在使用fdisk分区以后可以是用此命令格式化分区</p>
<p>mkfs -t ext4 /dev/sda8</p>
<p>-t: 指定分区格式，此处将sda8分区格式化成ext4分区</p>
<p>unzip: 解压zip压缩包</p>
<p>unzip test.zip -d ./test　　#将test.zip的文件解压到test文件夹</p>
<p>unzip -v test.zip　　#查看压缩包文件</p>
<p>uname: 查看系统信息</p>
<p>uname -a : 查看所有系统信息</p>
<p>tracerout: 路由跟踪</p>
<p>traceroute -T --sport=3324 -p 80 www.google.com</p>
<p>-T : 使用 tcp 的方式来 trace. 除了 -T 还可以用 -I 表示 ICMP, -U 表示 UDP, Linux 下默认是 UDP</p>
<p>--sport : 指定源端口</p>
<p>-p : 指定目标端口</p>
<p>nslookup: 域名信息查看</p>
<p>nslookup www.google.com</p>
<p>init: 切换系统 level</p>
<p>init 0/3/5/6</p>
<p>0: 关机</p>
<p>3: 命令行模式</p>
<p>5: 图形界面模式</p>
<p>6: 重启</p>
<p>sync: 将内存中未保存数据同步到硬盘</p>
<p>shutdown: 关机/开机等</p>
<p>shutdown -h now &quot;alexis shutdown the server&quot;: 立即关机,并发送通知消息&quot;alexis shutdown the server&quot;给其他用户</p>
<p>shutdown -r 20:30 : 在20：30分重启</p>
<p>shutdown -k 10 &quot;i will shutdown the server in 10 minutes&quot; : 不是真正的关机，只是发送消息给其他用户</p>
<p>ctrl+d: 相当与在shell中输入exit</p>
<p>忘记root密码后的处理方法</p>
<p>1.进入grub菜单后按e键，进入编辑模式</p>
<p>2.在kernel那行的最后空格，并键入 single</p>
<p>3.F10启动</p>
<p>4.输入新密码重启</p>
<p>last: 列出登入系统的用户相关信息</p>
<p>last -xnR 10 -f /var/www/wtmp -i 127.0.0.1 -id alexis</p>
<p>-x: 显示登入登出信息</p>
<p>-n: 显示的行数</p>
<p>-R: 去掉hostname栏位</p>
<p>-f: 指定log文件， /var/log/wtmp为linux记录所有用户登入相关信息的日志文件，默认用的就是这个，可以不加 -f，而/var/www/btmp则更为详细，记录了远程登录信息，如SSH</p>
<p>-i: 指定查询的id</p>
<p>-id: 指定查询的用户名</p>
<p>nl: 显示文件内容并显示行数</p>
<p>od： 以二进制形式显示文件内容</p>
<p>od -t c test</p>
<p>-t: 指定显示类型， a 默认字符， c askii， d 十进制， f 浮点数， o 八进制， x 十六进制</p>
<p>关于文件时间，文件的时间有三个</p>
<p>modification time (mtime): 文件最后修改时间</p>
<p>access time (atime): 文件最后读取时间</p>
<p>status time (ctime): 文件属性最后修改时间， chmod 什么的</p>
<p>默认的ls和ll显示的时间是 modification time，如果要显示atime，ctime，可以添加--time参数</p>
<p>ls -l --time=atime test</p>
<p>显示的就是test文件的最后访问时间</p>
<p>可以用touch来更新文件时间，此命令更新的是mtime和atime，而ctime则无法更改</p>
<p>touch test</p>
<p>可把test文件的m/atime更新为当前时间</p>
<p>touch -d &quot;2 days ago&quot; test</p>
<p>可把test文件的m/atime改为两天前</p>
<p>xargs: 将某命令输出作为另一个命令的参数输入</p>
<p>sudo find /usr/local/test/bin -type f -iname ‘*.sh’ | xargs -i sudo ln -l /usr/local/test/bin/{} /usr/bin/{}</p>
<p>这条命令批量建立软链接，其中 xargs -i 参数表示用 {} 代表管道前的命令的标准输出结果</p>
<p>xargs -I 则是指令管道前的命令的标准输出结果替换符号，例如 xargs -I {} sudo lin -l /test/bin/{} /usr/bin/{}</p>
<p>tar -tz -f test.tar.gz | xargs -i rm -rf {}</p>
<p>这个命令可以用来删除你一不小心散落一地的节操</p>
<p>ls | xargs -i -e'test' file {}</p>
<p>将ls的结果作为file的参数输出，并且在遇到 test 的时候停止</p>
<p>egrep: 正则匹配</p>
<p>find /var/www -type f | egrep -name '*.(c|php)$'</p>
<p>获取所有后缀为.c .php的文件</p>
<p>file: 查看文件类型</p>
<p>locate: 通过数据库文件 /var/lib/mlocate 来查找文件，其速度会比find快很多</p>
<p>由于该数据库文件是定时跟新的，所以查找前可以先更新数据库</p>
<p>updatedb</p>
<p>locate -i -r .*.php$</p>
<p>查找所有以php结尾的文件，忽略大小</p>
<p>whiereis : 命令用来查找path里的位置，例如 whereis ls</p>
<p>which : 用来在path里查找可执行文件的位置，查找出来的东西比whereis少</p>
<p>ldd (library dependency discovery) ： 查找共享库的依赖包</p>
<p>ldd $(which mysqld)</p>
<p>chattr +x/-x: 给文件添加特殊属性</p>
<p>chattr +a test: 让test只能添加内容，不能修改和删除内容</p>
<p>chattr +i test: 让test不能删除，改名，设置软链接，也不能写入，添加数据</p>
<p>chattr -ai test: 去除 ai 属性</p>
<p>lsattr: 列出文件的特殊属性</p>
<p>dumpe2fs: 查看ext文件系统信息</p>
<p>dumpe2fs -h /dev/sda1</p>
<p>-h: 只显示super block的信息，不加则会现实所有 block group的信息</p>
<p>fsck: 文件系统检测修复工具</p>
<p>fsck -CaDf /dev/sda8</p>
<p>-C: 现实进度条</p>
<p>-a: 自动修复问题sector</p>
<p>-D: ext文件系统专有选项，可以对文件系统的目录进行优化</p>
<p>-f: ext文件系统专有选项， 对没有unclean标志的磁盘分区也强制检查</p>
<p>e2label: 修改磁盘分区卷标</p>
<p>e2label /dev/sda7 &quot;Smilodon&quot;</p>
<p>hdparm: 磁盘性能测试</p>
<p>hdparm -tT /dev/sda</p>
<p>-t: 测试实际读取性能</p>
<p>-T: 测试磁盘cache读取性能</p>
<p>生成磁盘分区文件并挂载</p>
<p>dd： 转换和复制文件</p>
<p>dd if=/dev/zero of=/home/alexis/loopdev bs=1M count=512</p>
<p>使用/dev/zero生成一个blocksize为1M，一共512M大小的/home/alexis/loopdev文件</p>
<p>mkfs -t ext4 /home/alexis/loopdev</p>
<p>将loopdev格式化成ext4文件系统</p>
<p>mount -o loop /home/alexis/loopdev /mnt/linux/test</p>
<p>将刚刚生成的那个文件挂载到系统中</p>
<p>生成新的swap空间</p>
<p>dd if=/dev/zero of=/home/alexis/swapdev bs=1M count=128 #生成大文件</p>
<p>mkswap /home/alexis/swapdev #格式化成swap</p>
<p>swapon /home/alexis/swapdev #启动swap</p>
<p>free #查看内存和Swap的使用情况</p>
<p>parted： 分区工具，可以支持2TB以上的空间分区</p>
<p>parted /dev/sda print</p>
<p>打印所有分区状况，打印出来的比fdisk -l要好看哦～</p>
<p>parted /dev/sda mkpart logical ext4 210.2G 270.2G</p>
<p>创建一个逻辑分区，格式是ext4,柱面从210.2G~270.2G,比起fdisk n和mkfs -t来说简单一点。一步到位</p>
<p>parted /dev/sda rm 9</p>
<p>删除 /dev/sda9 分区</p>
<p>操作系统备份组合 dump/restore</p>
<p>dump: 备份文件系统或目录</p>
<p>dump -W #输出/etc/fstab文件里所有挂载设备的备份记录</p>
<p>dump -S /dev/sda2 #预测某个设备不压缩备份需要的空间</p>
<p>dump -u0 -j9 -f loop0.dump.0.bz2 /dev/loop0</p>
<p>这条命令备份/dev/loop0到loop0.dump.0.bz2里</p>
<p>-u 将备份记录写入到文件 /var/lib/dumpdatas, 具体的日志文件因系统而异</p>
<p>-0 备份级别，0～9，0为全量备份，1～9为增量备份，1的增量备份相对与0而呀，2相对与1而言，依次类推</p>
<p>-j 使用bzip2进行压缩，后面的数字 -j9 为压缩等级，从1~9,压缩率依次增加，速度依次减慢</p>
<p>-f 指定要备份文件的文件名</p>
<p>/dev/loop0 要备份的文件系统</p>
<p>restore: 查看或恢复dump出来的备份文件</p>
<p>restore -t -f loop0.dump</p>
<p>查看loop0.dump里的文件信息</p>
<p>-t 查看备份文件具体信息</p>
<p>-f 指定要操作的文件</p>
<p>restore -C -f loop0.dump</p>
<p>-C 将备份文件与当前挂载的文件系统比较</p>
<p>restore -r -f loop0.dump</p>
<p>将loop0.dump还原到当前目录的文件系统，如果是增量备份的还原，则需要继续执行 restore -r -f loop0.dump.1 . 2. 3 等等</p>
<p>使用dd备份MBR或整个磁盘备份</p>
<p>dd if=/dev/sda of=mbr.dd bs=512 count=1</p>
<p>备份sda的前512Bytes，实际上就是备份了MBR和Partition Table</p>
<p>dd if=/dev/sda1 of=sda1.dd.wholedisk</p>
<p>备份整个sda1</p>
<p>mkisofs: 做镜像</p>
<p>cdrecord: 通过镜像文件刻录光盘</p>
<p>cpio: 高级备份工具，参数巨多，暂时搁置</p>
<p>type: 查看命令的类型信息</p>
<p>type cd --&gt; cd is a shell builtin</p>
<p>表示 cd 是bash命令的内置命令</p>
<p>type ll --&gt; ll is aliased to `ls -alF'</p>
<p>表示ll是ls的别名</p>
<p>type mysql --&gt; mysql is /usr/bin/mysql</p>
<p>表示mysql是外部命令，并显示其来源</p>
<p>umask: 显示创建文件或文件夹的时候的默认权限</p>
<p>umask --&gt; 0002</p>
<p>表示创建该文件时，文件默认权限是 -rw-rw-rw- 减去 --------w- = -rw-rw-r--</p>
<p>创建目录时，目录的默认权限是 -rwxrwxrwx 减去 --------w- = -rwxrwxr-x</p>
<p>Linux文件特殊权限</p>
<p>SUID：</p>
<p>让用户在执行文件时暂时获取文件所有者的权限，例如sudo。该属性只能用于二进制可执行程序，其显示如下</p>
<p>-rwsr-xr-x 1 root root 69708 Jun 1 11:53 /usr/bin/sudo</p>
<p>SGID：</p>
<p>对二进制可执行文件而言，让用户在执行程序时暂时获取程序用户组的权限，显示如下<br>
-rwx--s--x 1 root root 24 Oct 14 00:05 /usr/bin/locate</p>
<p>对于目录而言, 用户在次目录下的有效用户组将会变为该目录的用户组<br>
SBIT：</p>
<p>该属性仅对目录有效，用户在该目录下创建的文件和目录，仅有root和该用户才能删除</p>
<p>drwxrwxrwt 12 root root 4096 Nov 20 11:11 /tmp</p>
<p>设置这三个属性很简单 chmod 7755</p>
<p>其中第一个7是特殊属性 ， 4: SUID, 2: SGID, 1： SBIT</p>
<p>route : 路由管理命令</p>
<p>route add -net 192.168.0 netmask 255.255.255.0 gw 10.8.1.1</p>
<p>添加路由</p>
<p>-net : 表示这是一个网域</p>
<p>-host : 表示这是一个具体主机</p>
<p>netmask， gw： 子网掩码， 网关</p>
<p>route -n</p>
<p>查看路由状态， -n 不显示主机名称，直接显示ip</p>
<p>route del -net 192.168.2.0</p>
<p>删除路由</p>
<p>alias: 设置命令别名</p>
<p>alias lm='ls -l | more'</p>
<p>以后执行lm命令的时候就相当与执行了 ls -l | more</p>
<p>unalias: 取消别名</p>
<p>unalias lm</p>
<p>history: 查看历史命令</p>
<p>linux bash执行的历史命令都会存放在 ~/.bash_history，每次注销bash的时候会将内存中的history内容写入文件，history命令查看的是内存中的历史命令</p>
<p>history 10: 查看最后的10条历史命令</p>
<p>history -w: 强制将内存中的历史写入~/.bash_history 文件</p>
<p>!number: 执行第 number 条历史命令</p>
<p>!command： 执行 history中以 command 开头的最近的那条历史命令</p>
<p>!!: 执行上一条历史命令</p>
<p>cut： 切分输出内容</p>
<p>cut infile -d ':' -f 2</p>
<p>-d: 切分的分割符</p>
<p>-f: 要选取的切分后的列号</p>
<p>cut -c 5-12</p>
<p>获取每行的第5至12个字符</p>
<p>tr： 删除或替换信息内容</p>
<p>cat test | tr -d ':'</p>
<p>删除 ： 符号</p>
<p>cat test | tr '[a-z]' '[A-Z]'</p>
<p>将小写字母替换成大写字母</p>
<p>col： 转换tab和其他特殊字符</p>
<p>cat test | col -x</p>
<p>将tab转换为对等的空格</p>
<p>cat test | col -b</p>
<p>所有反斜杠 \ 只保留反斜杠最后连接的那个字符</p>
<p>join： 合并两个文件中含有相同数据的行</p>
<p>join -t ':' -1 4 ~/test -2 3 ~/test2</p>
<p>用分隔符 : 切分每一行的数据，若第一个文件的第四列和第二个文件的第三列相同，则合并两行，默认是比较每行的第一列，如果相同则合并</p>
<p>paste： 合并两个文件的内容，以tab隔开</p>
<p>paste file1 file2</p>
<p>expand: 将tab替换成空格</p>
<p>expand file -t 10</p>
<p>将file的tab编程10个空格</p>
<p>split： 文件大小切割</p>
<p>split -b 300k test TMP</p>
<p>将test文件按照300k每个的大小切分，切分出来的文件前缀是 TMP， 他们是 TMPaa TMPab TMPac ...</p>
<p>split -l 10 test TMP</p>
<p>将test文件按照每10行切分一次切分</p>
<p>time： 计算命令执行时间</p>
<p>time ls</p>
<p>sort: 对输出进行排序</p>
<p>cat ~/test | sort</p>
<p>cat ~/test | sort -t ':' -k 3</p>
<p>用：号切割，并按照第3列排序</p>
<p>last | cut -d ' ' -f 1 | sort</p>
<p>uniq: 将连续重复的数据只显示一行</p>
<p>last | cut -d ' ' -f 1 | sort | uniq -c</p>
<p>统计所有重复的行的条数</p>
<p>tee: 双向重定向</p>
<p>last | tee last.list</p>
<p>将last的输出同时输出到stdout也重定向到last.list</p>
<p>last | tee -a last.list</p>
<p>-a: append，即追加到文件尾</p>
<p>bash判断命令test 与 []</p>
<p>test用于判断变量属性，它的结果不会输出，但是通过返回信号表示，例如运行完以后可以通过<span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 10: ?来查看结果,或者&amp;̲&amp; || 来控制后续命令的执行…'>?来查看结果,或者&amp;&amp; || 来控制后续命令的执行
复制代码 alexis@Smilodon:~/scripts</span> ls sh01.sh sh02.sh sh03.sh alexis@Smilodon:~/scripts$ test -e alexis@Smilodon:~/scripts$ echo <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>?</mo><mn>0</mn><mi>a</mi><mi>l</mi><mi>e</mi><mi>x</mi><mi>i</mi><mi>s</mi><mi mathvariant="normal">@</mi><mi>S</mi><mi>m</mi><mi>i</mi><mi>l</mi><mi>o</mi><mi>d</mi><mi>o</mi><mi>n</mi><mo>:</mo><mtext> </mtext><mi mathvariant="normal">/</mi><mi>s</mi><mi>c</mi><mi>r</mi><mi>i</mi><mi>p</mi><mi>t</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">? 0 alexis@Smilodon:~/scripts</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mclose">?</span><span class="mord">0</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord">@</span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mspace nobreak"> </span><span class="mord">/</span><span class="mord mathdefault">s</span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">s</span></span></span></span> test -e sh01.sh &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; exist alexis@Smilodon:~/scripts$ test -e nofile &amp;&amp; echo &quot;exist&quot; || echo &quot;not exist&quot; not exist alexis@Smilodon:~/scripts$ 复制代码</p>
<p>其他判断参数如下</p>
<p>测试的标志	代表意义</p>
<p>关於某个档名的『文件类型』判断，如 test -e filename 表示存在否 -e	该『档名』是否存在？(常用) -f	该『档名』是否存在且为文件(file)？(常用) -d	该『档名』是否存在且为目录(directory)？(常用) -b	该『档名』是否存在且为一个 block device 装置？ -c	该『档名』是否存在且为一个 character device 装置？ -S	该『档名』是否存在且为一个 Socket 文件？ -p	该『档名』是否存在且为一个 FIFO (pipe) 文件？ -L	该『档名』是否存在且为一个连结档？<br>
关於文件的权限侦测，如 test -r filename 表示可读否 (但 root 权限常有例外) -r	侦测该档名是否存在且具有『可读』的权限？ -w	侦测该档名是否存在且具有『可写』的权限？ -x	侦测该档名是否存在且具有『可运行』的权限？ -u	侦测该档名是否存在且具有『SUID』的属性？ -g	侦测该档名是否存在且具有『SGID』的属性？ -k	侦测该档名是否存在且具有『Sticky bit』的属性？ -s	侦测该档名是否存在且为『非空白文件』？<br>
两个文件之间的比较，如： test file1 -nt file2 -nt	(newer than)判断 file1 是否比 file2 新 -ot	(older than)判断 file1 是否比 file2 旧 -ef	判断 file1 与 file2 是否为同一文件，可用在判断 hard link 的判定上。 主要意义在判定，两个文件是否均指向同一个 inode 哩！<br>
关於两个整数之间的判定，例如 test n1 -eq n2 -eq	两数值相等 (equal) -ne	两数值不等 (not equal) -gt	n1 大於 n2 (greater than) -lt	n1 小於 n2 (less than) -ge	n1 大於等於 n2 (greater than or equal) -le	n1 小於等於 n2 (less than or equal)<br>
判定字串的数据 test -z string	判定字串是否为 0 ？若 string 为空字串，则为 true test -n string	判定字串是否非为 0 ？若 string 为空字串，则为 false。 注： -n 亦可省略 test str1 = str2	判定 str1 是否等於 str2 ，若相等，则回传 true test str1 != str2	判定 str1 是否不等於 str2 ，若相等，则回传 false<br>
多重条件判定，例如： test -r filename -a -x filename -a	(and)两状况同时成立！例如 test -r file -a -x file，则 file 同时具有 r 与 x 权限时，才回传 true。 -o	(or)两状况任何一个成立！例如 test -r file -o -x file，则 file 具有 r 或 x 权限时，就可回传 true。 !	反相状态，如 test ! -x file ，当 file 不具有 x 时，回传 true<br>
使用中括号 [ ] 来判断，使用[ ]需要注意的有<br>
括号两端和判断字符两旁必须有空格，如用 _ 表示空格，则是 [&quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>v</mi><mi>a</mi><mi>r</mi><mn>1</mn><mi mathvariant="normal">&quot;</mi><mo>=</mo><mo>=</mo><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">var1&quot;==&quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord">1</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">&quot;</span></span></span></span>var2&quot;]</p>
<p>变量变量用双引号扩起来，否则会出现 &quot;Too many arguments&quot; 的错误</p>
<p>3） 字符串用双引号或单引号扩起来</p>
<p>以下是shell示例脚本</p>
<p>复制代码 #!/bin/bash</p>
<p>use 'test' command to dump file properties</p>
<p>echo &quot;Please enter a file name, and I will dump the file properties&quot; read -p &quot;Enter your file name here: &quot; filename</p>
<p>判断该变量是否是个非空字符串</p>
<p>test -z $filename &amp;&amp; echo &quot;You MUST input a filename&quot; &amp;&amp; exit 0</p>
<p>判断文件是否存在</p>
<p>test ! -e <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 10: filename &amp;̲&amp; echo &quot;file &#039;'>filename &amp;&amp; echo &quot;file &#039;</span>filename' DOES NOT exist&quot; &amp;&amp; exit 0</p>
<p>检查文件类型与属性</p>
<p>test -f $filename &amp;&amp; filetype=&quot;regular file&quot; test -d $filename &amp;&amp; filetype=&quot;directory&quot; test -r $filename &amp;&amp; perm=&quot;readable&quot; test -w <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 10: filename &amp;̲&amp; perm=&quot;'>filename &amp;&amp; perm=&quot;</span>perm writable&quot; test -x <span class='katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 10: filename &amp;̲&amp; perm=&quot;'>filename &amp;&amp; perm=&quot;</span>perm executable&quot;</p>
<p>输出文件属性</p>
<p>echo &quot;File '$filename' is a $filetype&quot; echo &quot;And the permissions are : $perm&quot; 复制代码</p>
<p>复制代码 #!/bin/bash</p>
<p>test []</p>
<p>read -p &quot;Please input (Y/N)&quot; yn</p>
<p>使用 -o 表示 or</p>
<p>[ &quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mi>n</mi><mi mathvariant="normal">&quot;</mi><mo>=</mo><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>Y</mi><mi mathvariant="normal">&quot;</mi><mo>−</mo><mi>o</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">yn&quot; == &quot;Y&quot; -o &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">n</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.22222em;">Y</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord">&quot;</span></span></span></span>yn&quot; == &quot;y&quot; ] &amp;&amp; echo &quot;OK, continue&quot; &amp;&amp; exit 0 [ &quot;<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>y</mi><mi>n</mi><mi mathvariant="normal">&quot;</mi><mo>=</mo><mo>=</mo><mi mathvariant="normal">&quot;</mi><mi>N</mi><mi mathvariant="normal">&quot;</mi><mo>−</mo><mi>o</mi><mi mathvariant="normal">&quot;</mi></mrow><annotation encoding="application/x-tex">yn&quot; == &quot;N&quot; -o &quot;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">y</span><span class="mord mathdefault">n</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord">&quot;</span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mord">&quot;</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">o</span><span class="mord">&quot;</span></span></span></span>yn&quot; == &quot;n&quot; ] &amp;&amp; echo &quot;OK, interrupt&quot; &amp;&amp; exit 0 echo &quot;I don't know what you choice is&quot; &amp;&amp; exit 0 复制代码</p>
<p>id : 显示用户的用户id和用户组id信息</p>
<p>alexis@Smilodon:~/scripts$ id alexis uid=1000(alexis) gid=1000(alexis) groups=1000(alexis),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),109(lpadmin),124(sambashare)</p>
<p>finger ： 显示用户信息</p>
<p>复制代码 alexis@Smilodon:~/scripts$ finger alexis Login: alexis Name: Alexis Directory: /home/alexis Shell: /bin/bash On since Wed Jan 16 17:32 (CST) on tty7 1 hour 35 minutes idle On since Wed Jan 16 17:56 (CST) on pts/0 from :0.0 No mail. No Plan. 复制代码</p>
<p>newgrp : 更改当前用户的有效群组(创建文件时显示的群组)</p>
<p>newgrp sudo : 把当前用户有效群组改为sudo</p>
<p>su : 切换用户身份</p>
<p>su - : 以login-shell的方式切换到root，会重新读出login-shell配置</p>
<p>su -l alexis : 以login-shell的方式切换到alexis</p>
<p>sudo与sudoers文件</p>
<p>要使用sudo命令必须通过sudoers文件授权，切换到root用户编辑sudoers文件，加入一下行</p>
<p>alexis ALL=（ALL） ALL</p>
<p>%sudo ALL=(ALL) ALL</p>
<p>第一列表示授权的用户或用户组(带%的为用户组)</p>
<p>第二列的ALL表示可以从任何ip的主机使用sudo</p>
<p>第三列的(ALL)表示alexis可以通过sudo切换为任何用户下达命令</p>
<p>第四列的ALL表示用户可以通过sudo下达所有命令</p>
<p>w, who : 查看当前在线用户状况</p>
<p>lastlog: 查看所有用户最后登录情况</p>
<p>write ： 发送信息给其他在线用户</p>
<p>write alexis pst/1 ： 发送消息给 pst/1 的 alexis</p>
<p>mesg [y/n] : 接受或拒绝write的消息(root的消息除外)</p>
<p>wall ： 广播信息给所有用户</p>
<p>wall &quot;I will shutdown the system in 3 minutes&quot;</p>
<p>一次性计划任务 at 的使用</p>
<p>at ： 可以执行一次计划任务，并且有nohup效果，即不会因为会话结束而被中断</p>
<p>at的用户管理文件是/etc/at.allow /etc/at.deny</p>
<p>存在at.allow，则在at.allow文件中的所有用户可以执行at任务，不存在的用户不可执行at任务<br>
2.存在at.deny，则在at.deny文件中的用户不可执行at人物，不存在的用户可以执行at任务</p>
<p>3.如果两个文件都不存在，则只有root可执行at任务</p>
<p>命令格式</p>
<p>at -l 或 atq ： 查看所有at任务</p>
<p>atrm [jobid] : 删除第jobid号任务</p>
<p>at TIME : 在TIME时间内执行任务，TIME可以是HH:MM， HH：MM yyyy-mm-dd, now +5 minutes, 04pm +3 days</p>
<p>之后会进入一个shell，将你要执行的命令输入在shell中，最后ctrl+d(EOF)退出</p>
<p>周期性计划任务crontab</p>
<p>crontab ： 可以执行周期性计划任务，此命令的计划任务是针对用户而言的</p>
<p>crontab的管理文件是/etc/cron.allow, /etc/cron.deny.其管理规则与at的相同</p>
<p>crontab -u username -l : 列出某用户的所有计划任务，不加-u为列出当前用户的任务</p>
<p>crontab -r : 删除所有计划任务</p>
<p>crontab -e : 编辑计划任务，此计划任务的文件一般是自动创建于/var/spool/cron文件夹内</p>
<p>编辑计划任务的格式</p>
<p>0 12 * * * mail dmtsai -s &quot;at 12:00&quot; &lt; /home/dmtsai/.bashrc 计划任务一共6个栏位，分别表示</p>
<p>代表意义	分钟	小时	日期	月份	周	命令 数字范围	0-59	0-23	1-31	1-12	0-7	需要执行的命令</p>
<p>需要注意的是：周栏位的0和7都代表周日，且周不能与日月同时使用，否则会有问题，下面还有一些特殊的表示方法</p>
<p>特殊字符	代表意义 *(星号)	代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 * ， 就代表著『不论何月、何日的礼拜几的 12:00 都运行后续命令』的意思！ ,(逗号)	代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是： 0 3,6 * * * command 时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！ -(减号)	代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作： 20 8-12 * * * command 仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！ /n(斜线)	那个 n 代表数字，亦即是『每隔 n 单位间隔』的意思，例如每五分钟进行一次，则： */5 * * * * command 很简单吧！用 * 与 /5 来搭配，也可以写成 0-59/5 ，相同意思！</p>
<p>如果是要编辑系统的计划任务，而不是针对用户的计划任务，可以使用/etc/crontab文件，编辑他</p>
<p>复制代码</p>
<p>/etc/crontab: system-wide crontab</p>
<p>Unlike any other crontab you don't have to run the `crontab'</p>
<p>command to install the new version when you edit this file</p>
<p>and files in /etc/cron.d. These files also have username fields,</p>
<p>that none of the other crontabs do.</p>
<p>SHELL=/bin/sh PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin</p>
<p>m h dom mon dow user command</p>
<p>17 * * * * root cd / &amp;&amp; run-parts --report /etc/cron.hourly 25 6 * * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.daily ) 47 6 * * 7 root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.weekly ) 52 6 1 * * root test -x /usr/sbin/anacron || ( cd / &amp;&amp; run-parts --report /etc/cron.monthly )</p>
<p>复制代码 注意这个文件和crontab命令的区别，他多了一个user栏位，这里用来标注命令的运行者，其他地方和使用crontab命令一样</p>
<p>nohup : 无终止运行命令</p>
<p>使用nohup运行命令可以使命令在session断开后继续运行，比如用ssh登录的时候</p>
<p>nohup ./test.sh &amp;</p>
<p>这样test.sh在退出ssh登录后依然运行</p>
<p>pstree : 以树状形式现实进程关系</p>
<p>pstree -Aup</p>
<p>A : 程序间用ascii字节连接</p>
<p>u : 显示进程所属用户id</p>
<p>p : 现实进程pid</p>
<p>dmesg : 显示开机时内核检测的硬件信息</p>
<p>fuser : 通过文件显示使用该文件的用户</p>
<p>fuser -uv sh01.sh</p>
<p>u : 除了显示pid，也显示pid对应的用户名</p>
<p>v : 现实详细的文件相关信息， ACCESS 和 COMMAND</p>
<p>ACCESS有以下几种</p>
<p>c ：此程序在当前的目录下(非次目录)； e ：可被触发为运行状态； f ：是一个被开启的文件； r ：代表顶层目录 (root directory)； F ：该文件被开启了，不过在等待回应中； m ：可能为分享的动态函式库； COMMAND 是使用该文件的命令</p>
<p>modprobe : 模块管理命令</p>
<p>modprobe vfat : 加载vfat模块</p>
<p>modprobe -r vfat : 删除vfat模块</p>
<p>modprobe -l : 列出所有可用模块</p>
<p>lsmod : 列出已加载模块</p>
<p>modinfo : 查看模块详情</p>
<p>modinfo vfat</p>
<p>man hier : Description of the file system hierarchy</p>
<p>cat /etc/issue : 查看linux的发行版本</p>
<p>rsync : 将远程主机数据同步到本地</p>
<p>rsync -avzP bkuser@192.168.10.1:/bk/remotebackup /localbackup</p>
<p>将远端的 remotebackup 备份到本地</p>
<p>-a 参数，相当于-rlptgoD，-r 是递归 -l 是链接文件，意思是拷贝链接文件；-p 表示保持文件原有权限；-t 保持文件原有时间；-g 保持文件原有用户组；-o 保持文件原有属主；-D 相当于块设备文件； -z 传输时压缩； -P 传输进度； -v 传输时的进度等信息，和-P有点关系，自己试试。可以看文档；</p>
<p>rsync -chavzP --rsync-path=&quot;sudo rsync&quot; source 192.168.1.1:/dst</p>
<p>使用 sudo 用户将数据 rsync 到 dst</p>
<p>apt-get update : 跟新软件列表 apt-get upgrade : 更新现有软件 apt-get dist-upgrade : 更新disribution</p>
<p>sar -n DEV 1 100</p>
<p>查看网络流量, 每1秒输出一次, 输出100次, 输出内容</p>
<p>sar 还可以监控cpu -u, 内存 -r 具体看man</p>
<p>mac</p>
<p>lsof -i -P: 可以用来查看端口</p>
<p>-i: 只显示网络地址</p>
<p>-P: 让端口号不会转化成端口名</p>
<p>sudo tcpdump -X -i lo0 src host 127.0.0.1 and port 8081</p>
<p>-X: 将数据转换成ASCII</p>
<p>-i: 指定网卡</p>
<p>src: 指定源地址</p>
<p>dest: 指定目标地址</p>
<p>port: 端口</p>
<p>stty: tty 设置</p>
<p>stty -ixon 开启 XON 流控制, 开启这个以后 reverse search(ctrl+r) 可以使用 ctrl+r ctrl+s 来向前向后查找</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java获取当前路径的几种方法]]></title>
        <id>https://skytotwo.github.io//post/java-get-url</id>
        <link href="https://skytotwo.github.io//post/java-get-url">
        </link>
        <updated>2019-08-12T08:31:12.000Z</updated>
        <summary type="html"><![CDATA[<p>java开发过程中经常需要获取当前路径，而java也有相应的内置函数来对此提供支持，下面来介绍一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>java开发过程中经常需要获取当前路径，而java也有相应的内置函数来对此提供支持，下面来介绍一下。</p>
<!-- more -->
<p>1、利用System.getProperty()函数获取当前路径：<br>
System.out.println(System.getProperty(&quot;user.dir&quot;));//user.dir指定了当前的路径</p>
<p>2、使用File提供的函数获取当前路径：<br>
File directory = new File(&quot;&quot;);//设定为当前文件夹<br>
try{<br>
System.out.println(directory.getCanonicalPath());//获取标准的路径<br>
System.out.println(directory.getAbsolutePath());//获取绝对路径<br>
}catch(Exceptin e){}</p>
<p>File.getCanonicalPath()和File.getAbsolutePath()大约只是对于new File(&quot;.&quot;)和new File(&quot;..&quot;)两种路径有所区别。</p>
<p>对于getCanonicalPath()函数，“.&quot;就表示当前的文件夹，而”..“则表示当前文件夹的上一级文件夹<br>
对于getAbsolutePath()函数，则不管”.”、“..”，返回当前的路径加上你在new File()时设定的路径<br>
至于getPath()函数，得到的只是你在new File()时设定的路径</p>
<p>比如当前的路径为 C:/test ：<br>
File directory = new File(&quot;abc&quot;);<br>
directory.getCanonicalPath(); //得到的是C:/test/abc<br>
directory.getAbsolutePath();    //得到的是C:/test/abc<br>
direcotry.getPath();                    //得到的是abc</p>
<p>File directory = new File(&quot;.&quot;);<br>
directory.getCanonicalPath(); //得到的是C:/test<br>
directory.getAbsolutePath();    //得到的是C:/test/.<br>
direcotry.getPath();                    //得到的是.</p>
<p>File directory = new File(&quot;..&quot;);<br>
directory.getCanonicalPath(); //得到的是C:/<br>
directory.getAbsolutePath();    //得到的是C:/test/..<br>
direcotry.getPath();                    //得到的是..</p>
<p>另外：System.getProperty()中的字符串参数如下：</p>
<pre><code class="language-java">System.getProperty()参数大全 
java.version                                Java Runtime Environment version  
java.vendor                                Java Runtime Environment vendor  
java.vendor.url                           Java vendor URL  
java.home                                Java installation directory  
java.vm.specification.version   Java Virtual Machine specification version  
java.vm.specification.vendor    Java Virtual Machine specification vendor  
java.vm.specification.name      Java Virtual Machine specification name  
java.vm.version                        Java Virtual Machine implementation version  
java.vm.vendor                        Java Virtual Machine implementation vendor  
java.vm.name                        Java Virtual Machine implementation name  
java.specification.version        Java Runtime Environment specification version  
java.specification.vendor         Java Runtime Environment specification vendor  
java.specification.name           Java Runtime Environment specification name  
java.class.version                    Java class format version number  
java.class.path                      Java class path  
java.library.path                 List of paths to search when loading libraries  
java.io.tmpdir                       Default temp file path  
java.compiler                       Name of JIT compiler to use  
java.ext.dirs                       Path of extension directory or directories  
os.name                              Operating system name  
os.arch                                  Operating system architecture  
os.version                       Operating system version  
file.separator                         File separator (&quot;/&quot; on UNIX)  
path.separator                  Path separator (&quot;:&quot; on UNIX)  
line.separator                       Line separator (&quot;/n&quot; on UNIX)  
user.name                        User’s account name  
user.home                              User’s home directory  
user.dir                               User’s current working directory
</code></pre>
<h4 id="java中获取路径">JAVA中获取路径:</h4>
<p><strong>1.jsp中取得路径：</strong></p>
<p>以工程名为TEST为例：</p>
<p>(1)得到包含工程名的当前页面全路径：request.getRequestURI()<br>
结果：/TEST/test.jsp<br>
(2)得到工程名：request.getContextPath()<br>
结果：/TEST<br>
(3)得到当前页面所在目录下全名称：request.getServletPath()<br>
结果：如果页面在jsp目录下 /TEST/jsp/test.jsp<br>
(4)得到页面所在服务器的全路径：application.getRealPath(&quot;页面.jsp&quot;)<br>
结果：D:/resin/webapps/TEST/test.jsp<br>
(5)得到页面所在服务器的绝对路径：absPath=new java.io.File(application.getRealPath(request.getRequestURI())).getParent();<br>
结果：D:/resin/webapps/TEST</p>
<p><strong>2.在类中取得路径：</strong></p>
<p>(1)类的绝对路径：Class.class.getClass().getResource(&quot;/&quot;).getPath()<br>
结果：/D:/TEST/WebRoot/WEB-INF/classes/pack/<br>
(2)得到工程的路径：System.getProperty(&quot;user.dir&quot;)<br>
结果：D:/TEST</p>
<p><strong>3.在Servlet中取得路径：</strong></p>
<p>(1)得到工程目录：request.getSession().getServletContext().getRealPath(&quot;&quot;) 参数可具体到包名。<br>
结果：E:/Tomcat/webapps/TEST<br>
(2)得到IE地址栏地址：request.getRequestURL()<br>
结果：http://localhost:8080/TEST/test<br>
(3)得到相对地址：request.getRequestURI()<br>
结果：/TEST/test</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用java正则表达式来解析并获取指定的字符串]]></title>
        <id>https://skytotwo.github.io//post/java-regex</id>
        <link href="https://skytotwo.github.io//post/java-regex">
        </link>
        <updated>2019-08-05T04:27:09.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Java的正则表达式不仅可以用来匹配验证字符串是否符合标准类型，还可以用来解析字符串，获取自己想要得到的数据。在java.util.regex包下提供了系列的类来对字符串进行匹配。</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Java的正则表达式不仅可以用来匹配验证字符串是否符合标准类型，还可以用来解析字符串，获取自己想要得到的数据。在java.util.regex包下提供了系列的类来对字符串进行匹配。</strong></p>
<!-- more -->
<p>来看一下下面的例子：</p>
<pre><code class="language-java">publicstatic String parse (String s){
    Pattern pattern =Pattern.compile(&quot;charset=(.+?)\&quot;&quot;);//匹配的模式
     //通配符中也要加入转移字符 (.+?)代表要查找的内容
    Matcher matcher=pattern.matcher(s);
    while(matcher.find()){
       System.out.println(matcher.group(1)); //每次返回第一个即可 可用groupcount()方法来查看捕获的组数个数
    }
    return s;
}
</code></pre>
<p><strong>要匹配一下类型的字符串：<br>
其中标红的部分为想要获取的数据，注意这里要获取的数据长度不固定，并且可能为unicode<br>
Gb2312等其他编码类型，在这里我们所希望获取的是其编码方式。</strong><br>
具体应用实例：</p>
<pre><code class="language-java">package URL;
import java.NET.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.io.BufferedReader;
importjava.io.InputStream;
import java.io.InputStreamReader;
importjava.util.regex.*;
publicclass DataFromURL {
publicstatic String parse (String s){
    Pattern pattern =Pattern.compile(&quot;charset=(.+?)\&quot;&quot;);
    //通配符中也要加入转移字符 (.+?)代表要查找的内容
    Matcher matcher=pattern.matcher(s);
    while(matcher.find()){
       System.out.println(matcher.group(1));
    }
    return s;
}
publicstaticvoidgetDataFromURL(String url){
    try{
        URL u=new URL(url);//通过连接创建URL对象
        BufferedReader reader=new BufferedReader(new       InputStreamReader(u.openStream(),&quot;gb2312&quot;));//采用gb2312方式打开输入流
        intc;
       /*while((c=reader.read())!=-1)//该方法为每个字符读取
        {
            System.out.print((char)c);
        }*/
        String s;
        while((s=reader.readLine())!=null){//不为空一次性读取一行
        //System.out.println(s);
            if(s.contains(&quot;charset&quot;)){
                 parse(s);
            }
        }
    }catch(Exception e){
       e.printStackTrace();
    }
}
}
</code></pre>
<p>附录正则表达式说明：</p>
<p>众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生，而这些情况有时又比较复杂，如果用纯编码方式解决，往往会浪费程序员的时间及精力。因此，学习及使用正则表达式，便成了解决这一矛盾的主要手段。<br>
大 家都知道，正则表达式是一种可以用于模式匹配和替换的规范，一个正则表达式就是由普通的字符（例如字符a到z）以及特殊字符（元字符）组成的文字模式，它 用以描述在查找文字主体时待匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。<br>
自从jdk1.4推出java.util.regex包，就为我们提供了很好的JAVA正则表达式应用平台。</p>
<p>因为正则表达式是一个很庞杂的体系，所以我仅例举些入门的概念，更多的请参阅相关书籍及自行摸索。</p>
<p>// 反斜杠<br>
/t 间隔 ('/u0009')<br>
/n 换行 ('/u000A')<br>
/r 回车 ('/u000D')<br>
/d 数字 等价于[0-9]<br>
/D 非数字 等价于[^0-9]<br>
/s 空白符号 [/t/n/x0B/f/r]<br>
/S 非空白符号 [^/t/n/x0B/f/r]<br>
/w 单独字符 [a-zA-Z_0-9]<br>
/W 非单独字符 [^a-zA-Z_0-9]<br>
/f 换页符<br>
/e Escape<br>
/b 一个单词的边界<br>
/B 一个非单词的边界<br>
/G 前一个匹配的结束</p>
<p>^为限制开头<br>
^java    条件限制为以Java为开头字符<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">为</mi><mi mathvariant="normal">限</mi><mi mathvariant="normal">制</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">尾</mi><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">为限制结尾
java</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">限</span><span class="mord cjk_fallback">制</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">尾</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span></span></span></span>    条件限制为以java为结尾字符<br>
.  条件限制除/n以外任意一个单独字符<br>
java..    条件限制为java后除换行外任意两个字符</p>
<p>加入特定限制条件「[]」<br>
[a-z]    条件限制在小写a to z范围中一个字符<br>
[A-Z]    条件限制在大写A to Z范围中一个字符<br>
[a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符<br>
[0-9]    条件限制在小写0 to 9范围中一个字符<br>
[0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符<br>
[0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集)</p>
<p>[]中加入<sup>后加再次限制条件「[</sup>]」<br>
[^a-z]    条件限制在非小写a to z范围中一个字符<br>
[^A-Z]    条件限制在非大写A to Z范围中一个字符<br>
[^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符<br>
[^0-9]    条件限制在非小写0 to 9范围中一个字符<br>
[^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符<br>
[^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集)</p>
<p>在限制条件为特定字符出现0次以上时，可以使用「<em>」<br>
J</em>    0个以上J<br>
.*    0个以上任意字符<br>
J.*D    J与D之间0个以上任意字符</p>
<p>在限制条件为特定字符出现1次以上时，可以使用「+」<br>
J+    1个以上J<br>
.+    1个以上任意字符<br>
J.+D    J与D之间1个以上任意字符</p>
<p>在限制条件为特定字符出现有0或1次以上时，可以使用「?」<br>
JA?    J或者JA出现</p>
<p>限制为连续出现指定次数字符「{a}」<br>
J{2}    JJ<br>
J{3}    JJJ<br>
文字a个以上，并且「{a,}」<br>
J{3,}    JJJ,JJJJ,JJJJJ,???(3次以上J并存)<br>
文字个以上，b个以下「{a,b}」<br>
J{3,5}    JJJ或JJJJ或JJJJJ<br>
两者取一「|」<br>
J|A    J或A<br>
Java|Hello    Java或Hello</p>
<p>「()」中规定一个组合类型<br>
比如，我查询index中间的数据，可写作(.+?)</p>
<p>在使用Pattern.compile函数时，可以加入控制正则表达式的匹配行为的参数：<br>
PatternPattern.compile(String regex, int flag)</p>
<p>flag的取值范围如下：<br>
Pattern.CANON_EQ    当且仅当两个字符的&quot;正规分解(canonical decomposition)&quot;都完全相同的情况下，才认定匹配。比如用了这个标志之后，表达式&quot;a/u030A&quot;会匹配&quot;?&quot;。默认情况下，不考虑&quot;规 范相等性(canonical equivalence)&quot;。<br>
Pattern.CASE_INSENSITIVE(?i)    默认情况下，大小写不明感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不明感的匹 配，只要将UNICODE_CASE与这个标志合起来就行了。<br>
Pattern.COMMENTS(?x)    在这种模式下，匹配时会忽略(正则表达式里的)空格字符(译者注：不是指表达式里的&quot;//s&quot;，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。<br>
Pattern.DOTALL(?s)    在这种模式下，表达式'.'可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式'.'不匹配行的结束符。<br>
Pattern.MULTILINE<br>
(?m)    在这种模式下，'^'和'<span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;^&#039; at position 19: …匹配一行的开始和结束。此外，&#039;^̲&#039;仍然匹配字符串的开始，&#039;'>&#039;分别匹配一行的开始和结束。此外，&#039;^&#039;仍然匹配字符串的开始，&#039;</span>'也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。<br>
Pattern.UNICODE_CASE<br>
(?u)    在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不明感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。<br>
Pattern.UNIX_LINES(?d)    在这个模式下，只有'/n'才被认作一行的中止，并且与'.'，'^'，以及'$'进行匹配。</p>
<p>抛开空泛的概念，下面写出几个简单的Java正则用例：</p>
<p>◆比如，在字符串包含验证时</p>
<p>//查找以Java开头,任意结尾的字符串<br>
Patternpattern = Pattern.compile(&quot;^Java.*&quot;);<br>
Matchermatcher = pattern.matcher(&quot;Java不是人&quot;);<br>
boolean b=matcher.matches();<br>
//当条件满足时，将返回true，否则返回false<br>
System.out.println(b);</p>
<p>◆以多条件分割字符串时<br>
Pattern pattern =Pattern.compile(&quot;[, |]+&quot;);<br>
String[] strs =pattern.split(&quot;Java Hello World  Java,Hello,,World|Sun&quot;);<br>
for (inti=0;i<br>
System.out.println(strs[i]);<br>
}</p>
<p>◆文字替换（首次出现字符）<br>
Pattern pattern =Pattern.compile(&quot;正则表达式&quot;);<br>
Matcher matcher =pattern.matcher(&quot;正则表达式 HelloWorld,正则表达式 Hello World&quot;);<br>
//替换第一个符合正则的数据<br>
System.out.println(matcher.replaceFirst(&quot;Java&quot;));</p>
<p>◆文字替换（全部）<br>
Pattern pattern =Pattern.compile(&quot;正则表达式&quot;);<br>
Matcher matcher =pattern.matcher(&quot;正则表达式 HelloWorld,正则表达式 Hello World&quot;);<br>
//替换第一个符合正则的数据<br>
System.out.println(matcher.replaceAll(&quot;Java&quot;));</p>
<p>◆文字替换（置换字符）<br>
Pattern pattern =Pattern.compile(&quot;正则表达式&quot;);<br>
Matcher matcher =pattern.matcher(&quot;正则表达式 HelloWorld,正则表达式 Hello World &quot;);<br>
StringBuffer sbr =new StringBuffer();<br>
while(matcher.find()) {<br>
matcher.appendReplacement(sbr, &quot;Java&quot;);<br>
}<br>
matcher.appendTail(sbr);<br>
System.out.println(sbr.toString());</p>
<p>◆验证是否为邮箱地址</p>
<p>Stringstr=&quot;ceponline@yahoo.com.cn&quot;;<br>
Pattern pattern =Pattern.compile(&quot;[//w//.//-]+@([//w//-]+//.)+[//w//-]+&quot;,Pattern.CASE_INSENSITIVE);<br>
Matcher matcher =pattern.matcher(str);<br>
System.out.println(matcher.matches());</p>
<p>◆去除html标记<br>
Pattern pattern =Pattern.compile(&quot;&lt;.+?&gt;&quot;, Pattern.DOTALL);<br>
Matcher matcher =pattern.matcher(&quot;主页&quot;);<br>
String string =matcher.replaceAll(&quot;&quot;);<br>
System.out.println(string);</p>
<p>◆查找html中对应条件字符串<br>
Pattern pattern =Pattern.compile(&quot;href=/&quot;(.+?)/&quot;&quot;);<br>
Matcher matcher =pattern.matcher(&quot;主页&quot;);<br>
if(matcher.find())<br>
System.out.println(matcher.group(1));<br>
}</p>
<p>◆截取http://地址<br>
//截取url<br>
Pattern pattern =Pattern.compile(&quot;(http://|https://){1}[//w//.//-/:]+&quot;);<br>
Matcher matcher =pattern.matcher(&quot;dsdsdsfdf&quot;);<br>
StringBuffer buffer= new StringBuffer();<br>
while(matcher.find()){<br>
buffer.append(matcher.group());<br>
buffer.append(&quot;/r/n&quot;);<br>
System.out.println(buffer.toString());<br>
}</p>
<p>◆替换指定{}中文字</p>
<p>String str =&quot;Java目前的发展史是由{0}年-{1}年&quot;;<br>
String[][]object={new String[]{&quot;//{0//}&quot;,&quot;1995&quot;},newString[]{&quot;//{1//}&quot;,&quot;2007&quot;}};<br>
System.out.println(replace(str,object));</p>
<pre><code class="language-java">public staticString replace(final String sourceString,Object[] object) {
	Stringtemp=sourceString;    
	for(int i=0;i
		String[]result=(String[])object[i];
		Pattern   pattern = Pattern.compile(result[0]);
		Matcher matcher =pattern.matcher(temp);
		temp=matcher.replaceAll(result[1]);
		}
		return temp;
}

</code></pre>
<p>◆以正则条件查询指定目录下文件</p>
<pre><code class="language-java">//用于缓存文件列表
      private ArrayList files = new ArrayList();
      //用于承载文件路径
      private String _path;
      //用于承载未合并的正则公式
      private String _regexp;

      class MyFileFilter implements FileFilter {

            /**
             * 匹配文件名称
             */
            public boolean accept(File file) {
              try {
                Patternpattern = Pattern.compile(_regexp);
                Matchermatch = pattern.matcher(file.getName());               
                returnmatch.matches();
              } catch (Exception e) {
                returntrue;
              }
            }
          }

      /**
       * 解析输入流
       * @param inputs
       */
      FilesAnalyze (String path,String regexp){
          getFileName(path,regexp);
      }

      /**
       * 分析文件名并加入files
       * @param input
       */
      private void getFileName(String path,String regexp) {
          //目录
            _path=path;
            _regexp=regexp;
            File directory = new File(_path);
            File[] filesFile =directory.listFiles(new MyFileFilter());
            if (filesFile == null) return;
            for (int j = 0; j
             files.add(filesFile[j]);
            }
            return;
          }

      /**
       * 显示输出信息
       * @param out
       */
      public void print (PrintStream out) {
          Iterator elements = files.iterator();
          while (elements.hasNext()) {
              File file=(File)elements.next();
                 out.println(file.getPath());    
          }
      }

      public static void output(String path,String regexp) {

          FilesAnalyze fileGroup1 = newFilesAnalyze(path,regexp);
          fileGroup1.print(System.out);
      }

      public static void main (String[] args) {
         output(&quot;C://&quot;,&quot;[A-z|.]*&quot;);
      }
</code></pre>
<p>Java正则的功用还有很多，事实上只要是字符处理，就没有正则做不到的事情存在。（当然，正则解释时较耗时间就是了|||……）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java程序实现删除本地文件]]></title>
        <id>https://skytotwo.github.io//post/java-delete-file</id>
        <link href="https://skytotwo.github.io//post/java-delete-file">
        </link>
        <updated>2019-08-05T04:19:50.000Z</updated>
        <summary type="html"><![CDATA[<p>之前有用到过在项目里删除本地文件，记录下代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前有用到过在项目里删除本地文件，记录下代码。</p>
<!-- more -->
<pre><code class="language-java">import Java.io.File;
public class Test {
public static void main(String args[]) {
   Test t = new Test();
   delFolder(&quot;d:/test&quot;);
   System.out.println(&quot;OK&quot;);
}
// 删除文件夹
// param folderPath 文件夹完整绝对路径
public static void delFolder(String folderPath) {
   try {
    delAllFile(folderPath); // 删除完里面所有内容
    String filePath = folderPath;
    filePath = filePath.toString();
    java.io.File myFilePath = new java.io.File(filePath);
    myFilePath.delete(); // 删除空文件夹
   } catch (Exception e) {
    e.printStackTrace();
   }
}
// 删除指定文件夹下所有文件
// param path 文件夹完整绝对路径
public static boolean delAllFile(String path) {
   boolean flag = false;
   File file = new File(path);
   if (!file.exists()) {
    return flag;
   }
   if (!file.isDirectory()) {
    return flag;
   }
   String[] tempList = file.list();
   File temp = null;
   for (int i = 0; i &lt; tempList.length; i++) {
    if (path.endsWith(File.separator)) {
     temp = new File(path + tempList[i]);
    } else {
temp = new File(path + File.separator + tempList[i]);
    }
    if (temp.isFile()) {
     temp.delete();
    }
    if (temp.isDirectory()) {
       delAllFile(path + &quot;/&quot; + tempList[i]);// 先删除文件夹里面的文件
       delFolder(path + &quot;/&quot; + tempList[i]);// 再删除空文件夹
     flag = true;
    }
   }
   return flag;
}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网页登陆页面设置Cookie]]></title>
        <id>https://skytotwo.github.io//post/js-cookie-set</id>
        <link href="https://skytotwo.github.io//post/js-cookie-set">
        </link>
        <updated>2019-08-05T04:11:45.000Z</updated>
        <summary type="html"><![CDATA[<p>cookie是保存http协议状态的一个重要手段，基本上所有网站都会使用到cookie机制，cookie是session的一个实现方式，当然现在还有token来代替cookie，但cookie依旧是很重要的一个模式，这里在js中实现设置cookie进而实现登陆访问。</p>
]]></summary>
        <content type="html"><![CDATA[<p>cookie是保存http协议状态的一个重要手段，基本上所有网站都会使用到cookie机制，cookie是session的一个实现方式，当然现在还有token来代替cookie，但cookie依旧是很重要的一个模式，这里在js中实现设置cookie进而实现登陆访问。</p>
<!-- more -->
<pre><code class="language-javascript">&lt;%@ page contentType=&quot;text/html; charset=GB2312&quot;%&gt;
&lt;%@ page import=&quot;tellhow.commonweb.system.*&quot; %&gt;
&lt;%
   String useraccounts=&quot;&quot;;
   String userpassword=&quot;&quot;;
   String Messageinfo=&quot;请输入用户信息&quot;;
   useraccounts=request.getParameter(&quot;accounts&quot;);
   userpassword=request.getParameter(&quot;password&quot;);
   String flag = request.getParameter(&quot;flag&quot;)==null?&quot;&quot;:request.getParameter(&quot;flag&quot;);//flag为1则为从oms系统登陆 
   if(useraccounts!=null&amp;&amp;userpassword!=null){
   if(!useraccounts.equals(&quot;null&quot;)&amp;&amp;!useraccounts.equals(&quot;&quot;)&amp;&amp;!userpassword.equals(&quot;null&quot;)&amp;&amp;!userpassword.equals(&quot;&quot;)){
   loginBean myloginbean=new loginBean();
   myloginbean.init(pageContext);
   int retval;
   retval=myloginbean.checkuserlogin(useraccounts,userpassword,flag);
   switch(retval)
   {
      case 1:
         // response.sendRedirect(&quot;system/index_manage.jsp&quot;);
         // response.sendRedirect(&quot;gz/index.jsp&quot;);
         String url = request.getContextPath() + &quot;/getUserMsg.do?method=getUserInfo&amp;username=&quot; + useraccounts;
         System.out.println(url);
         response.sendRedirect(url);
      break;
      case -1:
          Messageinfo=&quot;您输入的密码不对，请重新输入!&quot;;
      break;
      case -2:
          Messageinfo=&quot;您输入的用户不存在，请重新输入!&quot;;
      break;
   }
   }
 }
%&gt;
&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;
	function window_Onload(){
	  loginfrm.accounts.focus();
	}
	function onInputKeyup(){
	  if(event.keyCode==13){
	  		if(event.srcElement.name==&quot;accounts&quot;){
	      		loginfrm.password.focus();
	      		return;
    		}
    		if(event.srcElement.name==&quot;password&quot;){
	      		loginfrm.submit();
	      		return;
    		}
  	  }
	}
&lt;/script&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;
&lt;title&gt;网站管理系统&lt;/title&gt;
&lt;!--[if lte IE 6]&gt;
&lt;script src=&quot;../css/mycss/js/DD_belatedPNG_0.0.8a.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    DD_belatedPNG.fix('*');
&lt;/script&gt;
&lt;![endif]--&gt;
&lt;link href=&quot;css/mycss/style/public.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;script src=&quot;css/mycss/js/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;css/mycss/js/index.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/jquery-1.8.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/jquery.cookie.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body  onload=&quot;window_Onload();getCookie();&quot;&gt;
&lt;FORM action=login.jsp method=post name=&quot;loginfrm&quot;&gt;
&lt;div class=&quot;main_area&quot;&gt;
    &lt;div class=&quot;main_left_area&quot;&gt;&lt;img src=&quot;css/mycss/images/logo_bg01.png&quot; width=&quot;280&quot; height=&quot;130&quot; /&gt;&lt;/div&gt;
    &lt;div class=&quot;main_mid_area&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;main_right_area&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;main_info_area&quot;&gt;
        &lt;div class=&quot;fill01_area&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;title_area&quot;&gt;&lt;img src=&quot;css/mycss/images/main_bg02.png&quot; width=&quot;487&quot; height=&quot;46&quot; alt=&quot;网站管理系统&quot;/&gt;&lt;/div&gt;
        &lt;div class=&quot;fill02_area&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;login_area&quot;&gt;
            &lt;div class=&quot;login_left_area&quot;&gt;
                &lt;div class=&quot;fill03_area&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;login_info_area&quot;&gt;
                    &lt;span&gt;用户名：&lt;/span&gt;&lt;input name=&quot;accounts&quot; id=&quot;accounts&quot; type=&quot;text&quot; onkeyup=&quot;onInputKeyup();&quot;&gt;
                    &lt;div class=&quot;fill04_area&quot;&gt;&lt;/div&gt;
                    &lt;span&gt;密　码：&lt;/span&gt;&lt;input name=&quot;password&quot; id=&quot;password&quot; type=&quot;password&quot; onkeyup=&quot;onInputKeyup();&quot;&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;login_right_area&quot;&gt;
                &lt;a  onclick=&quot;savedata();&quot;&gt;&lt;/a&gt;
            &lt;/div&gt;
            &lt;!-- &lt;a class=&quot;href03_area&quot; href=&quot;/login.jsp?accounts=guest&amp;password=1&quot;&gt;&lt;span &gt;&lt;/span&gt;&lt;font face=&quot;verdana&quot; size=&quot;3&quot; color=&quot;black&quot;&gt; 来宾访问&lt;/font&gt;&lt;/a&gt; --&gt;
        &lt;/div&gt;
        &lt;div class=&quot;login_href_area&quot;&gt;
            &lt;input type=&quot;checkbox&quot; id=&quot;boxchange&quot; name=&quot;checkbox&quot; value=&quot;1&quot;/&gt;
            &lt;a&gt;记住用户名密码&lt;/a&gt;
            &lt;a class=&quot;href03_area&quot; href=&quot;/login.jsp?accounts=guest&amp;password=1&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;flag_area&quot;&gt;&lt;%=Messageinfo%&gt;&lt;/div&gt;
        &lt;div &gt;&lt;/div&gt;
        &lt;div &gt;&lt;/div&gt;
        &lt;div class=&quot;login_href_areabottom&quot;&gt;&lt;font &gt;调控中心用户请使用OMS账户登录,其他用户请点击“来宾访问”&lt;/font&gt;&lt;/div&gt;
        &lt;div class=&quot;foot_area&quot;&gt;广州供电局有限公司 版权所有  技术支持:泰豪软件&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	var checkstate = null;//标识符，是为了在保存前调用设置cookie方法的进行判断
	$(&quot;#boxchange&quot;).change(function() { 
		if(document.all.checkbox.checked){ 
        	 checkstate = &quot;1&quot;;
         }else{
        	 checkstate = &quot;0&quot;;
        }
         
	});
	function savedata(){
		//存储cookie
	  	if(&quot;1&quot; == checkstate){  
				setCookie();
				//$.cookie(&quot;pwd&quot;,&quot;&quot;);
		}else if(&quot;0&quot; == checkstate){
			$.cookie('login_code', null, { expires: -1 });
	  		$.cookie('pwd', null, { expires: -1 });
		}
		loginfrm.submit();
	}
		
	//设置cookie
	function setCookie(){ //设置cookie    
       var loginCode = $(&quot;#accounts&quot;).val(); //获取用户名信息    
       var pwd = $(&quot;#password&quot;).val(); //获取登陆密码信息    
       $.cookie('login_code',loginCode, { expires: 7 });//调用jquery.cookie.js中的方法设置cookie中的用户名    
       $.cookie('pwd',pwd, { expires: 7 });//调用jquery.cookie.js中的方法设置cookie中的登陆密码
    }   
	function getCookie(){ //获取cookie    
        var loginCode = $.cookie('login_code'); //获取cookie中的用户名    
        var pwd =  $.cookie('pwd'); //获取cookie中的登陆密码    
        if(loginCode){//用户名存在的话把用户名填充到用户名文本框    
           $(&quot;#accounts&quot;).val(loginCode);    
        }    
        if(pwd){//密码存在的话把密码填充到密码文本框    
           $(&quot;#password&quot;).val(pwd);   
        } 
      //选中保存秘密的复选框
        if(loginCode != null &amp;&amp; loginCode != '' &amp;&amp; pwd != null &amp;&amp; pwd != ''){
        $(&quot;[name='checkbox']&quot;).attr(&quot;checked&quot;,&quot;true&quot;);   
       	   checkstate = &quot;1&quot;;
         }else{
         	checkstate = &quot;0&quot;;
      }
 }     

&lt;/script&gt;
&lt;/html&gt;

</code></pre>
]]></content>
    </entry>
</feed>