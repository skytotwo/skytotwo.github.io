<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skytotwo.github.io/</id>
    <title>Totoro の Home</title>
    <updated>2019-09-01T08:50:53.800Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skytotwo.github.io/"/>
    <link rel="self" href="https://skytotwo.github.io//atom.xml"/>
    <subtitle>空杯心态，每天进步</subtitle>
    <logo>https://skytotwo.github.io//images/avatar.png</logo>
    <icon>https://skytotwo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Totoro の Home</rights>
    <entry>
        <title type="html"><![CDATA[使用netflix-proxy达成看netflix视频网站的目的]]></title>
        <id>https://skytotwo.github.io//post/netflix-proxy-setup</id>
        <link href="https://skytotwo.github.io//post/netflix-proxy-setup">
        </link>
        <updated>2019-09-01T08:46:46.000Z</updated>
        <summary type="html"><![CDATA[<p>服务由ab77大神编写，这里稍作整理，需要注意的是，此服务用的是旧版服务，因为新版对python3.6安装存在问题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>服务由ab77大神编写，这里稍作整理，需要注意的是，此服务用的是旧版服务，因为新版对python3.6安装存在问题。</p>
 <!-- more --> 
<h1 id="关于">关于</h1>
<p><code>netflix proxy</code>是一个智能DNS代理，用于'netflix'、'hulu<code>[[n2]]（footnotes）、'hbo now'等流媒体的解锁。它使用Docker容器部署，并使用'dnsmasq</code>[[n18]]（footnotes）和'sniproxy`[[n1]]（footnotes）提供smartdns服务，它适用于一些被屏蔽的网站，如Pornhub和YouTube。</p>
<p>需要注意的是，由于容器不能够在ovz平台上安装（除了ovz7），所以建议使用kvm架构的vps安装此dns解锁服务，此服务建议使用debian系统。</p>
<p>该项目用到了DNS劫持 和 SNI代理。将Netflix的查询请求劫持到中转服务器的IP上，之后通过中转服务器监听443端口的 SNI代理 ，将你的观看请求通过中转服务器处理后发送给Netflix服务器。中转服务器使用SNI代理 ，因此也不会被判断成使用Proxy。</p>
<h1 id="脚本安装">脚本安装</h1>
<blockquote>
<p><code>TL;DR</code></p>
</blockquote>
<p>find a Debian or Ubuntu box with root on a clean public IP and run:</p>
<pre><code>apt-get update\
  &amp;&amp; apt-get -y install vim dnsutils curl sudo\
  &amp;&amp; curl -fsSL https://get.docker.com/ | sh || apt-get -y install docker.io\
  &amp;&amp; mkdir -p ~/netflix-proxy\
  &amp;&amp; cd ~/netflix-proxy\
  &amp;&amp; curl -fsSL https://github.com/skytotwo/netflix-proxy/archive/latest.tar.gz | gunzip - | tar x --strip-components=1\
  &amp;&amp; ./build.sh
</code></pre>
<p><a href="https://dashboard.unzoner.com/sub"><img align="left" src="https://api.unzoner.com/api/v1.0/countries/available/flags.png"></a><br><br></p>
<p>输入之后回车，等待docker的部署，部署完成之后出现下图所示文字：<br>
<img src="http://picture.totoro.site/images/2019/08/22/QQ20190404-2138362x-.png" alt="QQ20190404-2138362x-.png"></p>
<p>可以看到生成了一个登陆网址和用户名密码，用记事本保存。接着登录网页：<br>
<img src="http://picture.totoro.site/images/2019/08/22/QQ20190412-1502162x-.png" alt="QQ20190412-1502162x-.png"></p>
<p>登陆之后点击「Add IP」，添加需要中转的机器的ip（ipv4/6均可），这样我们就完成了中转的配置。</p>
<p>剩下的就是需要中转机器修改dns指向这个安装dns中转服务的机器的ip即可。</p>
<h1 id="支持的服务">支持的服务</h1>
<p>The following are supported out of the box, however adding additional services is trivial and is done by updating <code>dnsmasq.conf</code> file and running <code>docker restart dnsmasq</code>:</p>
<ul>
<li>Netflix</li>
<li>Hulu<a href="#footnotes">[n2]</a></li>
<li>HBO Now</li>
<li>Amazon Instant Video</li>
<li>Crackle</li>
<li>Pandora</li>
<li>Vudu</li>
<li>blinkbox</li>
<li>BBC iPlayer<a href="#footnotes">[n5]</a></li>
<li>NBC Sports and potentially many <a href="https://github.com/skytotwo/netflix-proxy/blob/master/proxy-domains.txt">more</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信支付统一下单失败，返回金额invalid total_fee]]></title>
        <id>https://skytotwo.github.io//post/wechat-invalid-total_fee</id>
        <link href="https://skytotwo.github.io//post/wechat-invalid-total_fee">
        </link>
        <updated>2019-09-01T08:41:55.000Z</updated>
        <summary type="html"><![CDATA[<p>这里是因为微信支付金额是以分为单位的，而支付宝是以元为单位的，这是两者的区别。在下单部分，需要将金额做一下处理，将元转化成分，下面是python的实现：</p>
]]></summary>
        <content type="html"><![CDATA[<p>这里是因为微信支付金额是以分为单位的，而支付宝是以元为单位的，这是两者的区别。在下单部分，需要将金额做一下处理，将元转化成分，下面是python的实现：</p>
<!-- more -->
<pre><code class="language-python">def trans_yuan_to_cent(total_fee):
    &quot;&quot;&quot;微信支付时，需要将元转为分&quot;&quot;&quot;
    total_fee = str(total_fee)
    index = total_fee.find('.')
    length = len(total_fee)

    if index == -1:  # 当不存在小数点时候，也就是分，直接乘以100，这里是加两个0
        fee = int(total_fee + '00')
    elif length - index &gt;= 3:  # 当传入金额待两位小数以上的时候
        fee = int(total_fee[0:index+3].replace('.', ''))
    elif length - index == 2:  # 当传入金额待一位小数时候
        fee = int(total_fee[0:index+2].replace('.', '')+'0')
    else:  # 当传入金额带一个小数点时候
        fee = int(total_fee[0:index+1].replace('.', '')+'00')

    return fee
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于服务器端口转发的两种常见方法]]></title>
        <id>https://skytotwo.github.io//post/linux-resend</id>
        <link href="https://skytotwo.github.io//post/linux-resend">
        </link>
        <updated>2019-09-01T08:36:13.000Z</updated>
        <summary type="html"><![CDATA[<p>很多时候，访问国外服务器时，网络质量是很影响体验的，当我们有一台普通线路的国外服务器，日常使用没有太大要求其实也能满足自身需要，但是如果想要让体验更佳，那就可以尝试使用服务器端口转发。</p>
]]></summary>
        <content type="html"><![CDATA[<p>很多时候，访问国外服务器时，网络质量是很影响体验的，当我们有一台普通线路的国外服务器，日常使用没有太大要求其实也能满足自身需要，但是如果想要让体验更佳，那就可以尝试使用服务器端口转发。</p>
 <!-- more -->
<p>端口转发的原理是用一台国内的服务器来做跳转，利用国内服务器优质的线路，使得访问国外服务器速度更快更稳定。常见的转发有rinetd、Haproxy、iptables、socat，前面2种只能转发TCP，后面TCP/UDP都可以转发，这里介绍iptables、socat，下面来看看两种转发方式。</p>
<h3 id="一-socat转发"><strong>一、socat转发</strong></h3>
<p>一键脚本<br>
脚本说明：脚本默认开启UDP、TCP转发，带开机自启功能，且一次只能转发单个端口，如果想转发多个端口请重复运行本脚本</p>
<p>使用root运行以下命令：</p>
<pre><code class="language-shell">wget https://www.moerats.com/usr/shell/socat.sh &amp;&amp; bash socat.sh
</code></pre>
<p>按要求输入以下信息：</p>
<p>如果你要用本地服务器的3333端口转发IP为1.1.1.1服务器的6666端口，那就依次填入指定参数。<br>
请输入本地端口:3333<br>
请输入远程端口:6666<br>
请输入远程IP:1.1.1.1<br>
输入后直到配置完成</p>
<h3 id="二-iptables转发"><strong>二、iptables转发</strong></h3>
<h4 id="21一键脚本"><strong>2.1一键脚本</strong></h4>
<pre><code class="language-shell">wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubiBackup/skytotwo/master/iptables-pf.sh &amp;&amp; chmod +x iptables-pf.sh &amp;&amp; bash iptables-pf.sh
</code></pre>
<p>下载并运行脚本后，先选择 1. 安装 iptables ，会检测是否安装 iptables 同时也会进行 iptables 防火墙开机启动加载等配置。</p>
<p>使用方法</p>
<pre><code class="language-shell">./iptables-pf.sh
</code></pre>
<p>运行脚本后，会显示菜单：</p>
<pre><code class="language-shell"> iptables 端口转发一键管理脚本 [vx.x.x]
 -- Toyo | doub.io/wlzy-20 --
 
 0. 升级脚本
————————————
 1. 安装 iptables
 2. 清空 iptables 端口转发
————————————
 3. 查看 iptables 端口转发
 4. 添加 iptables 端口转发
 5. 删除 iptables 端口转发
————————————
注意：初次使用前请请务必执行 1. 安装 iptables(不仅仅是安装)
 
 请输入数字 [0-5]:
</code></pre>
<p>选择 4. 添加 iptables 端口转发 后，会提示你依次输入 欲转发IP、欲转发端口、本地监听端口、本地IP、转发类型：</p>
<pre><code class="language-shell">请输入 iptables 欲转发至的 远程端口 [1-65535] (支持端口段 如 2333-6666, 被转发服务器):10000-11000
 
 欲转发端口 : 10000-11000
 
请输入 iptables 欲转发至的 远程IP(被转发服务器):2.2.2.2
 
 欲转发服务器IP : 2.2.2.2
 
请输入 iptables 本地监听端口 [1-65535] (支持端口段 如 2333-6666)
(默认端口: 10000-11000):
 
 本地监听端口 : 10000-11000
 
请输入 本服务器的 公网IP网卡IP(注意是网卡绑定的IP，而不仅仅是公网IP，回车自动检测):
 
 本服务器IP : 1.1.1.1
 
请输入数字 来选择 iptables 转发类型:
 1. TCP
 2. UDP
 3. TCP+UDP
 
(默认: TCP+UDP):
 
——————————————————————————————
 请检查 iptables 端口转发规则配置是否有误 !
 
 本地监听端口 : 10000-11000
 服务器 IP : 2.2.2.2
 
 欲转发的端口 : 10000-11000
 欲转发 IP : 1.1.1.1
 转发类型 : TCP+UDP
——————————————————————————————
</code></pre>
<p>最后会提示你确认配置是否有误，如果没有问题就按任意键继续，启动成功后就会提示：</p>
<pre><code class="language-shell">——————————————————————————————
 iptables 端口转发规则配置完成 !
 
 本地监听端口 : 10000:11000
 服务器 IP : 1.1.1.1
 
 欲转发的端口 : 10000:11000
 欲转发 IP : 2.2.2.2
 转发类型 : TCP+UDP
——————————————————————————————
</code></pre>
<p>选择 3. 查看 iptables 端口转发 后，会显示如下：</p>
<pre><code class="language-shell">当前有 2 个 iptables 端口转发规则。
1. 类型: tcp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000
2. 类型: udp 监听端口: 10000:20000 转发IP和端口: 2.2.2.2:10000-20000
</code></pre>
<p>选择 5. 删除 iptables 端口转发 后，也会显示列表，然后让你选择 要删除的端口转发规则序号。</p>
<p><strong>Shadowsocks客户端说明</strong><br>
假设你的海外服务器(被中转)中搭建的Shadowsocks服务端的IP是 2.2.2.2  ，SS端口是 10000 。</p>
<p>假设中转服务器的IP是 1.1.1.1 ，本地监听端口和SS端口不一致，本地监听端口是 20000 。</p>
<p>那么，你的Shadowsocks客户端，添加Shadowsocks服务器，IP填写 1.1.1.1 ，端口填写 20000 ，其他的 密码/加密方式/协议/混淆等等 全部和原Shadowsocks账号一样！</p>
<p><strong>其他说明</strong><br>
CentOS 7 默认的防火墙是 firewall，要使用本脚本，请先卸载或关闭 firewall 服务器，并安装 iptables 全套软件。</p>
<p>关于国内腾讯云等服务器转发失败解释<br>
国内的很多服务器，例如腾讯云，在VPS网卡上面绑定的都是内网IP，这样的话，如果你用脚本自动检测外网IP，会转发失败，需要在添加转发规则的时候，本服务器IP手动写你的服务器 网卡上面绑定的IP。</p>
<h4 id="22手动添加"><strong>2.2手动添加</strong></h4>
<p>在使用iptables转发流量之前请执行如下命令：</p>
<pre><code class="language-shell">sed -i 's/net.ipv4.ip_forward = 0/net.ipv4.ip_forward = 1/g' /etc/sysctl.conf
sysctl -p
</code></pre>
<p>然后我们清除下所有默认的iptables表：</p>
<pre><code class="language-shell">iptables -F
iptables -t nat -F
service iptables save
</code></pre>
<p>iptables相同端口转发命令：</p>
<pre><code class="language-shell">iptables -t nat -A PREROUTING -p tcp --dport [端口号] -j DNAT --to-destination [目标IP]
iptables -t nat -A PREROUTING -p udp --dport [端口号] -j DNAT --to-destination [目标IP]
iptables -t nat -A POSTROUTING -p tcp -d [目标IP] --dport [端口号] -j SNAT --to-source [中转服务器IP]
iptables -t nat -A POSTROUTING -p udp -d [目标IP] --dport [端口号] -j SNAT --to-source [中转服务器IP]
</code></pre>
<p>不同端口：</p>
<pre><code class="language-shell">iptables -t nat -A PREROUTING -p tcp --dport [源端口号] -j DNAT --to-destination [目标IP:目标端口号]
iptables -t nat -A PREROUTING -p udp --dport [源端口号] -j DNAT --to-destination [目标IP:目标端口号]
iptables -t nat -A POSTROUTING -p tcp -d [目标IP] --dport [目标端口号] -j SNAT --to-source [中转服务器IP]
iptables -t nat -A POSTROUTING -p udp -d [目标IP] --dport [目标端口号] -j SNAT --to-source [中转服务器IP]
</code></pre>
<p><strong>注意：执行完毕后，必须进行保存 请使用 service iptables save 进行保存。</strong></p>
<p>以下是一个实例（这里我们的应用端口为50020~50029，我们使用520022测试转发另外一个IP的6053端口，我们的主IP为：192.168.5.2，转发服务器IP为：1.1.1.1）：</p>
<pre><code class="language-shell">iptables -t nat -A PREROUTING -p tcp --dport 50022 -j DNAT --to-destination 1.1.1.1:6053
iptables -t nat -A PREROUTING -p udp --dport 50022 -j DNAT --to-destination 1.1.1.1:6053
iptables -t nat -A POSTROUTING -p tcp -d 1.1.1.1 --dport 6053 -j SNAT --to-source 192.168.5.2
iptables -t nat -A POSTROUTING -p udp -d 1.1.1.1 --dport 6053 -j SNAT --to-source 192.168.5.2
service iptables save
</code></pre>
<h3 id="三-iptables和socat的优劣"><strong>三、iptables和socat的优劣</strong></h3>
<p>实际体验中iptables会好一点，socat当转发数多了就会炸，推荐使用iptables转发。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一款强大好用的个人图床：chevereto安装教程]]></title>
        <id>https://skytotwo.github.io//post/chevereto-setup</id>
        <link href="https://skytotwo.github.io//post/chevereto-setup">
        </link>
        <updated>2019-09-01T08:27:49.000Z</updated>
        <summary type="html"><![CDATA[<p>说明：chevereto是目前最好的图床之一了。功能也非常强大。其免费版和收费版的区别，在于收费版多了硬盘扩展，社交分享功能和技术支持。硬盘扩展指的是你可以通过sftp等方式把上传的文件储存在其他服务器上。所以个人觉得，这个免费版已经足够使用了。而且chevereto的安装也非常简单，并且支持中文。网上很多教程都写得不是很清楚，这里就发个详细安装教程吧。</p>
]]></summary>
        <content type="html"><![CDATA[<p>说明：chevereto是目前最好的图床之一了。功能也非常强大。其免费版和收费版的区别，在于收费版多了硬盘扩展，社交分享功能和技术支持。硬盘扩展指的是你可以通过sftp等方式把上传的文件储存在其他服务器上。所以个人觉得，这个免费版已经足够使用了。而且chevereto的安装也非常简单，并且支持中文。网上很多教程都写得不是很清楚，这里就发个详细安装教程吧。</p>
 <!-- more --> 
<p>官网：https://chevereto.com/<br>
DEMO：https://demo.chevereto.com/</p>
<p>如下：<br>
<a href="http://picture.totoro.site/image/VWCR"><img src="http://picture.totoro.site/images/2019/04/18/WX20190418-1642542x.png" alt="WX20190418-1642542x.png"></a></p>
<h4 id="安装"><strong>安装</strong></h4>
<p><strong>环境要求：Apache/Nginx、PHP 5.5+、MySQL 5.0+</strong></p>
<h4 id="1-搭建web环境"><strong>1、搭建web环境</strong></h4>
<p>我们可以用lnmp、lamp一键包或者宝塔之类的面板来搭建web环境。<br>
lnmp安装方法可参考：</p>
<pre><code class="language-shell">wget -c http://soft.vpser.net/lnmp/lnmp1.4.tar.gz &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp
</code></pre>
<h3 id="2-上传chevereto程序"><strong>2、上传chevereto程序</strong></h3>
<p>搭建好web环境后，添加网站并解析，再上传chevereto程序到网站目录，chevereto下载地址：https://github.com/Chevereto/Chevereto-Free。<br>
这里以lnmp为例，执行命令：</p>
<pre><code class="language-shell">cd /home/wwwroot/
mkdir chevereto
cd chevereto
wget https://github.com/Chevereto/Chevereto-Free/archive/1.0.9.tar.gz
tar zvxf 1.0.9.tar.gz
</code></pre>
<p>赋权限</p>
<p>再执行非常重要的一步：</p>
<pre><code class="language-shell">chown www:www -R /home/wwwroot/chevereto
</code></pre>
<p><strong>创建settings.php文件</strong></p>
<p>在app目录新建settings.php文件并给予可写入权限:</p>
<pre><code class="language-shell">cd /home/wwwroot/chevereto/app
touch settings.php
chmod -R 777 settings.php
</code></pre>
<p><strong>修改nginx配置文件</strong></p>
<p>修改网站配置文件/usr/local/nginx/conf/nginx.conf,在server中添加以下代码:</p>
<pre><code class="language-shell">location / {
try_files $uri $uri/ /index.php?$query_string;
}
</code></pre>
<p>再将程序根路径指向chevereto文件夹：</p>
<pre><code class="language-shell">root /home/wwwroot/chevereto;
</code></pre>
<p>然后重启Nginx，使用命令:</p>
<pre><code class="language-shell">/etc/init.d/nginx restart
#或
lnmp restart
#或
lnmp nginx restart
</code></pre>
<h3 id="3-生成chevereto图床所需的数据库"><strong>3、生成chevereto图床所需的数据库</strong></h3>
<p>将安装lnmp自动生成的default文件夹中phpmyadmin拷贝到chevereto文件夹里</p>
<pre><code class="language-shell">cp -R /home/wwwroot/default/phpmyadmin /home/wwwroot/chevereto
</code></pre>
<p>浏览器访问http://IP/phpmyadmin, 登录。<br>
新增chevereto数据库<br>
新增chevereto用户，并且赋权限</p>
<h3 id="4-开始安装chevereto"><strong>4、开始安装chevereto</strong></h3>
<p>浏览器访问http://IP/<br>
然后开始填写数据库信息：<br>
<img src="http://picture.totoro.site/images/2019/04/18/chevereto03.png" alt="chevereto03.png"></p>
<p>随后安装成功！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[CentOS重启后resolv.conf被重置的解决方案]]></title>
        <id>https://skytotwo.github.io//post/centos-resolvconf-dns</id>
        <link href="https://skytotwo.github.io//post/centos-resolvconf-dns">
        </link>
        <updated>2019-09-01T08:21:20.000Z</updated>
        <summary type="html"><![CDATA[<p>近期在修改一台CentOS服务器的dns时发现只要重启服务器DNS就会被强制还原，解决方案如下：</p>
]]></summary>
        <content type="html"><![CDATA[<p>近期在修改一台CentOS服务器的dns时发现只要重启服务器DNS就会被强制还原，解决方案如下：</p>
 <!-- more -->
<p><strong>1、首先在网卡设置中修改NM_CONTROLLED的值：</strong><br>
修改文件/etc/sysconfig/network-scripts/ifcfg-eth0的内容：</p>
<pre><code class="language-shell">NM_CONTROLLED=&quot;no&quot;  //是否允许Network Manager管理，设置为no
</code></pre>
<p>默认允许Network Manager管理DNS，所以首先设置为no，然后操作DNS设置</p>
<p><strong>2、设置DNS内容：</strong><br>
修改DNS可以有如下两种方案：</p>
<p>①、修改网卡设置：<br>
在/etc/sysconfig/network-scripts/ifcfg-eth0中修改内容：</p>
<pre><code class="language-shell">PEERDNS=&quot;yes&quot;
DNS1=&quot;xxx.xxx.xxx.xxx&quot;
DNS2=&quot;xxx.xxx.xxx.xxx&quot;
</code></pre>
<p>这种设置方案是以网卡中设置的DNS为主，resolv.conf中按照网卡设置的DNS内容自动生成，以后想修改DNS，必须修改网卡中的设置才不会在服务器重启之后出现DNS设置失效的问题。</p>
<p>②、直接修改/etc/resolv.conf的值：<br>
PS.需要注意的是，若要使直接修改的DNS内容不会在服务器重启之后丢失，需要设置网卡中PEERDNS的值为no：</p>
<pre><code class="language-shell">nameserver xxx.xxx.xxx.xxx
nameserver xxx.xxx.xxx.xxx
</code></pre>
<p><strong>3、修改完毕之后重启网卡：</strong></p>
<pre><code class="language-shell">service network restart
</code></pre>
<p>按照上面任意一种方案修改DNS设置之后都不会出现重启服务器DNS设置复原的情况，适用于dhcp启动的机器。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python面试系统准备]]></title>
        <id>https://skytotwo.github.io//post/python-mianshi</id>
        <link href="https://skytotwo.github.io//post/python-mianshi">
        </link>
        <updated>2019-09-01T07:55:25.000Z</updated>
        <summary type="html"><![CDATA[<p>面试是一门学问，考验的是你的知识储备，临场发挥。对自己心仪的公司面试成功与否很大程度上靠的是对面试准备与否，是否熟悉相应的回答套路等。面试python岗位也是一样。</p>
]]></summary>
        <content type="html"><![CDATA[<p>面试是一门学问，考验的是你的知识储备，临场发挥。对自己心仪的公司面试成功与否很大程度上靠的是对面试准备与否，是否熟悉相应的回答套路等。面试python岗位也是一样。</p>
<!-- more --> 
<h3 id="一-面试流程介绍"><strong>一 面试流程介绍</strong></h3>
<h4 id="11-python后端职位分析"><strong>1.1 python后端职位分析</strong></h4>
<p><strong>职位分析：</strong><br>
<em>招聘信息看什么？</em><br>
1.岗位职责（业务是否感兴趣）<br>
2.职位要求（自己是否掌握，查漏补缺）<br>
3.公司技术栈（公司使用到哪些技术）</p>
<hr>
<p><strong>看招聘描述，挖掘信息</strong><br>
<em>从招聘信息中我们能挖掘到什么？</em><br>
1.你对公司做的业务是否感兴趣<br>
2.职位要求中的知识技能是否掌握，面试有多大概率成功<br>
3.自己还有哪些知识技能需要查漏补缺</p>
<hr>
<p><strong>有的放矢，针对性准备</strong><br>
<em>提升面试成功率</em><br>
1.针对公司的技术栈和要求编写不同的简历<br>
2.表现出对职位和公司业务的兴趣<br>
3.突出自己的技能优势，提升匹配度（技能与公司要求比较符合）</p>
<hr>
<h4 id="12-面试流程与环节"><strong>1.2 面试流程与环节</strong></h4>
<p><strong>后端面试流程</strong><br>
<em>学生重基础，社招重项目</em><br>
1.一面问基础<br>
2.二面问项目<br>
3.三面问设计（设计后端）</p>
<hr>
<p><strong>学生重基础</strong><br>
<em>项目经验少，基础很重要</em><br>
1.学历和成绩<br>
2.大学所学的计算机课程<br>
3.在校项目。实习经验</p>
<hr>
<p><strong>社招重项目</strong><br>
<em>社招重视项目和设计</em><br>
1.参与过哪些项目？有没有知名项目<br>
2.在项目中承担的职责<br>
3.有没有系统设计经验？</p>
<hr>
<p><strong>行为面试</strong><br>
<em>非技术性问题</em><br>
1.自我介绍<br>
2.口头表达能力<br>
3.沟通交流能力</p>
<hr>
<p><strong>HR面试</strong><br>
<em>到这里拿到offer可能就很大啦</em><br>
1.薪资待遇（锚定效应，可以提出比期望薪资稍高的待遇）<br>
2.职业规划<br>
3.自我介绍，沟通交流等</p>
<h4 id="13-python后端技术栈"><strong>1.3 python后端技术栈</strong></h4>
<p><strong>python语言基础</strong><br>
1.语言特点<br>
2.语法基础<br>
3.高级特性</p>
<hr>
<p><strong>算法与数据结构</strong><br>
1.常用算法和数据结构<br>
2.分析时间，空间复杂度<br>
3.实现常见数据结构和算法</p>
<hr>
<p><strong>编程范式</strong><br>
1.面向对象编程<br>
2.常用设计模式<br>
3.函数式编程</p>
<hr>
<p><strong>操作系统</strong><br>
1.常用的linux命令<br>
2.进程，线程<br>
3.内存管理</p>
<hr>
<p><strong>网络编程</strong><br>
1.常用TCP/IP/HTTP协议<br>
2.socket编程基础<br>
3.python并发库</p>
<hr>
<p><strong>数据库</strong><br>
1.mysql常考，索引优化<br>
2.关系型和Nosql的使用场景<br>
3.redis缓存</p>
<hr>
<p><strong>Python web框架</strong><br>
1.常用框架对比，restful<br>
2.wsgi原理<br>
3.web安全问题</p>
<hr>
<p><strong>系统设计</strong><br>
1.设计原则，如何分析<br>
2.后端系统常用组件（缓存、数据库、消息队列等）<br>
3.技术选型和实现（短网址、feed流系统）</p>
<hr>
<p><strong>技术之外，软实力</strong><br>
1.学习能力<br>
2.业务理解能力，沟通交流能力<br>
3.心态</p>
<h4 id="14-python初中级工程师技能要求和面试标准"><strong>1.4 python初中级工程师技能要求和面试标准</strong></h4>
<p><strong>初级工程师</strong><br>
1.扎实的计算机理论基础<br>
2.代码规范，风格良好<br>
3.能在指导下靠谱的完成业务需求</p>
<hr>
<p><strong>中级工程师</strong><br>
1.扎实的计算机基础和丰富的项目经验<br>
2.能独立设计和完成项目需求<br>
3.熟悉常用web组件（缓存、消息队列等），具有一定的系统设计能力</p>
<hr>
<p><strong>软实力</strong><br>
1.具有产品意识，技术引导产品<br>
2.沟通交流能力，团队协作能力<br>
3.技术领导能力和影响力</p>
<hr>
<p><strong>面试造核弹，工作拧螺丝</strong><br>
1.工作内容和业务紧密相关，需要先了解公司是做什么的<br>
2.平台决定成长（业务体量），还是要看公司的规模成都<br>
3.准备面试需要有的放矢，跟职位相匹配才行</p>
<h4 id="15简历书写与自我介绍"><strong>1.5简历书写与自我介绍</strong></h4>
<p><strong>表现出个人优势，突出关键信息</strong><br>
1.基本信息（姓名，学校，学历，联系方式等）<br>
2.职业技能（编程语言，框架，数据库，开发工具等）<br>
3.关键项目经验（承担职责，用到了哪些技术）</p>
<hr>
<p><strong>简历自我评价</strong><br>
1.简历自我评价可有可无<br>
2.最终还是面试官评价<br>
3.如果要写保证尽量内容简介、态度真诚</p>
<hr>
<p><strong>简历加分项</strong><br>
1.知名项目经验<br>
2.技术栈比较匹配<br>
3.开源项目（github、技术博客、linux等）</p>
<hr>
<p><strong>简历需要注意的</strong><br>
1.内容精简，突出重点，一页就好<br>
2.注意格式，推荐用pdf，避免hr打开格式乱掉<br>
3.信息真实，不弄虚作假。技能要与岗位相符</p>
<hr>
<p><strong>自我介绍说什么</strong><br>
1.个人信息<br>
2.掌握的技术，参与过的项目<br>
3.应聘的岗位，表达对该岗位的看法和兴趣<br>
举例：<br>
个人信息：你好我是~~~~~~<br>
工作项目经历：之前就职于~~~，担任什么，参与过~~~，对<s>比较熟悉<br>
求职意向：我希望应聘到这个岗位，</s>~~~~</p>
<hr>
<p><strong>自我介绍的准备</strong><br>
1.早准备<br>
2.准备开场白讲稿，面试前多练习<br>
3.找一个同伴好友模拟面试，消除紧张心理</p>
<h4 id="16行为面试常见问题与回答技巧"><strong>1.6行为面试常见问题与回答技巧</strong></h4>
<p><strong>面试官会根据候选人过去的行为评测其胜任能力</strong><br>
1.理论依据：行为的连贯性，在旧公司是这样，很可能在新公司也会这样<br>
2.人在相似的场景时会倾向于重复以往的行为模式<br>
3.评判人的业务能力，沟通交流能力，语言表达能力，抗压能力等</p>
<hr>
<p><strong>行为面试的套路（需要重点注意，一般就是问简历上的项目）</strong><br>
1.提问方式：说说你曾经~~~<br>
2.说说你做过的这个项目<br>
3.说说你碰到过的技术难题？你是如何解决的？有何收获？</p>
<hr>
<p><strong>star模型（需要按照这个来准备）<br>
1.情景（situation）：什么情景下发生的<br>
2.任务（task）：你是如何明确你的任务的<br>
3.行动（action）：采取了什么样的行动<br>
4.结果（result）：结果怎么样？学到了什么？</strong></p>
<hr>
<p><strong>常见问题：面试官一般会问，你还有什么要问我的吗？</strong><br>
1.你可千万别说没了，直接说没了说明你对这个岗位缺乏了解和兴趣<br>
2.表现出兴趣：问问工作内容（业务），技术栈（用到了什么技术），团队（团队有几个人），项目（这是什么项目，项目在公司的份量等）<br>
3.问自己的感兴趣的一些技术问题，架构问题</p>
<hr>
<p><strong>聊天是个重要的软技能</strong><br>
1.态度真诚，力求真实，不要弄虚作假<br>
2.言简意赅，突出重点，省略细枝末节。适当模拟练习<br>
3.采用STAR模型让回答更有条理</p>
<h3 id="二-python语言基础考察点"><strong>二、python语言基础考察点</strong></h3>
<p>####** 2.1 python语言基础常考题**<br>
<strong>python是静态还是动态类型？是强类型还是弱类型？</strong><br>
1.动态强类型语言（不少人误认为是弱类型）<br>
2.动态还是静态指的是编译器还是运行期确定类型<br>
3.强类型指的是不会发生隐式类型转换<br>
（python属于动态强类型语言）</p>
<hr>
<p><strong>python作为后端语言的优缺点</strong><br>
1.胶水语言，轮子多，应用广泛<br>
2.语言灵活，生产力高<br>
3.（缺点）性能不是很高，代码不是很好维护，python2和3的兼容性问题</p>
<hr>
<p><strong>什么是鸭子类型？</strong><br>
1.关注点在对象的行为，而不是类型（duck typeing）<br>
2.比如file,StringIO,socket都支持read/write方法，都能操作文件<br>
3.实现了相同的魔法方法，一定程度上来说，就是一个类型的，如定义了__iter__魔法方法，就可以用for来迭代</p>
<hr>
<p><strong>什么是monkey patch（猴子补丁）？ 哪些地方用到了？自己如何实现？</strong><br>
1.所谓的monkey patch就是运行时替换<br>
2.比如gevent库需要修改内置的socket<br>
3.form gevent import monkey; maonkey.patch_socket()<br>
(也可以自己实现，也就是运行过程中替换原来的部分功能，实现别的功能)</p>
<hr>
<p><strong>什么是python的自省（Introspection）？</strong><br>
1.运行时判断一个对象的类型的能力<br>
2.python一切皆对象，用type；id；isinstance获取对象类型信息<br>
3.Inspect模块提供了更多获取对象信息的函数</p>
<hr>
<p><strong>列表或者字典生成器</strong><br>
1.比如[i for i in range(10) if i % 2 == 0] 生成0到10 里能被2整除的数<br>
2.一种快速生成list/dict/set的方式，用来替代map/filter<br>
3.（i for i in range(10) if i % 2 == 0）生成的就是生成器</p>
<h4 id="22-python2和3差异"><strong>2.2 python2和3差异</strong></h4>
<p><strong>Python3的改进</strong><br>
1.print变成了函数而不是关键字<br>
2.编码问题。Python3不再有unicode对象，默认str就是unicode<br>
3.除法变化。Python3除号返回浮点数。而不像python2的地板除法<br>
4.优化的super（）直接调用父类的方法<br>
5.高级解包操作 如：a,b,*rest = range(10)<br>
6.限定关键字参数，在方法参数特别多的情况下，可以指定参数，一面搞混def test(a, b, *, c){} test(1,2,c=3)<br>
7.python3重新抛出异常不会丢失原来栈的信息<br>
8.range，zip，map，dict.values都是返回迭代器</p>
<hr>
<p><strong>Python3新增的</strong><br>
1.yield from链接子生成器<br>
2.asyncio内置库，async/await原生协程支持异步编程<br>
3.新的内置库enum,mock,asyncio,ipaddress,concurrent.futures等</p>
<hr>
<p><strong>Python3改进的</strong><br>
1.生成的pyc文件统一放到__pycache__里<br>
2.一些内置库的修改。urllib，selector等<br>
3.性能优化等</p>
<hr>
<p><strong>熟悉一些兼容2/3的工具</strong><br>
1.six模块<br>
2. 2to3等工具转换代码<br>
3. __future__模块</p>
<h4 id="23-python函数常考题"><strong>2.3 python函数常考题</strong></h4>
<p><strong>python如何传参？</strong><br>
1.是传递值还是传递引用呢？都不是。唯一支持的参数传递是共享传参<br>
2.call by object（共享对象），就是形参实参都指向同个对象<br>
3.call by sharing（共享传参），函数形参获得函数实参上各个引用的副本。<br>
4.python里面传递参数都是通过对象引用来传递的，也就是通过传递对象引用，如果操作的是可变对象，就可以直接在原来对象的基础上修改；如果操作的是不可变对象，那就相当于对对象进行一次复制拷贝，每次都不回修改到原来的对象数据。</p>
<hr>
<p>**函数传递中*args，<strong>kwargs含义是什么</strong><br>
1.用来处理可变参数<br>
2.*args被打包成tuple<br>
3.**kwargs被打包成dict（关键字参数要放在最后）</p>
<hr>
<p>####** 2.4 python异常机制常考题**<br>
<strong>什么时候需要捕获异常？</strong><br>
1.网络请求（超时，连接错误）<br>
2.资源访问（权限问题，资源不存在）<br>
3.代码逻辑（越界访问，KeyError）</p>
<hr>
<p><strong>如何自定义自己的异常？为什么需要钉子自己的异常？</strong><br>
1.因为有些业务异常找不到合适的异常来抛。<br>
2.继承Exception实现自定义的异常，不要继承BaseException<br>
3.给异常加上一些附加信息<br>
4.处理一些业务相关的特定异常（raise MyException）</p>
<pre><code class="language-python">#Eg：
Class MyException(Exception):
	Pass
	Try:
		Raise MyException(‘MyException’)
	Except MyException as e:
		Print(e)
</code></pre>
<h4 id="25-python性能剖析与优化gil常考题"><strong>2.5 python性能剖析与优化，GIL常考题</strong></h4>
<p><strong>什么是GIL？</strong><br>
1.Cpython解释器的内存管理并不是线程安全的<br>
2.保护多线程情况下对python对象的访问<br>
3.Cpython使用简单的锁机制避免多个线程同时执行字节码</p>
<hr>
<p><strong>GIL的影响（限制了程序的多喝执行）</strong><br>
1.同一个时间只能有一个线程执行字节码<br>
2.CPU密集程序难以利用多核优势，因为多核为了争抢执行，会互相拥挤争抢，导致白白浪费资源<br>
3.IO期间会释放GIL，所以对IO密集程序影响不大</p>
<hr>
<p><strong>如何规避GIL的影响</strong><br>
1.CPU密集型可以使用多进程+进程池<br>
2.IO密集可以使用多线程/协程（多进程其实系统开销更大，不一定比多线程效率高）<br>
3.使用cpython扩展（转化为c语言来执行）</p>
<hr>
<p><strong>即便有了GIL还要关注线程安全，非原子操作都要注意</strong><br>
<em>（什么操作才是原子的？）</em><br>
1.一个操作如果是一个字节指令可以完成的就是原子的<br>
2.原子的是可以保证线程安全的，因为不是一步到位的话，中间数据还是可能会被其他线程给污染<br>
3.可以使用dis操作来分析字节码</p>
<hr>
<p><strong>使用各种profile工具（内置或第三方）剖析程序性能（了解）</strong><br>
1.二八定律，大部分时间耗时在少量代码上<br>
2.内置的profile/cprofile等工具<br>
3.使用pyflame（uber开源）的火焰图工具</p>
<hr>
<p><strong>服务端性能优化措施，也就是着陆点</strong><br>
<em>注意：Web应用语言不会成为瓶颈</em><br>
1.数据结构与算法优化<br>
2.数据库层：索引优化，慢查询消除，批量操作减少IO，NoSql<br>
3.网络IO：批量操作，pipeline操作减少IO<br>
4.缓存：使用内存数据库redis/memcached<br>
5.异步：asyncio，celery<br>
6.并发：gevent/多线程</p>
<h4 id="26-python生成器与协程"><strong>2.6 python生成器与协程</strong></h4>
<p><strong>什么是生成器（Generator）？</strong><br>
1.生成器就是可以生成值得函数<br>
2.当一个函数里有了yield关键字就成了生成器<br>
3.生成器可以挂起执行并且保持当前执行的状态，也就是说区别于普通函数的return，生成器返回值后，记录了函数执行的状态</p>
<hr>
<p><strong>Python2没有原生的协程，只有基于生成器的协程</strong><br>
1.生成器可以通过yield暂停执行和产出数据<br>
2.同时支持send()向生成器发送数据throw()向生成器抛出异常，如果生成器函数中yield是在一个等式中，这代表着可以send发送数据过去</p>
<hr>
<p><strong>协程的注意点</strong><br>
1.协程需要使用send(None)或者next(coroutine)来预激(prime)才能启动<br>
2.在yield处协程会暂停执行<br>
3.单独的yield会产出值给调用方<br>
4.可以通过coroutine.send(value)来给协程发送值，发送的值会赋值给yield表达式左边的变量value=yield<br>
5.协程执行完成后(再继续调用，没有遇到下一个yield语句)会抛出StopIteration异常</p>
<hr>
<p><strong>Python3原生协程</strong><br>
Python3.5引入async/await支持原生协程，结合asyncio<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215308_653.png" alt="20190403215308_653.png"></p>
<h4 id="37-python单元测试"><strong>3.7 python单元测试</strong></h4>
<p><strong>什么是单元测试？</strong><br>
1.针对程序模块进行正确性检验<br>
2.一个函数，一个类进行验证<br>
3.自底向上保证程序正确性，从一个函数一个类最细粒度来写单元测试</p>
<hr>
<p><strong>为什么要写单元测试？</strong><br>
<em>注意：三无代码不可取（无文档，五注释，无单测）</em><br>
1.保证代码逻辑的正确性<br>
2.单测影响设计，一般来说容易测试的到吗往往是高内聚低耦合的，容易测试的代码质量更好<br>
3.回归测试，防止改一处整个服务整个服务不可用</p>
<hr>
<p><strong>单元测试相关的库</strong><br>
1.nose/pytest比较常用<br>
2.mock模块用来模拟替换网络请求<br>
3.coverage用来统计测试覆盖率<br>
如下测试案例：<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215354_363.png" alt="20190403215354_363.png"></p>
<h3 id="三-python算法与数据结构考察点"><strong>三。python算法与数据结构考察点</strong></h3>
<p>####** 3.1 python常用内置算法与数据结构常考题**<br>
<strong>仔细回想下你用过的哪些内置的算法和数据结构</strong><br>
1.sorted<br>
2.dict，list，set，tuple<br>
具体分类如下图：<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215420_510.png" alt="20190403215420_510.png"></p>
<hr>
<p><strong>collections模块提供了一些内置数据结构的扩展（重要）</strong><br>
1.namedtuple：元组元素命名方式来定义</p>
<pre><code class="language-python">Import collections
Point = collections.namedtuple(‘Point’, ‘x,y’)
p = Point(1,2)
print(p.x)
</code></pre>
<p>2.deque：实现队列</p>
<pre><code class="language-python">de collections.deque()
de.append(1)
de.appendleft(0)
de.pop()
de.popleft()
</code></pre>
<p>3.Counter：Counter类的目的是用来跟踪值出现的次数。它是一个无序的容器类型，以字典的键值对形式存储，其中元素作为key，其计数作为value。计数值可以是任意的Interger（包括0和负数）。Counter类和其他语言的bags或multisets很相似。</p>
<pre><code class="language-python">c = collections.Counter()
c = collections.Counter(‘abcad’)
print(c)
print(c.most_common())
</code></pre>
<p>4.OrderedDict：记住字典添加顺序</p>
<pre><code class="language-python">od = collections.OrderedDict()
od[‘c’] = ‘c’
od[‘a’] = ‘a’
od[‘b’] = ‘b’
print(list(od.keys()))
#[‘c’, ‘a’, ‘b’]
</code></pre>
<p>5.defaultdict：字典具有默认值</p>
<pre><code class="language-python">dd = collections.defaultdict(int)
dd[‘a’]
#0
dd[‘b’] += 1
print(dd)
#defaultdict(int, {‘a’:0, ‘b’:1})
</code></pre>
<hr>
<p><strong>python中dict的底层结构使用的是哈希表</strong><br>
1.为了支持快速查找使用了哈希表作为底层结构<br>
2.哈希表平均查找时间复杂度为O(1)<br>
3.Cpython解释器使用二次探查解决哈希冲突问题<br>
<strong>注意后续延展：<br>
如何解决哈希冲突问题？<br>
探查法，二次计算查找可用的内存块；链接法，同一个内存块做链表链接<br>
哈希表如何扩容的？</strong></p>
<hr>
<p><strong>python中的list和tuple的异同</strong><br>
1.都是线性结构，都支持下表访问<br>
2.都是序列类型，都能进行遍历<br>
3.list是可变对象，tuple是不可变对象，其保存到饿引用不可变<br>
4.list没法作为dict的键，tuple可以（可变对象不可hash）</p>
<hr>
<p><strong>LRUCache，替换掉最近最少使用的对象（redis应用）</strong><br>
1.缓存剔除策略，当缓存空间不够用的时候需要一种方式剔除key<br>
2.常见的有LRU,LFU等<br>
3.LRU通过使用一个循环双端队列不断把最新访问的key放到表头，这样剔除的时候只需要剔除最远处的key就好了<br>
实现如下图：<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215513_205.png" alt="20190403215513_205.png"><br>
4.利用python内置的dict+collections.OrderedDict实现<br>
5.dict用来做k/v键值对的缓存<br>
6.OrderedDict用来实现更新最新最近访问的key<br>
下面是具体代码实现：</p>
<pre><code class="language-python">from collections import OrderedDict


class LRUCache:

    def __init__(self, capacity=128):
        self.od = OrderedDict()
        self.capacity = capacity

    def get(self, key):  # 每次访问更新最新使用的 key
        if key in self.od:
            val = self.od[key]
            self.od.move_to_end(key)
            return val
        else:
            return -1

    def put(self, key, value):  # 更新 k/v
        if key in self.od:
            del self.od[key]
            self.od[key] = value  # 更新 key 到表头
        else:  # insert
            self.od[key] = value
            # 判断当前容量是否已经满了
            if len(self.od) &gt; self.capacity:
                self.od.popitem(last=False)
</code></pre>
<h2 id="32-python面试常考算法排序查找重中之重1常考排序算法冒泡排序快速排序归并排序堆排序2线性查找二分查找等3能独立实现代码手写能够分析时间空间复杂度">####** 3.2 python面试常考算法**<br>
<strong>（排序+查找，重中之重）</strong><br>
1.常考排序算法：冒泡排序，快速排序，归并排序，堆排序<br>
2.线性查找，二分查找等<br>
3.能独立实现代码（手写），能够分析时间空间复杂度<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215550_946.png" alt="20190403215550_946.png"></h2>
<p><strong>排序算法中的稳定性，什么是排序算法的稳定性？</strong><br>
1.相同大小的元素在排序之后依然保持相对位置不变，就是稳定的<br>
2.r[i]=r[j]且r[i]在r[j]之前，排序之后r[i]依然在r[j]之前<br>
3.稳定性对于排序一个复杂结构，并且需要保持原有排序才有意义</p>
<hr>
<p><strong>写出快速排序（步骤，示例）</strong><br>
1.partiton：选择基准分割数组为两个子数组，小于基准和大于基准的<br>
2.对两个子数组分别快排<br>
3.递归合并结果</p>
<pre><code class="language-python">def quicksort(array):
    # 递归出口
    if len(array) &lt; 2:
        return array
    else:
        pivot_index = 0  # 第一个元素作为pivot
        pivot = array[pivot_index]
        less_part = [
            i for i in array[pivot_index+1:] if i &lt;= pivot
        ]
        great_part = [
            i for i in array[pivot_index+1:] if i &gt; pivot
        ]
        return quicksort(less_part) + [pivot] + quicksort(great_part)


def test_quicksort():
    import random
    ll = list(range(10))
    random.shuffle(ll)
    print(ll)
    assert quicksort(ll) == sorted(ll)

test_quicksort()


</code></pre>
<p>写出归并排序，归并两个有序数组<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215626_102.png" alt="20190403215626_102.png"></p>
<pre><code class="language-python">def merge_sorted_list(sorted_a, sorted_b):
    length_a, length_b = len(sorted_a), len(sorted_b)
    a = b = 0
    new_sorted_seq = []

    while a &lt; length_a and b &lt; length_b:
        if sorted_a[a] &lt; sorted_b[b]:
            new_sorted_seq.append(sorted_a[a])
            a += 1
        else:
            new_sorted_seq.append(sorted_b[b])
            b += 1
    if a &lt; length_a:
        new_sorted_seq.extend(sorted_a[a:])
    else:
        new_sorted_seq.extend(sorted_b[b:])
    return new_sorted_seq


def test_merge_sorted_list():
    a = [1, 2, 5]
    b = [0, 3, 4, 8]
    print(merge_sorted_list(a, b))


# 分治法三步走。注意递归出口

def mergesort(array):
    # 递归出口
    if len(array) &lt;= 1:
        return array
    else:
        mid = int(len(array)/2)
        left_half = mergesort(array[:mid])
        right_half = mergesort(array[mid:])
        return merge_sorted_list(left_half, right_half)

def test_mergesort():
    import random
    ll =list(range(10))
    random.shuffle(ll)
    print(ll)
    assert mergesort(ll) == sorted(ll)

test_mergesort()

</code></pre>
<hr>
<p>实现堆排序<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215701_774.png" alt="20190403215701_774.png"></p>
<p>请写出二分查找<br>
递归方式实现二分，注意递归出口<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215743_938.png" alt="20190403215743_938.png"></p>
<pre><code class="language-python">def binary_search(array, target):  # 二分查找
    if not array:
        return -1
    beg, end = 0, len(array)
    while beg &lt; end:
        mid = beg + (end - beg) // 2  # py3
        if array[mid] == target:
            return mid
        elif array[mid] &gt; target:
            end = mid
        else:
            beg = mid + 1
    return -1


def test():
    &quot;&quot;&quot;
    如何设计测试用例：(等价类划分)
    - 正常值功能测试
    - 边界值（比如最大最小，最左最右值）
    - 异常值（比如 None，空值，非法值）
    &quot;&quot;&quot;
    # 正常值，包含有和无两种结果
    assert binary_search([0, 1, 2, 3, 4, 5], 1) == 1
    assert binary_search([0, 1, 2, 3, 4, 5], 6) == -1
    assert binary_search([0, 1, 2, 3, 4, 5], -1) == -1
    # 边界值
    assert binary_search([0, 1, 2, 3, 4, 5], 0) == 0
    assert binary_search([0, 1, 2, 3, 4, 5], 5) == 5
    assert binary_search([0], 0) == 0

    # 异常值
    assert binary_search([], 1) == -1

</code></pre>
<h4 id="33-python数据结构常考题"><strong>3.3 python数据结构常考题</strong></h4>
<p><strong>常考题型</strong><br>
1.常见的数据结构链表，队列，栈，二叉树，堆<br>
2.使用内置结构实现高级数据结构，比如内置的list/deque<br>
实现栈<br>
3.Leetcode或者《剑指offer》上的常见题</p>
<hr>
<p><strong>常考数据结构之链表</strong><br>
<em>（链表有单链表，双链表，循环双端链表）</em><br>
1.如何使用python来表示链表结构<br>
2.实现链表常见操作，比如插入节点，反转链表，合并多个链表等<br>
3.Leetcode联系常见链表题目<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215824_251.png" alt="20190403215824_251.png"></p>
<p>如何实现反转链表（单链表倒置）<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403215858_259.png" alt="20190403215858_259.png"></p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head):
        &quot;&quot;&quot;
        :type head: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        pre = None
        cur = head
        while cur:
            nextnode = cur.next
            cur.next = pre
            pre = cur
            cur = nextnode
        return pre

</code></pre>
<p><strong>常见数据结构之队列</strong><br>
<em>（队列queue是先进先出的结构）</em><br>
1.如何使用python实现队列？<br>
2.实现队列的apend和pop操作，如何做到先进先出<br>
3.使用python的list或者collections.deque实现队列</p>
<hr>
<p><img src="http://picture.totoro.site/images/2019/09/01/20190403215938_353.png" alt="20190403215938_353.png"><br>
实现队列（利用collections.deque）</p>
<pre><code class="language-python"># 实现队列。使用 deque
from collections import deque


class Queue:
    def __init__(self):
        self.items = deque()

    def append(self, val):
        return self.items.append(val)

    def pop(self):
        return self.items.popleft()

    def empty(self):
        return len(self.items) == 0


def test_queue():
    q = Queue()
    q.append(0)
    q.append(1)
    q.append(2)
    print(q.pop())
    print(q.pop())
    print(q.pop())


test_queue()

</code></pre>
<hr>
<p><strong>常考数据结构之栈</strong><br>
<em>（栈stack是后进先出结构）</em><br>
1.如何使用python实现栈？<br>
2.实现栈的push和pop操作，如何做到后进先出的<br>
3.同样也可以用python list 或者collections.deque实现栈</p>
<p>实现一个栈<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220008_449.png" alt="20190403220008_449.png"><br>
思考练习题：如何用两个栈实现队列？实现获取最小值的栈MIniStack</p>
<hr>
<p><strong>常考数据结构之字典与集合</strong><br>
<em>（python dict/set底层都是哈希表）</em><br>
1.哈希表的实现原理，底层其实就是一个数组<br>
2.根据哈希函数快速定位一个元素，平均查找O(1)<br>
3.不断加入元素会引起哈希表重新开辟空间，拷贝之前元素到新数组</p>
<hr>
<p><strong>哈希表如何解决冲突</strong><br>
<em>（链接法和开放寻址法）</em><br>
1.元素key冲突之后使用一个链表填充相同key的元素<br>
2.开放寻址法是冲突之后根据一种方式（二次探查）寻找下一个可用的槽<br>
3.cpython使用的是二次探查</p>
<hr>
<p><strong>常考数据结构之二叉树</strong><br>
<em>（先序，中序，后序遍历）</em><br>
1.先(根)序：先处理根，之后是左子树，然后是右子树<br>
2.中(根)序：先处理左子树，然后是根，然后是右子树<br>
3.后(根)序：先处理左子树，然后是右子树，最后是根</p>
<p><strong>树的遍历方式</strong><br>
先(根)序遍历：<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220045_150.png" alt="20190403220045_150.png"><br>
中序遍历：<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220105_181.png" alt="20190403220105_181.png"><br>
后序遍历：<br>
最后遍历根，上图挪下位置</p>
<hr>
<p><strong>常考数据结构之堆</strong><br>
<em>（堆其实是完全二叉树，有最大堆和最小堆）</em><br>
1.最大堆：对于每个非叶子节点V，V的值都比它的两个孩子大<br>
2.最大堆支持每次pop操作获取最大的元素，最小堆获取最小元素<br>
3.常见问题：用堆来完成topk问题，从海量数字中寻找最大的k个</p>
<p>使用堆解决TOPK问题<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220133_599.png" alt="20190403220133_599.png"></p>
<pre><code class="language-python">import heapq


class TopK:
    &quot;&quot;&quot;获取大量元素 topk 大个元素，固定内存
    思路：
    1. 先放入元素前 k 个建立一个最小堆
    2. 迭代剩余元素：
        如果当前元素小于堆顶元素，跳过该元素（肯定不是前 k 大）
        否则替换堆顶元素为当前元素，并重新调整堆
    &quot;&quot;&quot;

    def __init__(self, iterable, k):
        self.minheap = []
        self.capacity = k
        self.iterable = iterable

    def push(self, val):
        if len(self.minheap) &gt;= self.capacity:
            min_val = self.minheap[0]
            if val &lt; min_val:  # 当然你可以直接 if val &gt; min_val操作，这里我只是显示指出跳过这个元素
                pass
            else:
                heapq.heapreplace(self.minheap, val)  # 返回并且pop堆顶最小值，推入新的 val 值并调整堆
        else:
            heapq.heappush(self.minheap, val)  # 前面 k 个元素直接放入minheap

    def get_topk(self):
        for val in self.iterable:
            self.push(val)
        return self.minheap


def test():
    import random
    i = list(range(1000))  # 这里可以是一个可迭代元素，节省内存
    random.shuffle(i)
    print(i)
    _ = TopK(i, 10)
    print(_.get_topk())  # [990, 991, 992, 996, 994, 993, 997, 998, 999, 995]
test()

</code></pre>
<p>####<strong>3.4 python数据结构常考题之链表</strong><br>
<strong>链表涉及到指针操作较为复杂，容易出错，经常用作考题</strong><br>
1.熟悉链表的定义和常见操作<br>
2.常考题：删除一个链表节点<br>
3.常考题：合并两个有序链表</p>
<p>删除一个链表节点<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220203_664.png" alt="20190403220203_664.png"></p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        &quot;&quot;&quot;
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        &quot;&quot;&quot;
        nextnode = node.next
        after_next_node = node.next.next
        node.val = nextnode.val
        node.next = after_next_node

</code></pre>
<p>合并两个有序链表<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220239_147.png" alt="20190403220239_147.png"></p>
<pre><code class="language-python"># Definition for singly-linked list.
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

class Solution:
    def mergeTwoLists(self, l1, l2):
        &quot;&quot;&quot;
        :type l1: ListNode
        :type l2: ListNode
        :rtype: ListNode
        &quot;&quot;&quot;
        root = ListNode(None)
        cur = root
        while l1 and l2:
            if l1.val &lt; l2.val:
                node = ListNode(l1.val)
                l1 = l1.next
            else:
                node = ListNode(l2.val)
                l2 = l2.next
            cur.next = node
            cur = node
        # l1 或者 l2 可能还有剩余元素
        cur.next = l1 or l2
        return root.next

</code></pre>
<p>####** 3.5 python数据结构常考题之二叉树**<br>
<strong>二叉树涉及到递归和指针操作，常结合递归考察</strong><br>
1.二叉树的操作很多可以用递归的方式解决，不了解递归会比较吃力<br>
2.常考题：二叉树的镜像（反转二叉树）<br>
3.常考题：如何层序遍历二叉树（广度优先）</p>
<p>实现反转二叉树<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220308_411.png" alt="20190403220308_411.png"></p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def invertTree(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: TreeNode
        &quot;&quot;&quot;
        if root:
            root.left, root.right = root.right, root.left
            self.invertTree(root.left)
            self.invertTree(root.right)
        return root

</code></pre>
<p>实现层序遍历二叉树<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220334_351.png" alt="20190403220334_351.png"></p>
<pre><code class="language-python"># Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root):
        &quot;&quot;&quot;
        :type root: TreeNode
        :rtype: List[List[int]]
        &quot;&quot;&quot;
        if not root:  # NOTE: 注意 root 可能为空
            return []
        res = []
        cur_nodes = [root]
        next_nodes = []
        res.append([i.val for i in cur_nodes])  # [3]
        while cur_nodes or next_nodes:
            for node in cur_nodes:
                if node.left:
                    next_nodes.append(node.left)
                if node.right:
                    next_nodes.append(node.right)
            if next_nodes:
                res.append(
                    [i.val for i in next_nodes]
                )

            cur_nodes = next_nodes
            next_nodes = []
        return res

</code></pre>
<h4 id="36-python数据结构常考题之栈与队列"><strong>3.6 python数据结构常考题之栈与队列</strong></h4>
<p>1.熟练掌握用python的list或者collections.deque实现栈和队列<br>
2.常考题：用栈实现队列</p>
<p>使用栈实现队列<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220400_229.png" alt="20190403220400_229.png"></p>
<pre><code class="language-python">from collections import deque

class Stack:
    def __init__(self):
        self.items = deque()

    def push(self, val):
        return self.items.append(val)

    def pop(self):
        return self.items.pop()

    def top(self):  # 返回栈顶值
        return self.items[-1]

    def empty(self):
        return len(self.items) == 0

class MyQueue:

    def __init__(self):
        &quot;&quot;&quot;
        Initialize your data structure here.
        &quot;&quot;&quot;
        self.s1 = Stack()
        self.s2 = Stack()

    def push(self, x):
        &quot;&quot;&quot;
        Push element x to the back of queue.
        :type x: int
        :rtype: void
        &quot;&quot;&quot;
        self.s1.push(x)

    def pop(self):
        &quot;&quot;&quot;
        Removes the element from in front of queue and returns that element.
        :rtype: int
        &quot;&quot;&quot;
        if not self.s2.empty():
            return self.s2.pop()
        while not self.s1.empty():
            val = self.s1.pop()
            self.s2.push(val)
        return self.s2.pop()

    def peek(self):
        &quot;&quot;&quot;
        Get the front element.
        :rtype: int
        &quot;&quot;&quot;
        if not self.s2.empty():
            return self.s2.top()
        while not self.s1.empty():
            val = self.s1.pop()
            self.s2.push(val)
        return self.s2.top()

    def empty(self):
        &quot;&quot;&quot;
        Returns whether the queue is empty.
        :rtype: bool
        &quot;&quot;&quot;
        return self.s1.empty() and self.s2.empty()

def test():
    q = MyQueue()
    q.push(1)
    q.push(2)
    q.push(3)
    print(q.pop())
    print(q.pop())
    print(q.pop())

test()

</code></pre>
<p>####** 3.7 python数据结构常考题之堆**<br>
<strong>堆的常考题基本围绕在合并多个有序（数组/链表）</strong><br>
<em>topk问题</em><br>
1.理解堆的概念，堆是完全二叉树，有最大堆和最小堆<br>
2.会使用python内置的heapq模块实现堆的操作<br>
3.常考题：合并k个有序链表</p>
<p>合并k个有序链表<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220425_531.png" alt="20190403220425_531.png"></p>
<pre><code class="language-python"># Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

from heapq import heapify, heappop
class Solution:
    def mergeKLists(self, lists):
        &quot;&quot;&quot;
        :type lists: List[ListNode]
        :rtype: ListNode
        &quot;&quot;&quot;
        # 读取所有节点值
        h = []
        for node in lists:
            while node:
                h.append(node.val)
                node = node.next
        # 构造一个最小堆
        if not h:
            return None
        heapify(h)  # 转换成最小堆

        # 构造链表
        root = ListNode(heappop(h))
        curnode = root
        while h:
            nextnode = ListNode(heappop(h))
            curnode.next = nextnode
            curnode = nextnode
        return root

</code></pre>
<p>####** 3.8 python字符串常考算法题**<br>
<strong>了解常用的字符串操作</strong><br>
1.python内置了很多字符串操作，比如split，upper，replace等<br>
2.常考题：翻转一个字符串<br>
3.常考题：判断一个数字是否是回文数</p>
<p>翻转一个字符串<br>
（使用的是双端遍历法）<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220503_587.png" alt="20190403220503_587.png"></p>
<pre><code class="language-python">class Solution:
    def reverseString(self, s):
        &quot;&quot;&quot;
        :type s: List[str]
        :rtype: void Do not return anything, modify s in-place instead.
        &quot;&quot;&quot;
        beg = 0
        end = len(s)-1
        while beg &lt; end:
            s[beg], s[end] = s[end], s[beg]
            beg += 1
            end -= 1

</code></pre>
<p>判断一个数字是否是回文数（也是双端遍历）<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220525_534.png" alt="20190403220525_534.png"></p>
<pre><code class="language-python">class Solution:
    def isPalindrome(self, x):
        &quot;&quot;&quot;
        :type x: int
        :rtype: bool
        &quot;&quot;&quot;
        if x &lt; 0:
            return False
        s = str(x)
        beg, end = 0, len(s)-1
        while beg &lt; end:
            if s[beg] == s[end]:
                beg += 1
                end -= 1
            else:
                return False
        return True

def test():
    s = Solution()
    assert s.isPalindrome(121) is True
    assert s.isPalindrome(-1) is False
    assert s.isPalindrome(1) is True
test()

</code></pre>
<h3 id="四编程范式考察点"><strong>四.编程范式考察点</strong></h3>
<p>####** 4.1 面向对象基础及python类常考问题**<br>
<strong>什么是面向对象（oop）</strong><br>
1.把对象作为基本单元，把对象抽象成类（Class），包含成员（属性）和方法<br>
2.数据封装（包含属性和方法），继承（继承父类方法），多态（重写父类方法）<br>
3.python中使用类来实现面向对象</p>
<p><strong>python中如何创建类</strong><br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220557_262.png" alt="20190403220557_262.png"></p>
<hr>
<p><strong>组合和继承，优先使用组合而非继承</strong><br>
1.组合是使用其他的类实例作为自己的一个属性（Has-a的关系）<br>
2.子类继承父类的属性和方法（Is-a 的关系）<br>
3.优先使用组合保持代码简单<br>
使用组合的例子：<br>
课程源码：inherit_combination.py<br>
<img src="http://picture.totoro.site/images/2019/09/01/20190403220624_734.png" alt="20190403220624_734.png"></p>
<hr>
<p><strong>类变量和实例变量的区别</strong><br>
1.类变量由所有实例共享<br>
2.实例变量由实例单独享有，不同实例之间不影响<br>
3.当我们需要在一个类的不同实例之间共享变量的时候使用类变量</p>
<hr>
<p><strong>classmethod/staticmethod的异同</strong><br>
1.都可以通过Class.method()方式使用<br>
2.classmethod第一个参数是cls，可以引用类变量<br>
3.staticmethod使用起来和普通函数一样，只不过放在类里面组织</p>
<hr>
<p><strong>什么是元类，使用场景是什么？</strong><br>
<em>（元类-Meta Class是创建类的类）</em><br>
1.元类允许我们控制类的生成，比如修改类的属性等<br>
2.使用type来定义元类<br>
3.元类最常见的一个使用场景就是ORM框架</p>
<pre><code class="language-python">class Base:
    pass


class Child(Base):
    pass


# 等价定义 注意Base后要加上逗号否则就不是tuple了
SameChild = type('Child', (Base,), {})


# 加上方法
class ChildWithMethod(Base):
    bar = True

    def hello(self):
        print('hello')


def hello(self):
    print('hello')

# 等价定义
ChildWithMethod = type(
    'ChildWithMethod', (Base,), {'bar': True, 'hello': hello}
)


# 元类继承自 type
class LowercaseMeta(type):
    &quot;&quot;&quot; 修改类的属性名称为小写的元类 &quot;&quot;&quot;
    def __new__(mcs, name, bases, attrs):
        lower_attrs = {}
        for k, v in attrs.items():
            if not k.startswith('__'):    # 排除magic method
                lower_attrs[k.lower()] = v
            else:
                lower_attrs[k] = v
        return type.__new__(mcs, name, bases, lower_attrs)


class LowercaseClass(metaclass=LowercaseMeta):  # py3
    BAR = True

    def HELLO(self):
        print('hello')


print(dir(LowercaseClass))  # 你会发现&quot;BAR&quot;和&quot;HELLO&quot;都变成了小写
# 用一个类的实例调用hello方法，我们修改了类定义时候的属性名!!!
LowercaseClass().hello()

</code></pre>
<h4 id="42-装饰器面试常考问题"><strong>4.2 装饰器面试常考问题</strong></h4>
<p><strong>什么是装饰器（Decorator）</strong><br>
1.python中一切皆对象，函数也可以当做参数传递<br>
2.在不修改原函数的情况下，使用装饰器给该函数添加其他功能，有利于代码重用<br>
3.装饰器是接受函数作为参数，添加功能后返回一个新函数的函数（类）<br>
4.python中通过@使用装饰器</p>
<p>编写一个记录函数耗时的装饰器</p>
<pre><code class="language-python">import time


def log_time(func):  # 接受一个函数作为参数
    def _log(*args, **kwargs):
        beg = time.time()
        res = func(*args, **kwargs)
        print('ues time:{}'.format(time.time()-beg))
        return res
    return _log


# @log_time # @装饰器语法糖
def mysleep():
    time.sleep(1)

newsleep = log_time(mysleep)
newsleep()

</code></pre>
<p>如何使用类编写装饰器，以及给装饰器添加参数？（使用__call__魔法函数）</p>
<pre><code class="language-python">import time

class LogTime:

    def __init__(self, use_int=False):
        self.use_int = use_int

    def __call__(self, func):
        def _log(*args, **kwargs):
            beg = time.time()
            res = func(*args, **kwargs)
            if self.use_int:
                print('use time: {}'.format(
                    int(time.time()-beg))
                )
            else:
                print('use time: {}'.format(
                    time.time()-beg)
                )
            return res
        return _log


@LogTime(True)
def mysleep():
    time.sleep(1)


if __name__ == '__main__':
    mysleep()

</code></pre>
<h4 id="43-设计模式创建型模式python应用面试题"><strong>4.3 设计模式：创建型模式python应用面试题</strong></h4>
<p><strong>常见的创建型设计模式</strong><br>
1.工厂模式(Factory)：解决对象创建问题（重点）<br>
2.构造模式(Builder)：控制复杂对象的创建（重点）<br>
3.原型模式(Prototype):通过原型的克隆创建新的实例<br>
4.单例模式(Borg/Singleton)：一个类只能有一个实例，只能创建同一个对象（重点）<br>
5.对象池模式(Pool)：预先分配同一类型的一组实例<br>
6.惰性计算模式(Lazy Evaluation)：延迟计算(python 的property)</p>
<hr>
<p><strong>工厂模式</strong><br>
<em>什么是工厂模式（Factory）</em><br>
1.解决对象创建问题<br>
2.解耦对象的创建和使用<br>
3。包括工厂方法和抽象工厂</p>
<hr>
<p><strong>构造模式</strong><br>
<em>什么是构造模式（Builder）</em><br>
1.用来控制复杂对象的构造<br>
2.创建和表示分离，比如你要买电脑。工厂模式直接给你电脑，但构造模式允许你自定义电脑的配置，组装完成后给你</p>
<hr>
<p><strong>原型模式</strong><br>
<em>什么是原型模式（Prototype）</em><br>
1.通过克隆原型来创建新的实例<br>
2.可以使用相同的原型，通过修改部分属性来创建新的实例<br>
3.用途：对于一些创建实例开销比较大的地方可以使用原型模式</p>
<hr>
<p><strong>单例模式</strong><br>
单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。<br>
单例模式的实现有很多方式：<br>
<strong>new</strong>()在__init__()之前被调用，用于生成实例对象。利用这个方法和类的属性的特点可以实现设计模式的单例模式。单例模式是指创建唯一对象，单例模式设计的类只能实例 （这个绝对常考啊.绝对要记住1~2个方法,当时面试官是让手写的）<br>
1.使用__new__方法</p>
<pre><code class="language-python">class Singleton(object):
    def __new__(cls, *args, **kw):
        if not hasattr(cls, '_instance'):
            orig = super(Singleton, cls)
            cls._instance = orig.__new__(cls, *args, **kw)
        return cls._instance
class MyClass(Singleton):
    a = 1
</code></pre>
<p>2.共享属性<br>
创建实例时把所有实例的__dict__指向同一个字典,这样它们具有相同的属性和方法.</p>
<pre><code class="language-python">class Borg(object):
    _state = {}
    def __new__(cls, *args, **kw):
        ob = super(Borg, cls).__new__(cls, *args, **kw)
        ob.__dict__ = cls._state
        return ob
class MyClass2(Borg):
    a = 1
</code></pre>
<p>3.装饰器版本</p>
<pre><code class="language-python">def singleton(cls):
    instances = {}
    def getinstance(*args, **kw):
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance
@singletonclass 
MyClass:
  ...
</code></pre>
<p>4.import方法<br>
作为python的模块是天然的单例模式</p>
<pre><code class="language-python"># mysingleton.pyclass 
My_Singleton(object):
    def foo(self):
        pass

my_singleton = My_Singleton()
# to usefrom mysingleton 
import my_singleton
my_singleton.foo()
</code></pre>
<p>5.共享同一个实例的方法<br>
源码：</p>
<pre><code class="language-python"># 一个工厂方法的例子
class DogToy:
    def speak(self):
        print(&quot;wang wang&quot;)


class CatToy:
    def speak(self):
        print(&quot;miao miao&quot;)


def toy_factory(toy_type):
    if toy_type == 'dog':
        return DogToy()
    elif toy_type == 'cat':
        return CatToy()


# 一个构造模式的例子
class Computer:
    def __init__(self, serial_number):
        self.serial = serial_number
        self.memory = None      # in gigabytes
        self.hdd = None         # in gigabytes
        self.gpu = None

    def __str__(self):
        info = ('Memory: {}GB'.format(self.memory),
                'Hard Disk: {}GB'.format(self.hdd),
                'Graphics Card: {}'.format(self.gpu))
        return '\n'.join(info)


class ComputerBuilder:
    def __init__(self):
        self.computer = Computer('AG23385193')

    def configure_memory(self, amount):
        self.computer.memory = amount

    def configure_hdd(self, amount):
        self.computer.hdd = amount

    def configure_gpu(self, gpu_model):
        self.computer.gpu = gpu_model


class HardwareEngineer:
    def __init__(self):
        self.builder = None

    def construct_computer(self, memory, hdd, gpu):
        self.builder = ComputerBuilder()
        [step for step in (self.builder.configure_memory(memory),
                        self.builder.configure_hdd(hdd),
                        self.builder.configure_gpu(gpu))]

    @property
    def computer(self):
        return self.builder.computer

# 使用buidler，可以创建多个builder类实现不同的组装方式
engineer = HardwareEngineer()
engineer.construct_computer(hdd=500, memory=8, gpu='GeForce GTX 650 Ti')
computer = engineer.computer
print(computer)


# 单例模式
class Singleton:
    def __new__(cls, *args, **kwargs):
        if not hasattr(cls, '_instance'):
            _instance = super().__new__(cls, *args, **kwargs)
            cls._instance = _instance
        return cls._instance


class MyClass(Singleton):
    pass

c1 = MyClass()
c2 = MyClass()
assert c1 is c2  # 单例的，c1 c2 同一个实例

</code></pre>
<h4 id="44-设计模式结构型模式python应用面试题"><strong>4.4 设计模式：结构型模式python应用面试题</strong></h4>
<p><strong>常见结构型设计模式</strong><br>
1.装饰器模式(Decorator)：无需子类化扩展对象功能 （重要）<br>
2.代理模式(Proxy)：把一个对象的操作代理到另一个对象（重要）<br>
3.适配器模式(Adapter)：通过一个间接层适配统一接口（重要）<br>
4.外观模式(Facade)：简化复杂对象的访问问题<br>
5.享元模式(Flyweight)：通过对象复用(池)改善资源利用，比如连接池<br>
6.MVC模式(Model-View-Controller)：解耦展示逻辑和业务逻辑 （重要）</p>
<hr>
<p><strong>代理模式</strong><br>
<em>什么是代理模式（Proxy）</em><br>
1.把一个对象的操作代理到另一个对象<br>
2.这里又要提到之前实现的Stack/Queue，把操作代理到deque<br>
3.通常使用has-a组合关系<br>
4.可用作校验用途</p>
<pre><code class="language-python">from collections import deque

class Stack(object):  # 使用组合的例子

    def __init__(self):
        self._deque = deque()   # has a deque()

    def push(self, value):
        return self._deque.append(value)

    def pop(self):
        return self._deque.pop()

    def empty(self):
        return len(self._deque) == 0

    def __iter__(self):
        res = []
        for i in self._deque:
            res.append(i)
        for i in reversed(res):
            yield i

s = Stack()
s.push(1)
s.push(2)
for i in s:
    print(i)

</code></pre>
<hr>
<p><strong>适配器模式</strong><br>
<em>什么是适配器模式（Adapter）</em><br>
1.把不同对象的接口适配到同一接口<br>
2.想象一个多功能充电头，可以给不同的电器充电，充当了适配器<br>
3.当我们需要给不同的对象统一接口</p>
<pre><code class="language-python"># 适配器模式的例子
class Dog(object):
    def __init__(self):
        self.name = &quot;Dog&quot;

    def bark(self):
        return &quot;woof!&quot;


class Cat(object):
    def __init__(self):
        self.name = &quot;Cat&quot;

    def meow(self):
        return &quot;meow!&quot;


class Adapter:
    def __init__(self, obj, **adapted_methods):
        &quot;&quot;&quot;We set the adapted methods in the object's dict&quot;&quot;&quot;
        self.obj = obj
        self.__dict__.update(adapted_methods)

    def __getattr__(self, attr):
        &quot;&quot;&quot;All non-adapted calls are passed to the object&quot;&quot;&quot;
        return getattr(self.obj, attr)


objects = []
dog = Dog()
objects.append(Adapter(dog, make_noise=dog.bark))
cat = Cat()
objects.append(Adapter(cat, make_noise=cat.meow))
for obj in objects:
    print(&quot;A {0} goes {1}&quot;.format(obj.name, obj.make_noise()))

</code></pre>
<h4 id="45-设计模式行为型模式python应用面试题"><strong>4.5 设计模式：行为型模式python应用面试题</strong></h4>
<p><strong>常见行为型设计模式</strong><br>
1.迭代器模式(Iterator)：通过统一的接口迭代对象<br>
2.观察者模式(Observer)：对象发生改变的时候，观察者执行相应动作（常见订阅模式，事先订阅监听）<br>
3.策略模式(Strategy)：针对不同规模输入使用不同的策略</p>
<hr>
<p><strong>迭代器模式</strong><br>
<em>迭代器模式(Iterator)</em><br>
1.python内置对迭代器模式的支持<br>
2.比如我们可以用for遍历各种Iterable的数据类型<br>
3.python里可以实现__next__和__iter__实现迭代器</p>
<hr>
<p><strong>观察者模式</strong><br>
1.发布订阅是一种最常用的实现方式<br>
2.发布订阅用于解耦逻辑<br>
3.可以通过回调等方式实现，当发生事件时，调用相应的回调函数</p>
<hr>
<p><strong>策略模式</strong><br>
<em>策略模式（Strategy）</em><br>
1.根据不同的输入采用不同的策略<br>
2.比如买东西超过10个打八折，超过20个打七折<br>
3.对外暴露统一的接口，内部采用不同的策略计算</p>
<pre><code class="language-python"># 发布订阅模式

class Publisher:  # 发布者
    def __init__(self):
        self.observers = []  # 观察者

    def add(self, observer):  # 加入观察者
        if observer not in self.observers:
            self.observers.append(observer)
        else:
            print('Failed to add : {}').format(observer)

    def remove(self, observer):  # 移除观察者
        try:
            self.observers.remove(observer)
        except ValueError:
            print('Failed to remove : {}').format(observer)

    def notify(self):   # 调用观察者的回调
        [o.notify_by(self) for o in self.observers]


class Formatter(Publisher):  # 继承自发布者
    def __init__(self, name):
        super().__init__()
        self.name = name
        self._data = 0

    @property
    def data(self):
        return self._data

    @data.setter
    def data(self, new_value):
        self._data = int(new_value)
        self.notify()    # data 在被合法赋值以后会执行notify


class BinaryFormatter:
    &quot;&quot;&quot; 订阅者 &quot;&quot;&quot;

    def notify_by(self, publisher):
        print(&quot;{}: '{}' has now bin data = {}&quot;.format(
            type(self).__name__,
            publisher.name,
            bin(publisher.data))
        )

def test():
    df = Formatter('formatter') # 发布者
    bf = BinaryFormatter()  # 订阅者
    df.add(bf)  # 添加订阅者
    df.data = 3  # 设置的时候调用订阅者的notify_by


# 策略模式

class Order:
    def __init__(self, price, discount_strategy=None):
        self.price = price
        self.discount_strategy = discount_strategy

    def price_after_discount(self):
        if self.discount_strategy:
            discount = self.discount_strategy(self)
        else:
            discount = 0
        return self.price - discount

    def __repr__(self):
        fmt = &quot;&lt;Price: {}, price after discount: {}&gt;&quot;
        return fmt.format(
            self.price, self.price_after_discount()
        )


def ten_percent_discount(order):
    return order.price * 0.10


def on_sale_discount(order):
    return order.price * 0.25 + 20


def main():
    order0 = Order(100)
    order1 = Order(100, discount_strategy=ten_percent_discount)
    order2 = Order(1000, discount_strategy=on_sale_discount)
    print(order0)
    print(order1)
    print(order2)

</code></pre>
<h4 id="46-python函数式编程常考题"><strong>4.6 python函数式编程常考题</strong></h4>
<p><strong>python支持部分函数式编程特性</strong><br>
1.把电脑的运算视作数学上的函数计算（lambda演算）<br>
2.高阶函数：map/reduce/filter<br>
3.无副作用，相同的参数调用始终产生同样的结果</p>
<hr>
<p><strong>什么是闭包(Closure)？</strong><br>
1.绑定了外部作用域的变量的函数<br>
2.即使程序离开外部作用域，如果闭包仍然可见，绑定变量不会被销毁<br>
3.每次运行外部函数都会重新创建闭包</p>
<h3 id="五-操作系统考察点"><strong>五 操作系统考察点</strong></h3>
<p>####** 5.1面试常考linux命令**<br>
<strong>为什么要学linux？</strong><br>
<em>（大部分企业应用跑在linux server上）</em><br>
1.熟练在linux服务器上操作<br>
2.了解linux工作原理和常用工具<br>
3.需要了解查看文件，进程，内存相关的一些命令，用来调试和排查</p>
<hr>
<p><strong>如何查询linux命令</strong><br>
1.使用man命令查询用法。但是man手册比较晦涩<br>
2.使用工具自带的help，比如pip --help<br>
3.这里介绍一个man的替代工具tldr。pip install tldr</p>
<hr>
<p><strong>文件/目录操作命令</strong><br>
<em>（掌握常见的文件操作工具）</em><br>
1.chown/chmod/chgrp<br>
2.ls/rm/cd/cp/mv/touch/rename/ln(软链接和硬链接等)<br>
3.locate/find/grep 定位查找和搜索</p>
<hr>
<p><strong>文件查看</strong><br>
<em>（文件或者日志查看工具）</em><br>
1.编辑器 vi/nano<br>
2.cat/head/tail 查看文件<br>
3.more/less 交互式查看文件</p>
<hr>
<p><strong>进程操作命令</strong><br>
1.ps 查看进程（ps -ef|grep tomcat）<br>
2.kill -9 杀死进程<br>
3.top/htop 监控进程</p>
<hr>
<p><strong>内存操作命令</strong><br>
1.free 查看可用内存<br>
2.了解每一列的具体含义<br>
3.排查内存泄露问题</p>
<hr>
<p><strong>掌握常见的网络工具</strong><br>
1.ifconfig 查看网卡信息<br>
2.lsof/netstat 查看端口信息<br>
3.ssh/scp远程登录/复制。tcpdump抓包</p>
<hr>
<p><strong>掌握常见用户和组的操作</strong><br>
1.useradd/usermod<br>
2.groupadd/groupmod</p>
<h4 id="52-操作系统线程和进程常考面试题"><strong>5.2 操作系统线程和进程常考面试题</strong></h4>
<p><strong>进程和线程对比</strong><br>
1.进程是对运行时程序的封装，是系统资源调度和分配的基本单位<br>
2.线程是进程的子任务，cpu调度和分配的基本单位，实现进程内并发（python同一时间内只能执行一个线程，无法利用多核的优势，所以还是cpu不断切换线程并发执行）<br>
3.一个进程可以包含多个线程，线程依赖进程存在，并共享进程内存</p>
<hr>
<p><strong>python哪些操作是线程安全的？</strong><br>
1.一个操作可以在多线程环境中安全使用，获取正确的结果<br>
2.线程安全的操作好比线程是顺序执行的而不是并发执行的，达到线程隔离<br>
3.非原子性操作的线程容易使得数据变得不安全<br>
4.一般如果涉及到写操作需要考虑如何让多个线程安全的访问数据</p>
<hr>
<p><strong>线程同步的方式</strong><br>
1.互斥量（锁）：通过互斥机制防止多个线程同时访问公共资源<br>
2.信号量（Semphare）：控制同一时刻多个线程访问同一个资源的线程数<br>
3.事件（信号）：通过通知的方式保持线程同步（使用较少）</p>
<hr>
<p><strong>进程间通信的方式</strong><br>
1.管道/匿名管道/有名管道(pipe)<br>
2.信号(Signal)：比如用户使用Ctrl+c产生SIGINT程序终止信号<br>
3.消息队列(Message)<br>
4.共享内存(share memory)<br>
5.信号量(Semaphore)<br>
6.套接字(Socket)：最常用的方式</p>
<hr>
<p><strong>python中如何使用多线程</strong><br>
<em>（threading模块）</em><br>
1.threading.Thread类用来创建线程<br>
2.start()方法启动线程<br>
3.可以用join()等待线程结束</p>
<hr>
<p><strong>python中如何使用多进程</strong><br>
<em>（python有GIL，可以使用多进程实现cpu密集程序）</em><br>
1.multiprocessing多进程模块<br>
2.multiprocessing.Process类实现多进程<br>
3.一般用在cpu密集程序里，避免GIL的影响<br>
课程源码-多进程：multiprocess_test.py</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python中的单例模式]]></title>
        <id>https://skytotwo.github.io//post/python-singelton</id>
        <link href="https://skytotwo.github.io//post/python-singelton">
        </link>
        <updated>2019-09-01T07:50:50.000Z</updated>
        <summary type="html"><![CDATA[<p>单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p>
]]></summary>
        <content type="html"><![CDATA[<p>单例模式（Singleton Pattern）是一种常用的软件设计模式，该模式的主要目的是确保某一个类只有一个实例存在。当你希望在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p>
<!-- more -->
<h3 id="单例模式">单例模式</h3>
<p>比如，某个服务器程序的配置信息存放在一个文件中，客户端通过一个 AppConfig 的类来读取配置文件的信息。如果在程序运行期间，有很多地方都需要使用配置文件的内容，也就是说，很多地方都需要创建 AppConfig 对象的实例，这就导致系统中存在多个 AppConfig 的实例对象，而这样会严重浪费内存资源，尤其是在配置文件内容很多的情况下。事实上，类似 AppConfig 这样的类，我们希望在程序运行期间只存在一个实例对象。</p>
<p>在 Python 中，我们可以用多种方法来实现单例模式：</p>
<ul>
<li>使用模块</li>
<li>使用 <strong>new</strong></li>
<li>使用装饰器（decorator）</li>
<li>使用元类（metaclass）</li>
</ul>
<h4 id="使用模块"><strong>使用模块</strong></h4>
<p>其实，Python 的模块就是天然的单例模式，因为模块在第一次导入时，会生成 .pyc 文件，当第二次导入时，就会直接加载 .pyc 文件，而不会再次执行模块代码。因此，我们只需把相关的函数和数据定义在一个模块中，就可以获得一个单例对象了。如果我们真的想要一个单例类，可以考虑这样做：</p>
<pre><code class="language-python"># mysingleton.py
class My_Singleton(object):
    def foo(self):
        pass

my_singleton = My_Singleton()
</code></pre>
<p>将上面的代码保存在文件 mysingleton.py 中，然后这样使用：</p>
<pre><code class="language-python">from mysingleton import my_singleton

my_singleton.foo()
</code></pre>
<h4 id="使用-new"><strong>使用 <strong>new</strong></strong></h4>
<p>为了使类只能出现一个实例，我们可以使用 <strong>new</strong> 来控制实例的创建过程，代码如下：</p>
<pre><code class="language-python">class Singleton(object):
    _instance = None
    def __new__(cls, *args, **kw):
        if not cls._instance:
            cls._instance = super(Singleton, cls).__new__(cls, *args, **kw)  
        return cls._instance  

class MyClass(Singleton):  
    a = 1
</code></pre>
<p>在上面的代码中，我们将类的实例和一个类变量 _instance 关联起来，如果 cls._instance 为 None 则创建实例，否则直接返回 cls._instance。</p>
<p>执行情况如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; one = MyClass()
&gt;&gt;&gt; two = MyClass()
&gt;&gt;&gt; one == two
True
&gt;&gt;&gt; one is two
True
&gt;&gt;&gt; id(one), id(two)
(4303862608, 4303862608)
</code></pre>
<h4 id="使用装饰器"><strong>使用装饰器</strong></h4>
<p>我们知道，装饰器（decorator）可以动态地修改一个类或函数的功能。这里，我们也可以使用装饰器来装饰某个类，使其只能生成一个实例，代码如下：</p>
<pre><code class="language-python">from functools import wraps

def singleton(cls):
    instances = {}
    @wraps(cls)
    def getinstance(*args, **kw):
        if cls not in instances:
            instances[cls] = cls(*args, **kw)
        return instances[cls]
    return getinstance

@singleton
class MyClass(object):
    a = 1
</code></pre>
<p>在上面，我们定义了一个装饰器 singleton，它返回了一个内部函数 getinstance，该函数会判断某个类是否在字典 instances 中，如果不存在，则会将 cls 作为 key，cls(*args, **kw) 作为 value 存到 instances 中，否则，直接返回 instances[cls]。</p>
<h4 id="使用-metaclass"><strong>使用 metaclass</strong></h4>
<p>元类（metaclass）可以控制类的创建过程，它主要做三件事：</p>
<ol>
<li>拦截类的创建</li>
<li>修改类的定义</li>
<li>返回修改后的类<br>
使用元类实现单例模式的代码如下：</li>
</ol>
<pre><code class="language-python">class Singleton(type):
    _instances = {}
    def __call__(cls, *args, **kwargs):
        if cls not in cls._instances:
            cls._instances[cls] = super(Singleton, cls).__call__(*args, **kwargs)
        return cls._instances[cls]

# Python2
class MyClass(object):
    __metaclass__ = Singleton

# Python3
# class MyClass(metaclass=Singleton):
#    pass
</code></pre>
<h4 id="小结"><strong>小结</strong></h4>
<p><strong>Python 的模块是天然的单例模式，这在大部分情况下应该是够用的，当然，我们也可以使用装饰器、元类等方法</strong></p>
<p>转载至：http://python.jobbole.com/87294/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搭建SS/SSR服务]]></title>
        <id>https://skytotwo.github.io//post/ss-and-ssr</id>
        <link href="https://skytotwo.github.io//post/ss-and-ssr">
        </link>
        <updated>2019-08-26T14:46:33.000Z</updated>
        <content type="html"><![CDATA[<p>系统为centos7 ，xshell用root用户远程登录，进入root目录下，然后做如下操作。</p>
<h4 id="一-搭建ss"><strong>一、搭建SS</strong></h4>
<p>输入三行代码：</p>
<pre><code class="language-shell">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh
chmod +x shadowsocks.sh
./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log
</code></pre>
<p>按提示输入密码、端口、加密方式，（加密方式建议选 7；端口默认 443，建议改成 1000~10000）。</p>
<p>等待安装完成，即可获得 SS 账号信息（IP，密码，端口，加密方式）。</p>
<h4 id="二-搭建ssr免流"><strong>二、搭建SSR（免流）</strong></h4>
<p>如果安装了SS，就不需要再安装SSR了，如果要改装SSR，请按照上一部分内容的教程先卸载SS！！！</p>
<p><strong>1.下载一键搭建SSR脚本（只需要执行一次，卸载SSR后也不需要重新执行）</strong><br>
如果服务器没有安装git，执行如下命令安装git：</p>
<pre><code class="language-shell">centos：
sudo yum install git
</code></pre>
<pre><code class="language-shell">git clone https://github.com/flyzy2005/ss-fly，此步骤与一键搭建ss一致，就是clone一键脚本代码。
</code></pre>
<p><strong>2.运行搭建SSR脚本代码</strong></p>
<pre><code class="language-shell">ss-fly/ss-fly.sh -ssr
</code></pre>
<p>全部结束后，看到如下就说明安装成功了：</p>
<pre><code class="language-shell">Congratulations, ShadowsocksR server install completed!
Your Server IP        :你的服务器ip
Your Server Port      :你的端口
Your Password         :你的密码
Your Protocol         :你的协议
Your obfs             :你的混淆
Your Encryption Method:your_encryption_method
 
Welcome to visit:https://shadowsocks.be/9.html
Enjoy it!
</code></pre>
<p><strong>3.注意：</strong><br>
加密方式（method）选择aes-256-cfb；混淆方式（obfs）选择http_simple；协议（protocol）选择auth_sha1_v4。</p>
<p><strong>4.相关操作SSR命令</strong></p>
<pre><code class="language-shell">启动：/etc/init.d/shadowsocks start
停止：/etc/init.d/shadowsocks stop
重启：/etc/init.d/shadowsocks restart
状态：/etc/init.d/shadowsocks status

配置文件路径：/etc/shadowsocks.json
日志文件路径：/var/log/shadowsocks.log
代码安装目录：/usr/local/shadowsocks
</code></pre>
<p><strong>5.卸载SSR服务</strong></p>
<pre><code class="language-shell">./shadowsocksR.sh uninstall
</code></pre>
<h4 id="三-安装bbr加速"><strong>三、安装bbr加速</strong></h4>
<p>锐速已经停更，对于新的系统内核支持有限，建议改用谷歌的开源方案：Google BBR 对 SS 进行优化加速。效果都差不多的。</p>
<p>逐行执行下面命令安装 BBR。</p>
<pre><code class="language-shell">wget — no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh
chmod +x bbr.sh
./bbr.sh
</code></pre>
<p>显示 “Press any key to start…” 按回车确认。</p>
<p>安装完后，按提示重启 VPS，输入 Y 回车重启。稍候 1min 等待重启完成，再重新连接 Xshell。</p>
<p>重启后输入 lsmod | grep bbr ，出现 tcp_bbr 即说明 BBR 已经启动。</p>
<h4 id="四-配置shadowsocks配置文件"><strong>四、配置shadowsocks配置文件</strong></h4>
<p>进入到etc目录下执行：</p>
<pre><code class="language-shell">vi shadowsocks.json
</code></pre>
<p>编辑配置文件如下：</p>
<pre><code class="language-shell">{
    &quot;server&quot;:&quot;0.0.0.0&quot;,
    &quot;server_ipv6&quot;:&quot;[::]&quot;,
    &quot;local_address&quot;:&quot;127.0.0.1&quot;,
    &quot;local_port&quot;:1080,
    &quot;port_password&quot;:{
        &quot;1088&quot;:&quot;**********&quot;,
        &quot;8080&quot;:&quot;**********&quot;,
        &quot;80&quot;:&quot;***********&quot;
    },
    &quot;timeout&quot;:120,
    &quot;method&quot;:&quot;aes-256-cfb&quot;,
    &quot;protocol&quot;:&quot;auth_sha1_v4&quot;,
    &quot;protocol_param&quot;:&quot;&quot;,
    &quot;obfs&quot;:&quot;http_simple&quot;,
    &quot;obfs_param&quot;:&quot;&quot;,
    &quot;redirect&quot;:&quot;&quot;,
    &quot;dns_ipv6&quot;:false,
    &quot;fast_open&quot;:false,
    &quot;workers&quot;:1
}

</code></pre>
<p>这个是多端口的配置，因为涉及到后面要免流，联通的话需要开8080和80端口。</p>
<h4 id="五-开启防火墙端口使用iptables"><strong>五、开启防火墙端口（使用iptables）</strong></h4>
<p>在旧版本的CentOS中，是使用 iptables 命令来设置防火墙的。但是，从CentOS7开始，默认就没有安装iptables，而是改用firewall来配置防火墙。</p>
<p><strong>1.CentOS7更改为iptables防火墙</strong><br>
CentOS7切换到iptables防火墙，首先应该关闭默认的firewall防火墙并禁止自启动，然后再来安装和启动iptables防火墙。</p>
<p>操作步骤如下：</p>
<pre><code class="language-shell">systemctl stop firewalld
# 停止firewall

systemctl disable firewalld
# 禁止firewall的开机自启动

yum install iptables-services
# 安装iptables

systemctl start iptables
# 开启iptables

systemctl enable iptables
# 启用iptables的自启动
</code></pre>
<p>之后，就可以在CentOS7中使用iptables配置防火墙。</p>
<p><strong>2.开启shadowsocks.json配置的端口，这样外面才能访问</strong><br>
进入/etc/sysconfig/</p>
<pre><code class="language-shell">cd /etc/sysconfig
</code></pre>
<p>执行</p>
<pre><code class="language-shell">vi iptables
</code></pre>
<p>按i进行插入开放端口命令</p>
<pre><code class="language-shell">-A INPUT -p udp -m state --state NEW -m udp --dport 1088 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 1088 -j ACCEPT
-A INPUT -p udp -m state --state NEW -m udp --dport 8080 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT
-A INPUT -p udp -m state --state NEW -m udp --dport 80 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT
</code></pre>
<p>最后如下：</p>
<pre><code class="language-shell"># Generated by iptables-save v1.4.21 on Tue Dec 18 03:38:00 2018
*filter
:INPUT ACCEPT [0:0]
:FORWARD ACCEPT [0:0]
:OUTPUT ACCEPT [113:31400]
-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT
-A INPUT -p icmp -j ACCEPT
-A INPUT -i lo -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT
-A INPUT -p udp -m state --state NEW -m udp --dport 1088 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 1088 -j ACCEPT
-A INPUT -p udp -m state --state NEW -m udp --dport 8080 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT
-A INPUT -p udp -m state --state NEW -m udp --dport 80 -j ACCEPT
-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT
-A INPUT -j REJECT --reject-with icmp-host-prohibited
-A FORWARD -j REJECT --reject-with icmp-host-prohibited
COMMIT
# Completed on Tue Dec 18 03:38:00 2018
</code></pre>
<p>然后重启防火墙：</p>
<pre><code class="language-shell">service iptables restart
</code></pre>
<p>最后查看端口是否开放：</p>
<pre><code class="language-shell">/sbin/iptables -L -n
</code></pre>
<p>重启shadowsocks：</p>
<pre><code class="language-shell">/etc/init.d/shadowsocks restart
</code></pre>
<h4 id="六-配置客户端访问"><strong>六、配置客户端访问</strong></h4>
<p><strong>1.电脑端：</strong><br>
SS：<br>
Shadowsocks 的MAC客户端，主要有两个版本：ShadowsocksX 和 ShadowsocksX-NG，其中ShadowsocksX-NG为ShadowsocksX的最新版本 。目前这两个版本仅支持SS原版，不支持SSR的混淆功能。</p>
<p>SSR：<br>
推荐使用Shadowsocks-NG-R，下载地址是：<br>
<a href="https://github.com/qinyuhang/ShadowsocksX-NG-R/releases/download/1.4.4-r8/ShadowsocksX-NG-R8.dmg" title="点我下载">点我下载</a></p>
<p>配置：<br>
如果按照上面安装步骤来的话，SS就填写服务器ip，端口，加密方式，密码就能访问了；SSR的话要加上上面的协议和混淆，可以不用填写混淆参数，因为不需要免流。</p>
<p><strong>2.客户端（ios）:</strong><br>
ios端的话就推荐使用小火箭，去美区商店下载。<br>
SS：<br>
选择SS配置，然后填写服务器ip，端口，加密方式，密码。访问ok。</p>
<p>SSR：<br>
选择SSR配置，然后填写服务器ip，端口，加密方式，密码，协议，混淆，额外需要填写混淆参数，这是为了免流，联通大王卡的混淆参数是：mmbiz.qpic.cn  测试可以免流。注意免流的话需要开启全局代理。</p>
<h4 id="七-免流科普"><strong>七、免流科普：</strong></h4>
<p>大概介绍一下，一些移动运营商存在一些特定的免流优惠，比如手机流量登录运营商客户端免流量。前期是简单的通过网址来判断是否符合免流条件。SSR安装在手机上后，上网时手机流量经SSR转发到上网地址，通过在SSR内加入免流网址的混淆参数后，让运营商判断失误，达到免流的目的。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[使用openOffice实现word、excel等转pdf功能]]></title>
        <id>https://skytotwo.github.io//post/openoffice</id>
        <link href="https://skytotwo.github.io//post/openoffice">
        </link>
        <updated>2019-08-26T14:31:25.000Z</updated>
        <summary type="html"><![CDATA[<p>最近在公司项目中需要实现Excel转pdf的功能，一开始我自己写了工具类来实现转换，实现方式是将目标文件读流，再读出每个sheet，再将sheet数组一个个遍历取当页的数据，读数据的时候又需要每行每行的遍历，再将每个sheet拼接起来成为一个pdf。</p>
]]></summary>
        <content type="html"><![CDATA[<p>最近在公司项目中需要实现Excel转pdf的功能，一开始我自己写了工具类来实现转换，实现方式是将目标文件读流，再读出每个sheet，再将sheet数组一个个遍历取当页的数据，读数据的时候又需要每行每行的遍历，再将每个sheet拼接起来成为一个pdf。</p>
<!-- more -->
<p>本来自己想着简单，确实也实现了功能，但是还是存在很多小问题自己无法控制，比如说对excel的页面布局格式之类的需要严格控制调整，这样弄得很烦，所以想着另找出路。这时候想到了Appache的openOffice。<br>
openOffice其实是一个服务，可以安装在windows、mac和linux下，用命令启动后，程序调用该端口，就能调用本机安装的office软件或者wps软件进行转格式，原理就是这样的。<br>
接下来我们来看下怎么使用。</p>
<hr>
<h4 id="一下载安装"><strong>一.下载安装</strong></h4>
<p>这是一个开源程序，下载地址是：<br>
<a href="https://www.openoffice.org/download/" title="https://www.openoffice.org/download/">https://www.openoffice.org/download/</a><br>
进入下载页面，多个系统程序包可以选择，如图下：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180916103231_367.png" alt="20180916103231_367.png"><br>
这里介绍windows系统和linux系统的安装，因为开发环境西药先测试，然后是要部署至生产环境的，因为公司生产环境用的是redhat红帽系统，所以会针对性的介绍下。</p>
<p><strong>windows</strong><br>
windows安装其实很简单，就是一步步点下一步就好了，安装完成后，我们需要记住相应的启动命令来启动程序。如下图：<br>
打开cmd进入openoffice安装目录：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180916103716_95.png" alt="20180916103716_95.png"><br>
在program文件夹下输入启动命令，soffice.exe -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;,然后回车就启动了<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180916103856_647.png" alt="20180916103856_647.png"></p>
<p><strong>linux</strong><br>
linux下安装会复杂一点，这里以redhat为例，我们先下载对应的安装包，红帽系统需要选择rpm格式的，我们下载64位的，如下图：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180916104119_512.png" alt="20180916104119_512.png"><br>
然后安装过程如下：</p>
<pre><code class="language-shell">一、安装openOffice
1.使用tar -xzvf xxxx.tar.gz解压缩后，会得到对应的解压文件 /zh-CN

目录。
2.进入/zh-CN//RPMS/目录
3.执行　rpm –ivh *rpm（安装所有rpm文件）
4.进入到desktop-integration目录　cd desktop-integration
5.执行　rpm -ivh openoffice.org3.2-redhat-menus-3.2-9472.noarch.rpm

这时openOffice己经安装完成，默认会安装在/opt下

二、启动openOffice服务　
1.进入opt目录：cd /opt
2.进入openoffice.org3目录：　cd openoffice.org3
3.进入cd program目录
4.执行　soffice -headless -accept=&quot;socket,host=127.0.0.1,port=8100;urp;&quot; -nofirststartwizard &amp; 

三、停止openOffice服务

ps -aux | grep oppenoffice 查看是否openoffice服务是否已启动；
</code></pre>
<p>至此，openOffice的安装我们已经搞定了，接下来就是程序的编写了</p>
<h4 id="二转换程序编写"><strong>二.转换程序编写</strong></h4>
<p>首先我们需要在项目里导入相应的jar包，所需jar包如下：</p>
<pre><code class="language-java">jodconverter-2.2.2.jar
ridl-3.2.1.jar
org.apache.commons.io.jar
juh.jar
jurt.jar
unoil.jar
slf4j-api-1.7.13.jar
slf4j-jdk14-1.7.13.jar
xstream-1.4.1.jar

</code></pre>
<p>转换的java方法我这边直接拿项目里用到的方法来讲，其实也很简单</p>
<pre><code class="language-java">import java.io.File;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.net.ConnectException;

import com.artofsolving.jodconverter.DocumentConverter;
import com.artofsolving.jodconverter.openoffice.connection.OpenOfficeConnection;
import com.artofsolving.jodconverter.openoffice.connection.SocketOpenOfficeConnection;
import com.artofsolving.jodconverter.openoffice.converter.OpenOfficeDocumentConverter;

public class Converter {
	 /** 
     * 将Office文档转换为PDF. 运行该函数需要用到OpenOffice, OpenOffice下载地址为 
     * http://www.openoffice.org/ 
     *  
     * &lt;pre&gt; 
     * 方法示例: 
     * String sourcePath = &quot;F:\\office\\source.doc&quot;; 
     * String destFile = &quot;F:\\pdf\\dest.pdf&quot;; 
     * Converter.office2PDF(sourcePath, destFile); 
     * &lt;/pre&gt; 
     *  
     * @param sourceFile 
     *            源文件, 绝对路径. 可以是Office2003-2007全部格式的文档, Office2010的没测试. 包括.doc, 
     *            .docx, .xls, .xlsx, .ppt, .pptx等. 示例: F:\\office\\source.doc 
     * @param destFile 
     *            目标文件. 绝对路径. 示例: F:\\pdf\\dest.pdf 
     * @return 操作成功与否的提示信息. 如果返回 -1, 表示找不到源文件, 或url.properties配置错误; 如果返回 0, 
     *         则表示操作成功; 返回1, 则表示转换失败 
     */  
    public static int office2PDF(String sourceFile, String destFile) {  
        try {  
            File inputFile = new File(sourceFile);  
            if (!inputFile.exists()) {  
                return -1;// 找不到源文件, 则返回-1  
            }  
  
            // 如果目标路径不存在, 则新建该路径  
            File outputFile = new File(destFile);  
         
            //String OpenOffice_HOME = &quot;D:\\Program Files\\OpenOffice.org 4&quot;;//这里是OpenOffice的安装目录, 在我的项目中,为了便于拓展接口,没有直接写成这个样子,但是这样是绝对没问题的  
            String OpenOffice_HOME = &quot;C:\\Program Files (x86)\\OpenOffice 4&quot;;
            // 如果从文件中读取的URL地址最后一个字符不是 '\'，则添加'\'  
            if (OpenOffice_HOME.charAt(OpenOffice_HOME.length() - 1) != '\\') {  
                OpenOffice_HOME += &quot;\\&quot;;  
            }  
            // 启动OpenOffice的服务  
            String command = OpenOffice_HOME  
                    + &quot;program\\soffice.exe -headless -accept=\&quot;socket,host=127.0.0.1,port=8100;urp;\&quot;&quot;;
            //注意：linux系统的服务是已经启动好的，不需要另启动服务，下面这句本地需要，服务器不需要
            Process pro = Runtime.getRuntime().exec(command);  
            // connect to an OpenOffice.org instance running on port 8100  
            OpenOfficeConnection connection = new SocketOpenOfficeConnection(  
                    &quot;127.0.0.1&quot;, 8100);  
            connection.connect();  
  
            // convert  
            DocumentConverter converter = new OpenOfficeDocumentConverter(  
                    connection);  
            converter.convert(inputFile, outputFile);  
  
            // close the connection  
            connection.disconnect();  
            //注意：关闭OpenOffice服务的进程 ，下面这句本地需要，服务器不需要
            pro.destroy();  
  
            return 0;  
        } catch (ConnectException e) {  
            e.printStackTrace();  
        } catch (IOException e) {  
            e.printStackTrace();  
        }  
  
        return 1;  
    }
}
</code></pre>
<p>这里很好理解，就是拿到文件，连接openOffice服务，调用转换方法。</p>
<p>其实开发和部署还是很顺利的，需要注意的是jar包不能少，不然会报错在服务器上。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Django自定义xadmin插件之导入excel]]></title>
        <id>https://skytotwo.github.io//post/django-xadmin-excel</id>
        <link href="https://skytotwo.github.io//post/django-xadmin-excel">
        </link>
        <updated>2019-08-26T14:17:13.000Z</updated>
        <summary type="html"><![CDATA[<p>xadmin的厉害之处在于它允许使用者自定义插件，使用者编写自己需要的插件并注册到xadmin中，以便xadmin实现自己所需要的功能。</p>
]]></summary>
        <content type="html"><![CDATA[<p>xadmin的厉害之处在于它允许使用者自定义插件，使用者编写自己需要的插件并注册到xadmin中，以便xadmin实现自己所需要的功能。</p>
<!-- more -->
<p>xadmin是如何能够实现插件的自定义呢？其实在xadmin使用文档上可以找到答案，如下所示：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902134855_643.png" alt="20180902134855_643.png"></p>
<hr>
<p>这里拿制作excel导入插件为例。最终实现的效果是在xadmin中某类别下能够出现导入excel按钮，并且能够实现excel的导入，如下图所示：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902135157_751.png" alt="20180902135157_751.png"><br>
点击导入excel选项：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902135226_545.png" alt="20180902135226_545.png"></p>
<p>并且最终实现悬着好excel文件后，点击确认，能够将导入逻辑相应到后台进行处理。</p>
<h4 id="一编写excel插件"><strong>一.编写excel插件</strong></h4>
<p>要编写excel插件，首先需要认识xadmin的目录结构，这里建议将xadmin下载至本地并放置在项目中，这样才能编写插件代码，下载地址是：<br>
<a href="https://github.com/sshwsfc/xadmin" title="点我下载">点我下载</a><br>
下载后得到的xadmin文件结构如下：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902135714_712.png" alt="20180902135714_712.png"><br>
我们需要做的是在plugins模块中编写插件，plugins模块中已经有很多的插件了，如下：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180902135841_910.png" alt="20180902135841_910.png"><br>
这里已经有许多可以直接用的插件。<br>
直接在里面新建文件，命名为excel.py代码如下：</p>
<pre><code class="language-python"># coding:utf-8

import xadmin
from xadmin.views import BaseAdminPlugin, ListAdminView
from django.template import loader


#excel 导入
class ListImportExcelPlugin(BaseAdminPlugin):
    import_excel = False

    def init_request(self, *args, **kwargs):
        return bool(self.import_excel)#返回bool值，excel显示权限

    def block_top_toolbar(self, context, nodes):
        nodes.append(loader.render_to_string('xadmin/excel/model_list.top_toolbar.import.html'))


xadmin.site.register_plugin(ListImportExcelPlugin, ListAdminView)
</code></pre>
<p><strong>解读：</strong></p>
<ul>
<li>自定义的ListImportExcelPlugin类需要继承BaseAdminPlugin类，这是固定写法。然后定义的init_request方法，是为了确定xadmin中excel导入按钮的显示权限，这里返回一个bool值，为Ture则为显示，False则不显示，这里顶一个了一个import_excel = False变量，默认值为False，其实可以在model对应adminx类中指定import_excel的值，因为xadmin展示的时候回默认加载这个变量，这样就能达到按钮显示权限了。</li>
<li>而block_top_toolbar方法则是必须要重写的方法，这方法作用是将选项按钮固定在toolbar上，并直接nodes.append即可，参数是一个html页面，这个就是点击导入excel后出现的弹窗悬着excel页面。</li>
</ul>
<p>然后需要将自己编写的excel插件文件注册到xadmin中，直接在plugins模块的init文件中PLUGINS配置文件中添加“excel”即可，注意，excelwei插件的文件名，如下：</p>
<pre><code class="language-python">PLUGINS = (
    ...
	'excel'
)
</code></pre>
<h4 id="二后台逻辑"><strong>二.后台逻辑</strong></h4>
<p>当选择了excel文件并且点击了确定后，需要将excel文件传至后台接收处理，这里该怎么做呢？<br>
其实只需要在对应的model关联的adminx类中定义post方法即可，如下：</p>
<pre><code class="language-python">#用于在课程页面导入excel页面后，对导入的excel做后台逻辑
    def post(self, request, *args, **kwargs):
        if 'excel' in request.FILES:
            pass
        return super().post(request, args, kwargs) #最后一定要调用父类CourseAdmin的post方法返回
</code></pre>
<p>这样就能后将excel传至后台，并且编写我们的解析excel逻辑了，这里需要注意的是，post方法一定要返回父类的post方法，这是固定写法，不然的话会报错，连最起码的xadmin保存都会出错。</p>
<p>至此，自己编写的导入excel插件就安装成功啦，类似的其他功能实现方式也差不多，都是这个套路~</p>
]]></content>
    </entry>
</feed>