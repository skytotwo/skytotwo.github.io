<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skytotwo.github.io/</id>
    <title>Totoro の Home</title>
    <updated>2019-08-26T08:28:42.234Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skytotwo.github.io/"/>
    <link rel="self" href="https://skytotwo.github.io//atom.xml"/>
    <subtitle>空杯心态，每天进步</subtitle>
    <logo>https://skytotwo.github.io//images/avatar.png</logo>
    <icon>https://skytotwo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Totoro の Home</rights>
    <entry>
        <title type="html"><![CDATA[flask全局404装饰器（全局以及蓝图）]]></title>
        <id>https://skytotwo.github.io//post/flask-404-decorator</id>
        <link href="https://skytotwo.github.io//post/flask-404-decorator">
        </link>
        <updated>2019-08-26T08:25:56.000Z</updated>
        <summary type="html"><![CDATA[<p>在flask里是可以实现全局事件注册的，利用装饰器来注册相应的事件，比如404错误，数据库错误等，当错误出现就会捕获走对应的逻辑，很方便。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在flask里是可以实现全局事件注册的，利用装饰器来注册相应的事件，比如404错误，数据库错误等，当错误出现就会捕获走对应的逻辑，很方便。</p>
<!-- more --> 
<pre><code class="language-python">#全局
@app.errorhandler(404)
def page_not_found(error):
    &quot;&quot;&quot;
    404
    &quot;&quot;&quot;
    return render_template(&quot;home/404.html&quot;), 404

#蓝图，注册范围为本蓝图
@web.errorhandler(404)
def page_not_found(error):
    &quot;&quot;&quot;
    404
    &quot;&quot;&quot;
    return render_template(&quot;home/404.html&quot;), 404

#蓝图，注册范围为全局
@web.app_errorhandler(404)
def page_not_found(error):
    &quot;&quot;&quot;
    404
    &quot;&quot;&quot;
    return render_template(&quot;home/404.html&quot;), 404
</code></pre>
<p>注意：</p>
<ul>
<li>核心对象加载的错误处理装饰器，全局的直接是@app.errorhandler(404)</li>
<li>蓝图的加载错误处理装饰器：
<ol>
<li>蓝图名.errorhandler(404)，表示在该蓝图范围中的错误才能触发处理程序</li>
<li>蓝图名.app_errorhandler(404)，表示注册为程序全局的错误处理程序</li>
</ol>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Flask的蓝图解释一二]]></title>
        <id>https://skytotwo.github.io//post/flask-blueprint</id>
        <link href="https://skytotwo.github.io//post/flask-blueprint">
        </link>
        <updated>2019-08-26T08:23:37.000Z</updated>
        <summary type="html"><![CDATA[<p>以下是一个最基本的蓝图示例。在这里，我们将使用蓝图来简单地渲染静态模板:</p>
]]></summary>
        <content type="html"><![CDATA[<p>以下是一个最基本的蓝图示例。在这里，我们将使用蓝图来简单地渲染静态模板:</p>
<!-- more -->
<pre><code class="language-python">from flask import Blueprint, render_template, abort
from jinja2 import TemplateNotFound

simple_page = Blueprint('simple_page', __name__,
                        template_folder='templates')

from app.feedback import feedback #视图
</code></pre>
<pre><code class="language-python">#视图部分 feedback.py
from . import simple_page

@simple_page.route('/', defaults={'page': 'index'})
@simple_page.route('/&lt;page&gt;')
def show(page):
    try:
        return render_template('pages/%s.html' % page)
    except TemplateNotFound:
        abort(404)
</code></pre>
<p>当你使用 @simple_page.route 装饰器绑定一个函数时，蓝图会记录下所登记的 show 函数。当以后在应用中注册蓝图时，这个函数会被注册到应用中。另外，它 会把构建 Blueprint 时所使用的名称（在本例为 simple_page ）作 为函数端点的前缀。</p>
<pre><code class="language-python">可以这样注册蓝图:

from flask import Flask
from yourapplication.simple_page import simple_page

app = Flask(__name__)
app.register_blueprint(simple_page)
以下是注册蓝图后形成的规则:

[&lt;Rule '/static/&lt;filename&gt;' (HEAD, OPTIONS, GET) -&gt; static&gt;,
 &lt;Rule '/&lt;page&gt;' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;,
 &lt;Rule '/' (HEAD, OPTIONS, GET) -&gt; simple_page.show&gt;]
</code></pre>
<p>所以当外部访问到对应url规则时，会直接找到指定蓝图下的方法。也就是定义蓝图下引入视图的意义，会直接在那里找对应方法。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[谈谈python中的深拷贝和浅拷贝]]></title>
        <id>https://skytotwo.github.io//post/python-copy</id>
        <link href="https://skytotwo.github.io//post/python-copy">
        </link>
        <updated>2019-08-26T08:19:53.000Z</updated>
        <summary type="html"><![CDATA[<p>原文链接：谈谈python中的深拷贝和浅拷贝<a href="https://www.jianshu.com/p/efa9dd51f5cc">https://www.jianshu.com/p/efa9dd51f5cc</a></p>
<p>最近面试被问到python中深拷贝和浅拷贝的知识<br>
这里进行下总结，以便今后复习<br>
python中的深拷贝和浅拷贝和java里面的概念是一样的，所谓浅拷贝就是对引用的拷贝，所谓深拷贝就是对对象的资源的拷贝。</p>
]]></summary>
        <content type="html"><![CDATA[<p>原文链接：谈谈python中的深拷贝和浅拷贝<a href="https://www.jianshu.com/p/efa9dd51f5cc">https://www.jianshu.com/p/efa9dd51f5cc</a></p>
<p>最近面试被问到python中深拷贝和浅拷贝的知识<br>
这里进行下总结，以便今后复习<br>
python中的深拷贝和浅拷贝和java里面的概念是一样的，所谓浅拷贝就是对引用的拷贝，所谓深拷贝就是对对象的资源的拷贝。</p>
 <!-- more -->
<p><strong>首先，对赋值操作我们要有以下认识：</strong></p>
<ol>
<li>赋值是将一个对象的地址赋值给一个变量，让变量指向该地址（ 旧瓶装旧酒 ）。</li>
<li>修改不可变对象（str、tuple）需要开辟新的空间</li>
<li>修改可变对象（list等）不需要开辟新的空间<br>
浅拷贝仅仅复制了容器中元素的地址</li>
</ol>
<pre><code class="language-python">&gt;&gt;&gt; a=['hello',[1,2,3]]
&gt;&gt;&gt; b=a[:]
&gt;&gt;&gt; [id(x) for x in a]
[55792504, 6444104]
&gt;&gt;&gt; [id(x) for x in b]
[55792504, 6444104]
&gt;&gt;&gt; a[0]='world'
&gt;&gt;&gt; a[1].append(4)
&gt;&gt;&gt; print(a)
['world', [1, 2, 3, 4]]
&gt;&gt;&gt; print(b)
['hello', [1, 2, 3, 4]]
</code></pre>
<p>这里可以看出，未修改前，a和b中元素的地址都是相同的，不可变的hello<br>
和可变的list地址都一样，说明浅拷贝知识将容器内的元素的地址复制了一份。这可以通过修改后，b中字符串没改变，但是list元素随着a相应改变得到验证。</p>
<ul>
<li>浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素（ 新瓶装旧酒 ）。</li>
</ul>
<p>深拷贝，完全拷贝了一个副本，容器内部元素地址都不一样</p>
<pre><code class="language-python">&gt;&gt;&gt; from copy import deepcopy
&gt;&gt;&gt; a=['hello',[1,2,3]]
&gt;&gt;&gt; b=deepcopy(a)
&gt;&gt;&gt; [id(x) for x in a]
[55792504, 55645000]
&gt;&gt;&gt; [id(x) for x in b]
[55792504, 58338824]
&gt;&gt;&gt; a[0]='world'
&gt;&gt;&gt; a[1].append(4)
&gt;&gt;&gt; 
&gt;&gt;&gt; print(a)
['world', [1, 2, 3, 4]]
&gt;&gt;&gt; print(b)
['hello', [1, 2, 3]]
</code></pre>
<p>这里可以看出，深拷贝后，a和b的地址以及a和b中的元素地址均不同，这是完全拷贝的一个副本，修改a后，发现b没有发生任何改变，因为b是一个完全的副本，元素地址与a均不同，a修改不影响b。</p>
<ul>
<li>深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。也就是说（ 新瓶装新酒 ）。</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Flask中url_for的参数解释]]></title>
        <id>https://skytotwo.github.io//post/flask-url_for</id>
        <link href="https://skytotwo.github.io//post/flask-url_for">
        </link>
        <updated>2019-08-26T08:17:44.000Z</updated>
        <summary type="html"><![CDATA[<p>url_for函数的作用是：通过给定的endpoint端点和额外参数，结合请求上下文和应用上下文，生成一个url地址并返回。</p>
]]></summary>
        <content type="html"><![CDATA[<p>url_for函数的作用是：通过给定的endpoint端点和额外参数，结合请求上下文和应用上下文，生成一个url地址并返回。</p>
<!-- more --> 
<p>其中的额外参数有：<br>
_external: 是否使用绝对路径<br>
_scheme：使用http还是https，设置这个参数时，必须使_external=True<br>
_anchor：锚点，可以定位到html中的某一个位置<br>
_method：http方法,post、get等</p>
<p>endpoint其实又叫做端点，默认情况下是视图函数名，也可以自定义端点名，主要是用作url_for反向寻找视图的一个标记，如：</p>
<pre><code class="language-python">{{ url_for('login') }}
</code></pre>
<p>login就是endpoint端点名。</p>
<p>url_for() 函数还支持一种简写的端点形式，在蓝本中可以省略蓝本名，例如url_for('.<br>
index')。在这种写法中，命名空间是当前请求所在的蓝本。这意味着同一蓝本中的重定向<br>
可以使用简写形式，但跨蓝本的重定向必须使用带有命名空间的端点名。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[单页面应用程序和多页面应用程序（网站）的区别]]></title>
        <id>https://skytotwo.github.io//post/single&amp;mutipage</id>
        <link href="https://skytotwo.github.io//post/single&amp;mutipage">
        </link>
        <updated>2019-08-26T08:13:52.000Z</updated>
        <summary type="html"><![CDATA[<p>单页面和双页面应用的区别：</p>
<ul>
<li>1、单页面应用程序的数据渲染是在客户端进行的；而多页面应用程序的数据渲染则是在服务端进行的。</li>
<li>2、单页面应用程序的数据请求等是在js中通过ajax完成的；多页面应用程序则是在服务端试图函数中完成的。</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<p>单页面和双页面应用的区别：</p>
<ul>
<li>1、单页面应用程序的数据渲染是在客户端进行的；而多页面应用程序的数据渲染则是在服务端进行的。</li>
<li>2、单页面应用程序的数据请求等是在js中通过ajax完成的；多页面应用程序则是在服务端试图函数中完成的。</li>
</ul>
<h2 id="-more-"><!-- more --></h2>
<h3 id="单页面应用singlepage-web-applicationspa"><strong>单页面应用（SinglePage Web Application，SPA）</strong></h3>
<p>只有一张Web页面的应用，是一种从Web服务器加载的富客户端，单页面跳转仅刷新局部资源 ，公共资源(js、css等)仅需加载一次，常用于PC端官网、购物等网站<br>
如图：<br>
<img src="/attached/image/20180508/20180508223839_750.png" alt=""></p>
<h3 id="多页面应用multipage-applicationmpa"><strong>多页面应用（MultiPage Application，MPA）</strong></h3>
<p>多页面跳转刷新所有资源，每个公共资源(js、css等)需选择性重新加载，常用于 app 或 客户端等</p>
<p>如图：<br>
<img src="/attached/image/20180508/20180508223908_626.png" alt=""></p>
<p>具体对比分析：</p>
<p><img src="/attached/image/20180508/20180508223927_729.jpg" alt=""></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Python的with上下文要点]]></title>
        <id>https://skytotwo.github.io//post/python-with-context</id>
        <link href="https://skytotwo.github.io//post/python-with-context">
        </link>
        <updated>2019-08-26T08:09:49.000Z</updated>
        <summary type="html"><![CDATA[<p>python的的with上下文其实可以自己实现，只要该对象实现了__enter__和__exit__方法，就实现了一个with上下文，可以用with来处理该对象，如下：</p>
]]></summary>
        <content type="html"><![CDATA[<p>python的的with上下文其实可以自己实现，只要该对象实现了__enter__和__exit__方法，就实现了一个with上下文，可以用with来处理该对象，如下：</p>
<!-- more -->
<pre><code class="language-python">class MyResource:
	def __enter__(self):
		return self
	
	def __exit__(self, exc_type, exc_value, tb):
		if tb:
			print('proccess exception')
		else:
			print('no exception')
		print('close resource connection')
		
	def query(self):
		print('query data')
		

with MyResource() as resource:
	resource.query()
</code></pre>
<p>注意：<br>
1、任何实现了__enter__和__exit__魔法方法的对象都能用with处理<br>
2、with实例化对象后用as赋给一个变量，变量为__enter__所返回的值，上面代码中__enter__返回的是实例对象。<br>
3、调用的顺序是__enter__，然后with里的逻辑，最后是__exit__方法。<br>
4、<strong>exit</strong> 方法包含4个参数，分别是(self, exc_type, exc_value, tb)，第一个是实例对象，后面三个分别为异常类型、异常值和异常堆栈信息。这里主要是为了捕获异常，只要是逻辑处理中危险异常，都会在这里捕获，并退出。<br>
5、<strong>exit</strong> 方法是有返回的，如果return值是Ture的话，就代表捕获了异常，不会抛出；如果返回值为空或者返回False，就代表异常会继续抛出。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[详解flask上下文与出入栈]]></title>
        <id>https://skytotwo.github.io//post/flask-content</id>
        <link href="https://skytotwo.github.io//post/flask-content">
        </link>
        <updated>2019-08-26T08:04:10.000Z</updated>
        <summary type="html"><![CDATA[<p>在flask中，上下文算是核心中的核心了，其作用于请求的访问处理，多线程隔离的实现等。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在flask中，上下文算是核心中的核心了，其作用于请求的访问处理，多线程隔离的实现等。</p>
 <!-- more --> 
<h4 id="flask的上下文">flask的上下文：</h4>
<p>1、应用上下文 （AppContent）<br>
2、请求上下文 （Request Context）</p>
<p>如图所示：<br>
<img src="http://picture.totoro.site/images/2019/08/26/20180506181132_533.jpg" alt="20180506181132_533.jpg"></p>
<p>应用上下文是对当前应用实例app的封装<br>
请求上下文是对当前请求Request的封装</p>
<p>1、当每一个请求进入系统的时候，都会将当前的应用上下文和请求上下文进行入栈操作，所代表的栈对象分别是_app_ctx_stack和_request_ctx_stack。<br>
2、栈对象进入栈顶的顺序是，先应用上下文的栈对象先进入栈顶，然后才是请求上下文的栈对象进入栈顶</p>
<h4 id="注意">注意：</h4>
<p>1、当一个请求进来时，也就是在请求的逻辑中要获取应用上下文，flask会先判断应用上下文的栈顶是否有该应用实例栈对象，没有的话会自动帮着将当前的应用上下文栈对象推入栈中。也就是说，在请求的逻辑视图处理中，是可以获取到当前的应用上下文的。<br>
2、通过current_app和request获取当前应用上下文和请求上下文，其实都是经过了flask的封装，该方法是localproxy，都是分别去各自的栈顶获取栈对象，然后再取出app和request这个属性。</p>
<p>3、在不是请求视图中要获取当前的应用上下文，是需要自己将当前的应用栈对象push到栈中的，然后才能通过current_app来获取到当前应用实例。通常在离线应用和单元测试场景上会使用到。<br>
具体代码如下：</p>
<pre><code class="language-python">app = Flask(__name__)

ctx = app.app_content()
ctx.push()

然后使用完了需要将其在栈中去除
ctx.pop()
</code></pre>
<h4 id="所有名词解释">所有名词解释</h4>
<p>1、以线程ID号作为key的字典-&gt;Local-&gt;LocalStack<br>
（local是通过点来实现线程隔离的，localstack则是封装了local通过push()、pop()和top成为线程隔离对象(栈)）<br>
2、AppContext RequestContext -&gt; LocalStack<br>
（AppContext是应用上下文，RequestContext是请求上下文，分别依次推入各自的线程隔离对象中）<br>
3、Flask -&gt; AppContext   Request -&gt; RequestContext<br>
（AppContext封装的是Flask的应用核心对象，RequestContext封装的是本次请求的Request对象）<br>
4、current_app -&gt;(LocalStack.top = AppContext top.app=Flask)<br>
（current_app指的是线程隔离对象栈顶的元素（应用上下文）的app属性（核心对象））<br>
5、request -&gt;(LocalStack.top = RequestContext top.request= Request)<br>
（request指的是线程隔离对象栈顶元素（请求上下文）的request属性（当前request对象））</p>
<p>注意：app，也就是当前应用核心对象只有一个，因为它是在主线程中生成的，而request则是每次请求都会生成一个，所以需要线程隔离。app的话，因为作为字典存在的线程隔离，都是同一个value是没有意义的，所以app并没有被线程隔离</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos系统下nginx 相关命令]]></title>
        <id>https://skytotwo.github.io//post/centos-nginx</id>
        <link href="https://skytotwo.github.io//post/centos-nginx">
        </link>
        <updated>2019-08-26T08:01:26.000Z</updated>
        <content type="html"><![CDATA[<pre><code class="language-python">linux（centos）系统下nginx 服务器重启，关闭的命令。

nginx -s reload  ：修改配置后重新加载生效

nginx -s reopen  ：重新打开日志文件

nginx -t 测试nginx配置文件是否正确

nginx -t -c /path/to/nginx.conf 测试nginx配置文件是否正确

关闭nginx：

nginx -s stop  : 快速停止nginx
         quit  : 完整有序的停止nginx

其他的停止 nginx 方式：

ps -ef | grep nginx

kill -QUIT 主进程号     ：从容停止Nginx

kill -TERM 主进程号     ：快速停止Nginx

pkill -9 nginx         :强制停止Nginx

启动nginx:

nginx -c /path/to/nginx.conf

平滑重启nginx：

kill -HUP 主进程号
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7 环境下部署flask网站步骤]]></title>
        <id>https://skytotwo.github.io//post/centos7-flask-env</id>
        <link href="https://skytotwo.github.io//post/centos7-flask-env">
        </link>
        <updated>2019-08-26T07:53:41.000Z</updated>
        <summary type="html"><![CDATA[<p>自己之前做了一个flask项目，完成后部署在腾讯云，过程由踩一点坑，这里记录下过程。在部署之前，需要先配置centos7环境，具体链接为：<br>
<a href="https://totoro.site/post/centos7-python-env/" title="centos7 环境配置">centos7 环境配置</a></p>
]]></summary>
        <content type="html"><![CDATA[<p>自己之前做了一个flask项目，完成后部署在腾讯云，过程由踩一点坑，这里记录下过程。在部署之前，需要先配置centos7环境，具体链接为：<br>
<a href="https://totoro.site/post/centos7-python-env/" title="centos7 环境配置">centos7 环境配置</a></p>
 <!-- more --> 
<p>1、安装依赖包<br>
在虚拟环境中安装好所有包，例如：</p>
<pre><code class="language-python">pip install -r requements.txt
</code></pre>
<p>2、关闭调试模式 app.debug = False，并且安装flask-script插件来进行命令行启动项目，如下：</p>
<pre><code class="language-python">pip install flask-script
from flask_script import Manager

manage = Manager(app)

if __name__ == &quot;__main__&quot;:
    manage.run()
</code></pre>
<p>3、在init文件中修改mysql数据库连接（ip地址等），然后在navicat中远程连接到服务器的mysql，进行数据传输，这样是最省时的。<br>
4、配置nginx 反向代理<br>
nginx配置文件：</p>
<pre><code class="language-python">worker_processes 4;
events {
    worker_connections 262140;
}
http {
    include mime.types;
    default_type application/octet-stream;
    sendfile on;
    keepalive_timeout 65;
    limit_conn_zone $binary_remote_addr zone=addr:5m;
    upstream movie {
		server 127.0.0.1:5000;
        server 127.0.0.1:5001;
        server 127.0.0.1:5002;
        server 127.0.0.1:5003;
        server 127.0.0.1:5004;
    }
    server {
        listen 80;
        server_name localhost;
        location / {
            root html;
            index index.html index.htm;
            proxy_pass http://movie;
        }
        location ~ \.flv$ {
            flv;
            limit_conn addr 4;
            limit_rate 1024k;
            rewrite ^/static/uploads/movies/(.+?).flv$ /flask_movie/app/static/uploads/movies/$1.flv permanent;
        }
        location ~ \.mp4$ {
            mp4;
            limit_conn addr 4;
            limit_rate 1024k;
            rewrite ^/static/uploads/movies/(.+?).mp4$ /flask_movie/app/static/uploads/movies/$1.mp4 permanent;
        }
        error_page 500 502 503 504 /50x.html;
        location = /50x.html {
            root html;
        }
    }
}

</code></pre>
<p>然后将配置文件拷贝至nginx目录中，覆盖原有配置文件：</p>
<pre><code class="language-python">cp nginx.conf /usr/local/nginx/conf/
ubuntu: cp nginx.conf /etc/nginx/conf.d
</code></pre>
<p>将项目拷贝到nginx的html目录：</p>
<pre><code class="language-python">cp -r movie_project /usr/local/nginx/html

</code></pre>
<p>然后重启nginx：</p>
<pre><code class="language-python">nginx -s stop
nginx
nginx -s reload
</code></pre>
<p>启动项目：</p>
<pre><code class="language-python">cd /usr/local/nginx/html/movie_project

python manage.py runserver
</code></pre>
<p>5、开启多个端口后台运行</p>
<pre><code class="language-python">nohup python manage.py runserver -h 127.0.0.1 -p 5001 &amp;

然后 ctr + c

nohup python manage.py runserver -h 127.0.0.1 -p 5002 &amp;

然后 ctr + c

nohup python manage.py runserver -h 127.0.0.1 -p 5003 &amp;

然后 ctr + c

nohup python manage.py runserver -h 127.0.0.1 -p 5004 &amp;
</code></pre>
<p>这样就开启了四个端口，输入如下命令可以查看：</p>
<pre><code class="language-python">netstat -anptu | grep 500*
</code></pre>
<p>6、流媒体访问限制<br>
限制单个ip能发起的连接: limit_conn addr 1;<br>
限制视频速率: limit_rate 1024k;<br>
刷新nginx nginx -s reload</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Centos7 部署python应用相关配置]]></title>
        <id>https://skytotwo.github.io//post/centos7-python-env</id>
        <link href="https://skytotwo.github.io//post/centos7-python-env">
        </link>
        <updated>2019-08-26T07:47:31.000Z</updated>
        <summary type="html"><![CDATA[<p>在centos上部署python环境需要的步骤很多，包括nginx，python版本安装，mysql的安装配置，虚拟环境的安装配置等，过程比较繁琐，有许多小细节要注意，以下是相关步骤。</p>
]]></summary>
        <content type="html"><![CDATA[<p>在centos上部署python环境需要的步骤很多，包括nginx，python版本安装，mysql的安装配置，虚拟环境的安装配置等，过程比较繁琐，有许多小细节要注意，以下是相关步骤。</p>
<!-- more -->
<h3 id="1-安装python36"><strong>1. 安装python3.6</strong></h3>
<p>编译环境准备：</p>
<pre><code class="language-python"> yum groupinstall 'Development Tools'
 yum install zlib-devel bzip2-devel openssl-devel ncurese-devel
 yum -y install openssl-devel bzip2-devel expat-devel gdbm-devel readline-devel
</code></pre>
<p>1 . 获取</p>
<pre><code class="language-python">wget https://www.python.org/ftp/python/3.6.3/Python-3.6.3.tgz
tar -xzvf Python-3.6.3.tgz -C  /tmp
cd  /tmp/Python-3.6.3/
</code></pre>
<p>2 . 把Python3.6安装到 /usr/local 目录</p>
<pre><code class="language-python">./configure --prefix=/usr/local
make
make altinstall
</code></pre>
<p>3 . 更改/usr/bin/python链接</p>
<pre><code class="language-python">ln -s /usr/local/bin/python3.6 /usr/bin/python3
</code></pre>
<p>替换旧Python，将默认安装的python2软链接指向python：</p>
<pre><code class="language-python">mv /usr/bin/python /usr/bin/old_python
</code></pre>
<p>再将/usr/bin/python指向python3：</p>
<pre><code class="language-python">ln -s /usr/local/bin/python3.6 /usr/bin/python
</code></pre>
<p>这样输入/usr/bin/python出来的就是python3了。这也是后面安装virtualenvwrapper，配置路径不会出错的前提。<br>
删除软连接：rm -rf  /home/zhenwx/htccode（示例）</p>
<p>4 .使得输入python系统默认为python3</p>
<pre><code class="language-python">cd /usr/bin/
ls yum*
vim yum
</code></pre>
<p>修改第一行尾python2</p>
<pre><code class="language-python">vim yum-config-manager
</code></pre>
<p>修改第一行尾python2</p>
<pre><code class="language-python">vim yum-debug-restore
vim yum-groups-manager
vim yum-build-dep
vim yum-debug-dump
vim yumdownloader
vim /usr/libexec/urlgrabber-ext-down
</code></pre>
<p>修改第一行尾python2</p>
<p>此时输入python就是3.6的python了。</p>
<h3 id="2-maridb"><strong>2. maridb</strong></h3>
<ol>
<li>
<p>安装</p>
<pre><code class="language-python"></code></pre>
</li>
</ol>
<p>sudo yum install mariadb-server</p>
<pre><code>2. 启动， 重启

    ```python
sudo systemctl start mariadb
sudo systemctl restart mariadb
</code></pre>
<ol start="3">
<li>设置bind-ip</li>
</ol>
<pre><code class="language-python">vim /etc/my.cnf
</code></pre>
<p>在 [mysqld]:下面加一行</p>
<pre><code class="language-python">bind-address = 0.0.0.0
</code></pre>
<p>4 . 设置外部ip可以访问</p>
<p>先进入mysql才能运行下面命令:mysql 直接进入就行</p>
<pre><code class="language-python">GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY '123456' WITH GRANT OPTION;
</code></pre>
<pre><code class="language-python">FLUSH PRIVILEGES;
</code></pre>
<p>5 . 设置阿里云、腾讯云的对外端口<br>
在对应服务器控制面板中，添加安全组规则，开放端口3306</p>
<p>6 . 安装mysqlclient出问题</p>
<pre><code>centos 7：
    yum install python-devel mariadb-devel -y

ubuntu：
    sudo apt-get install libmysqlclient-dev

然后：
    pip install mysqlclient
</code></pre>
<h3 id="3-安装nginx"><strong>3. 安装nginx</strong></h3>
<p>1、拷贝我们的nginx安装包到服务器<br>
2、安装依赖包</p>
<pre><code class="language-python">yum -y install gcc gcc-c++ openssl-devel pcre-devel httpd-tools
</code></pre>
<p>3、编译安装</p>
<pre><code class="language-python">tar -zxf nginx.tar.gz
cd nginx/

useradd nginx
./configure --prefix=/usr/local/nginx --user=nginx --group=nginx --with-http_ssl_module --with-http_mp4_module --with-http_flv_module

make &amp;&amp; make install

ln -s /usr/local/nginx/sbin/nginx /usr/sbin/
</code></pre>
<h3 id="4-安装virtualenvwrapper"><strong>4. 安装virtualenvwrapper</strong></h3>
<pre><code class="language-python">yum install python-setuptools python-devel
pip install virtualenvwrapper
</code></pre>
<p>编辑.bashrc文件</p>
<pre><code class="language-python">vim ~/.bashrc
</code></pre>
<pre><code class="language-python">export WORKON_HOME=$HOME/.virtualenvs
source /usr/local/bin/virtualenvwrapper.sh
</code></pre>
<p>重新加载.bashrc文件</p>
<pre><code class="language-python">source  ~/.bashrc
</code></pre>
<p>新建虚拟环境</p>
<pre><code class="language-python">mkvirtualenv mxonline
</code></pre>
<p>进入虚拟环境</p>
<pre><code class="language-python">workon mxonline
</code></pre>
<p>安装pip包<br>
我们可以通过 pip freeze &gt; requirements.txt 将本地的虚拟环境安装包相信信息导出来</p>
<p>然后将requirements.txt文件上传到服务器之后运行：</p>
<pre><code class="language-python">pip install -r requirements.txt
</code></pre>
<p>安装依赖包</p>
]]></content>
    </entry>
</feed>