<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skytotwo.github.io/</id>
    <title>Totoro の Home</title>
    <updated>2019-08-12T08:37:29.206Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skytotwo.github.io/"/>
    <link rel="self" href="https://skytotwo.github.io//atom.xml"/>
    <subtitle>空杯心态，每天进步</subtitle>
    <logo>https://skytotwo.github.io//images/avatar.png</logo>
    <icon>https://skytotwo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Totoro の Home</rights>
    <entry>
        <title type="html"><![CDATA[java获取当前路径的几种方法]]></title>
        <id>https://skytotwo.github.io//post/java-get-url</id>
        <link href="https://skytotwo.github.io//post/java-get-url">
        </link>
        <updated>2019-08-12T08:31:12.000Z</updated>
        <summary type="html"><![CDATA[<p>java开发过程中经常需要获取当前路径，而java也有相应的内置函数来对此提供支持，下面来介绍一下。</p>
]]></summary>
        <content type="html"><![CDATA[<p>java开发过程中经常需要获取当前路径，而java也有相应的内置函数来对此提供支持，下面来介绍一下。</p>
<!-- more -->
<p>1、利用System.getProperty()函数获取当前路径：<br>
System.out.println(System.getProperty(&quot;user.dir&quot;));//user.dir指定了当前的路径</p>
<p>2、使用File提供的函数获取当前路径：<br>
File directory = new File(&quot;&quot;);//设定为当前文件夹<br>
try{<br>
System.out.println(directory.getCanonicalPath());//获取标准的路径<br>
System.out.println(directory.getAbsolutePath());//获取绝对路径<br>
}catch(Exceptin e){}</p>
<p>File.getCanonicalPath()和File.getAbsolutePath()大约只是对于new File(&quot;.&quot;)和new File(&quot;..&quot;)两种路径有所区别。</p>
<p>对于getCanonicalPath()函数，“.&quot;就表示当前的文件夹，而”..“则表示当前文件夹的上一级文件夹<br>
对于getAbsolutePath()函数，则不管”.”、“..”，返回当前的路径加上你在new File()时设定的路径<br>
至于getPath()函数，得到的只是你在new File()时设定的路径</p>
<p>比如当前的路径为 C:/test ：<br>
File directory = new File(&quot;abc&quot;);<br>
directory.getCanonicalPath(); //得到的是C:/test/abc<br>
directory.getAbsolutePath();    //得到的是C:/test/abc<br>
direcotry.getPath();                    //得到的是abc</p>
<p>File directory = new File(&quot;.&quot;);<br>
directory.getCanonicalPath(); //得到的是C:/test<br>
directory.getAbsolutePath();    //得到的是C:/test/.<br>
direcotry.getPath();                    //得到的是.</p>
<p>File directory = new File(&quot;..&quot;);<br>
directory.getCanonicalPath(); //得到的是C:/<br>
directory.getAbsolutePath();    //得到的是C:/test/..<br>
direcotry.getPath();                    //得到的是..</p>
<p>另外：System.getProperty()中的字符串参数如下：</p>
<pre><code class="language-java">System.getProperty()参数大全 
java.version                                Java Runtime Environment version  
java.vendor                                Java Runtime Environment vendor  
java.vendor.url                           Java vendor URL  
java.home                                Java installation directory  
java.vm.specification.version   Java Virtual Machine specification version  
java.vm.specification.vendor    Java Virtual Machine specification vendor  
java.vm.specification.name      Java Virtual Machine specification name  
java.vm.version                        Java Virtual Machine implementation version  
java.vm.vendor                        Java Virtual Machine implementation vendor  
java.vm.name                        Java Virtual Machine implementation name  
java.specification.version        Java Runtime Environment specification version  
java.specification.vendor         Java Runtime Environment specification vendor  
java.specification.name           Java Runtime Environment specification name  
java.class.version                    Java class format version number  
java.class.path                      Java class path  
java.library.path                 List of paths to search when loading libraries  
java.io.tmpdir                       Default temp file path  
java.compiler                       Name of JIT compiler to use  
java.ext.dirs                       Path of extension directory or directories  
os.name                              Operating system name  
os.arch                                  Operating system architecture  
os.version                       Operating system version  
file.separator                         File separator (&quot;/&quot; on UNIX)  
path.separator                  Path separator (&quot;:&quot; on UNIX)  
line.separator                       Line separator (&quot;/n&quot; on UNIX)  
user.name                        User’s account name  
user.home                              User’s home directory  
user.dir                               User’s current working directory
</code></pre>
<h4 id="java中获取路径">JAVA中获取路径:</h4>
<p><strong>1.jsp中取得路径：</strong></p>
<p>以工程名为TEST为例：</p>
<p>(1)得到包含工程名的当前页面全路径：request.getRequestURI()<br>
结果：/TEST/test.jsp<br>
(2)得到工程名：request.getContextPath()<br>
结果：/TEST<br>
(3)得到当前页面所在目录下全名称：request.getServletPath()<br>
结果：如果页面在jsp目录下 /TEST/jsp/test.jsp<br>
(4)得到页面所在服务器的全路径：application.getRealPath(&quot;页面.jsp&quot;)<br>
结果：D:/resin/webapps/TEST/test.jsp<br>
(5)得到页面所在服务器的绝对路径：absPath=new java.io.File(application.getRealPath(request.getRequestURI())).getParent();<br>
结果：D:/resin/webapps/TEST</p>
<p><strong>2.在类中取得路径：</strong></p>
<p>(1)类的绝对路径：Class.class.getClass().getResource(&quot;/&quot;).getPath()<br>
结果：/D:/TEST/WebRoot/WEB-INF/classes/pack/<br>
(2)得到工程的路径：System.getProperty(&quot;user.dir&quot;)<br>
结果：D:/TEST</p>
<p><strong>3.在Servlet中取得路径：</strong></p>
<p>(1)得到工程目录：request.getSession().getServletContext().getRealPath(&quot;&quot;) 参数可具体到包名。<br>
结果：E:/Tomcat/webapps/TEST<br>
(2)得到IE地址栏地址：request.getRequestURL()<br>
结果：http://localhost:8080/TEST/test<br>
(3)得到相对地址：request.getRequestURI()<br>
结果：/TEST/test</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[利用java正则表达式来解析并获取指定的字符串]]></title>
        <id>https://skytotwo.github.io//post/java-regex</id>
        <link href="https://skytotwo.github.io//post/java-regex">
        </link>
        <updated>2019-08-05T04:27:09.000Z</updated>
        <summary type="html"><![CDATA[<p><strong>Java的正则表达式不仅可以用来匹配验证字符串是否符合标准类型，还可以用来解析字符串，获取自己想要得到的数据。在java.util.regex包下提供了系列的类来对字符串进行匹配。</strong></p>
]]></summary>
        <content type="html"><![CDATA[<p><strong>Java的正则表达式不仅可以用来匹配验证字符串是否符合标准类型，还可以用来解析字符串，获取自己想要得到的数据。在java.util.regex包下提供了系列的类来对字符串进行匹配。</strong></p>
<!-- more -->
<p>来看一下下面的例子：</p>
<pre><code class="language-java">publicstatic String parse (String s){
    Pattern pattern =Pattern.compile(&quot;charset=(.+?)\&quot;&quot;);//匹配的模式
     //通配符中也要加入转移字符 (.+?)代表要查找的内容
    Matcher matcher=pattern.matcher(s);
    while(matcher.find()){
       System.out.println(matcher.group(1)); //每次返回第一个即可 可用groupcount()方法来查看捕获的组数个数
    }
    return s;
}
</code></pre>
<p><strong>要匹配一下类型的字符串：<br>
其中标红的部分为想要获取的数据，注意这里要获取的数据长度不固定，并且可能为unicode<br>
Gb2312等其他编码类型，在这里我们所希望获取的是其编码方式。</strong><br>
具体应用实例：</p>
<pre><code class="language-java">package URL;
import java.NET.*;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.io.BufferedReader;
importjava.io.InputStream;
import java.io.InputStreamReader;
importjava.util.regex.*;
publicclass DataFromURL {
publicstatic String parse (String s){
    Pattern pattern =Pattern.compile(&quot;charset=(.+?)\&quot;&quot;);
    //通配符中也要加入转移字符 (.+?)代表要查找的内容
    Matcher matcher=pattern.matcher(s);
    while(matcher.find()){
       System.out.println(matcher.group(1));
    }
    return s;
}
publicstaticvoidgetDataFromURL(String url){
    try{
        URL u=new URL(url);//通过连接创建URL对象
        BufferedReader reader=new BufferedReader(new       InputStreamReader(u.openStream(),&quot;gb2312&quot;));//采用gb2312方式打开输入流
        intc;
       /*while((c=reader.read())!=-1)//该方法为每个字符读取
        {
            System.out.print((char)c);
        }*/
        String s;
        while((s=reader.readLine())!=null){//不为空一次性读取一行
        //System.out.println(s);
            if(s.contains(&quot;charset&quot;)){
                 parse(s);
            }
        }
    }catch(Exception e){
       e.printStackTrace();
    }
}
}
</code></pre>
<p>附录正则表达式说明：</p>
<p>众所周知，在程序开发中，难免会遇到需要匹配、查找、替换、判断字符串的情况发生，而这些情况有时又比较复杂，如果用纯编码方式解决，往往会浪费程序员的时间及精力。因此，学习及使用正则表达式，便成了解决这一矛盾的主要手段。<br>
大 家都知道，正则表达式是一种可以用于模式匹配和替换的规范，一个正则表达式就是由普通的字符（例如字符a到z）以及特殊字符（元字符）组成的文字模式，它 用以描述在查找文字主体时待匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。<br>
自从jdk1.4推出java.util.regex包，就为我们提供了很好的JAVA正则表达式应用平台。</p>
<p>因为正则表达式是一个很庞杂的体系，所以我仅例举些入门的概念，更多的请参阅相关书籍及自行摸索。</p>
<p>// 反斜杠<br>
/t 间隔 ('/u0009')<br>
/n 换行 ('/u000A')<br>
/r 回车 ('/u000D')<br>
/d 数字 等价于[0-9]<br>
/D 非数字 等价于[^0-9]<br>
/s 空白符号 [/t/n/x0B/f/r]<br>
/S 非空白符号 [^/t/n/x0B/f/r]<br>
/w 单独字符 [a-zA-Z_0-9]<br>
/W 非单独字符 [^a-zA-Z_0-9]<br>
/f 换页符<br>
/e Escape<br>
/b 一个单词的边界<br>
/B 一个非单词的边界<br>
/G 前一个匹配的结束</p>
<p>^为限制开头<br>
^java    条件限制为以Java为开头字符<br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">为</mi><mi mathvariant="normal">限</mi><mi mathvariant="normal">制</mi><mi mathvariant="normal">结</mi><mi mathvariant="normal">尾</mi><mi>j</mi><mi>a</mi><mi>v</mi><mi>a</mi></mrow><annotation encoding="application/x-tex">为限制结尾
java</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">为</span><span class="mord cjk_fallback">限</span><span class="mord cjk_fallback">制</span><span class="mord cjk_fallback">结</span><span class="mord cjk_fallback">尾</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span></span></span></span>    条件限制为以java为结尾字符<br>
.  条件限制除/n以外任意一个单独字符<br>
java..    条件限制为java后除换行外任意两个字符</p>
<p>加入特定限制条件「[]」<br>
[a-z]    条件限制在小写a to z范围中一个字符<br>
[A-Z]    条件限制在大写A to Z范围中一个字符<br>
[a-zA-Z] 条件限制在小写a to z或大写A to Z范围中一个字符<br>
[0-9]    条件限制在小写0 to 9范围中一个字符<br>
[0-9a-z] 条件限制在小写0 to 9或a to z范围中一个字符<br>
[0-9[a-z]] 条件限制在小写0 to 9或a to z范围中一个字符(交集)</p>
<p>[]中加入<sup>后加再次限制条件「[</sup>]」<br>
[^a-z]    条件限制在非小写a to z范围中一个字符<br>
[^A-Z]    条件限制在非大写A to Z范围中一个字符<br>
[^a-zA-Z] 条件限制在非小写a to z或大写A to Z范围中一个字符<br>
[^0-9]    条件限制在非小写0 to 9范围中一个字符<br>
[^0-9a-z] 条件限制在非小写0 to 9或a to z范围中一个字符<br>
[^0-9[a-z]] 条件限制在非小写0 to 9或a to z范围中一个字符(交集)</p>
<p>在限制条件为特定字符出现0次以上时，可以使用「<em>」<br>
J</em>    0个以上J<br>
.*    0个以上任意字符<br>
J.*D    J与D之间0个以上任意字符</p>
<p>在限制条件为特定字符出现1次以上时，可以使用「+」<br>
J+    1个以上J<br>
.+    1个以上任意字符<br>
J.+D    J与D之间1个以上任意字符</p>
<p>在限制条件为特定字符出现有0或1次以上时，可以使用「?」<br>
JA?    J或者JA出现</p>
<p>限制为连续出现指定次数字符「{a}」<br>
J{2}    JJ<br>
J{3}    JJJ<br>
文字a个以上，并且「{a,}」<br>
J{3,}    JJJ,JJJJ,JJJJJ,???(3次以上J并存)<br>
文字个以上，b个以下「{a,b}」<br>
J{3,5}    JJJ或JJJJ或JJJJJ<br>
两者取一「|」<br>
J|A    J或A<br>
Java|Hello    Java或Hello</p>
<p>「()」中规定一个组合类型<br>
比如，我查询index中间的数据，可写作(.+?)</p>
<p>在使用Pattern.compile函数时，可以加入控制正则表达式的匹配行为的参数：<br>
PatternPattern.compile(String regex, int flag)</p>
<p>flag的取值范围如下：<br>
Pattern.CANON_EQ    当且仅当两个字符的&quot;正规分解(canonical decomposition)&quot;都完全相同的情况下，才认定匹配。比如用了这个标志之后，表达式&quot;a/u030A&quot;会匹配&quot;?&quot;。默认情况下，不考虑&quot;规 范相等性(canonical equivalence)&quot;。<br>
Pattern.CASE_INSENSITIVE(?i)    默认情况下，大小写不明感的匹配只适用于US-ASCII字符集。这个标志能让表达式忽略大小写进行匹配。要想对Unicode字符进行大小不明感的匹 配，只要将UNICODE_CASE与这个标志合起来就行了。<br>
Pattern.COMMENTS(?x)    在这种模式下，匹配时会忽略(正则表达式里的)空格字符(译者注：不是指表达式里的&quot;//s&quot;，而是指表达式里的空格，tab，回车之类)。注释从#开始，一直到这行结束。可以通过嵌入式的标志来启用Unix行模式。<br>
Pattern.DOTALL(?s)    在这种模式下，表达式'.'可以匹配任意字符，包括表示一行的结束符。默认情况下，表达式'.'不匹配行的结束符。<br>
Pattern.MULTILINE<br>
(?m)    在这种模式下，'^'和'<span class='katex-error' title='ParseError: KaTeX parse error: Expected group after &#039;^&#039; at position 19: …匹配一行的开始和结束。此外，&#039;^̲&#039;仍然匹配字符串的开始，&#039;'>&#039;分别匹配一行的开始和结束。此外，&#039;^&#039;仍然匹配字符串的开始，&#039;</span>'也匹配字符串的结束。默认情况下，这两个表达式仅仅匹配字符串的开始和结束。<br>
Pattern.UNICODE_CASE<br>
(?u)    在这个模式下，如果你还启用了CASE_INSENSITIVE标志，那么它会对Unicode字符进行大小写不明感的匹配。默认情况下，大小写不敏感的匹配只适用于US-ASCII字符集。<br>
Pattern.UNIX_LINES(?d)    在这个模式下，只有'/n'才被认作一行的中止，并且与'.'，'^'，以及'$'进行匹配。</p>
<p>抛开空泛的概念，下面写出几个简单的Java正则用例：</p>
<p>◆比如，在字符串包含验证时</p>
<p>//查找以Java开头,任意结尾的字符串<br>
Patternpattern = Pattern.compile(&quot;^Java.*&quot;);<br>
Matchermatcher = pattern.matcher(&quot;Java不是人&quot;);<br>
boolean b=matcher.matches();<br>
//当条件满足时，将返回true，否则返回false<br>
System.out.println(b);</p>
<p>◆以多条件分割字符串时<br>
Pattern pattern =Pattern.compile(&quot;[, |]+&quot;);<br>
String[] strs =pattern.split(&quot;Java Hello World  Java,Hello,,World|Sun&quot;);<br>
for (inti=0;i<br>
System.out.println(strs[i]);<br>
}</p>
<p>◆文字替换（首次出现字符）<br>
Pattern pattern =Pattern.compile(&quot;正则表达式&quot;);<br>
Matcher matcher =pattern.matcher(&quot;正则表达式 HelloWorld,正则表达式 Hello World&quot;);<br>
//替换第一个符合正则的数据<br>
System.out.println(matcher.replaceFirst(&quot;Java&quot;));</p>
<p>◆文字替换（全部）<br>
Pattern pattern =Pattern.compile(&quot;正则表达式&quot;);<br>
Matcher matcher =pattern.matcher(&quot;正则表达式 HelloWorld,正则表达式 Hello World&quot;);<br>
//替换第一个符合正则的数据<br>
System.out.println(matcher.replaceAll(&quot;Java&quot;));</p>
<p>◆文字替换（置换字符）<br>
Pattern pattern =Pattern.compile(&quot;正则表达式&quot;);<br>
Matcher matcher =pattern.matcher(&quot;正则表达式 HelloWorld,正则表达式 Hello World &quot;);<br>
StringBuffer sbr =new StringBuffer();<br>
while(matcher.find()) {<br>
matcher.appendReplacement(sbr, &quot;Java&quot;);<br>
}<br>
matcher.appendTail(sbr);<br>
System.out.println(sbr.toString());</p>
<p>◆验证是否为邮箱地址</p>
<p>Stringstr=&quot;ceponline@yahoo.com.cn&quot;;<br>
Pattern pattern =Pattern.compile(&quot;[//w//.//-]+@([//w//-]+//.)+[//w//-]+&quot;,Pattern.CASE_INSENSITIVE);<br>
Matcher matcher =pattern.matcher(str);<br>
System.out.println(matcher.matches());</p>
<p>◆去除html标记<br>
Pattern pattern =Pattern.compile(&quot;&lt;.+?&gt;&quot;, Pattern.DOTALL);<br>
Matcher matcher =pattern.matcher(&quot;主页&quot;);<br>
String string =matcher.replaceAll(&quot;&quot;);<br>
System.out.println(string);</p>
<p>◆查找html中对应条件字符串<br>
Pattern pattern =Pattern.compile(&quot;href=/&quot;(.+?)/&quot;&quot;);<br>
Matcher matcher =pattern.matcher(&quot;主页&quot;);<br>
if(matcher.find())<br>
System.out.println(matcher.group(1));<br>
}</p>
<p>◆截取http://地址<br>
//截取url<br>
Pattern pattern =Pattern.compile(&quot;(http://|https://){1}[//w//.//-/:]+&quot;);<br>
Matcher matcher =pattern.matcher(&quot;dsdsdsfdf&quot;);<br>
StringBuffer buffer= new StringBuffer();<br>
while(matcher.find()){<br>
buffer.append(matcher.group());<br>
buffer.append(&quot;/r/n&quot;);<br>
System.out.println(buffer.toString());<br>
}</p>
<p>◆替换指定{}中文字</p>
<p>String str =&quot;Java目前的发展史是由{0}年-{1}年&quot;;<br>
String[][]object={new String[]{&quot;//{0//}&quot;,&quot;1995&quot;},newString[]{&quot;//{1//}&quot;,&quot;2007&quot;}};<br>
System.out.println(replace(str,object));</p>
<pre><code class="language-java">public staticString replace(final String sourceString,Object[] object) {
	Stringtemp=sourceString;    
	for(int i=0;i
		String[]result=(String[])object[i];
		Pattern   pattern = Pattern.compile(result[0]);
		Matcher matcher =pattern.matcher(temp);
		temp=matcher.replaceAll(result[1]);
		}
		return temp;
}

</code></pre>
<p>◆以正则条件查询指定目录下文件</p>
<pre><code class="language-java">//用于缓存文件列表
      private ArrayList files = new ArrayList();
      //用于承载文件路径
      private String _path;
      //用于承载未合并的正则公式
      private String _regexp;

      class MyFileFilter implements FileFilter {

            /**
             * 匹配文件名称
             */
            public boolean accept(File file) {
              try {
                Patternpattern = Pattern.compile(_regexp);
                Matchermatch = pattern.matcher(file.getName());               
                returnmatch.matches();
              } catch (Exception e) {
                returntrue;
              }
            }
          }

      /**
       * 解析输入流
       * @param inputs
       */
      FilesAnalyze (String path,String regexp){
          getFileName(path,regexp);
      }

      /**
       * 分析文件名并加入files
       * @param input
       */
      private void getFileName(String path,String regexp) {
          //目录
            _path=path;
            _regexp=regexp;
            File directory = new File(_path);
            File[] filesFile =directory.listFiles(new MyFileFilter());
            if (filesFile == null) return;
            for (int j = 0; j
             files.add(filesFile[j]);
            }
            return;
          }

      /**
       * 显示输出信息
       * @param out
       */
      public void print (PrintStream out) {
          Iterator elements = files.iterator();
          while (elements.hasNext()) {
              File file=(File)elements.next();
                 out.println(file.getPath());    
          }
      }

      public static void output(String path,String regexp) {

          FilesAnalyze fileGroup1 = newFilesAnalyze(path,regexp);
          fileGroup1.print(System.out);
      }

      public static void main (String[] args) {
         output(&quot;C://&quot;,&quot;[A-z|.]*&quot;);
      }
</code></pre>
<p>Java正则的功用还有很多，事实上只要是字符处理，就没有正则做不到的事情存在。（当然，正则解释时较耗时间就是了|||……）</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java程序实现删除本地文件]]></title>
        <id>https://skytotwo.github.io//post/java-delete-file</id>
        <link href="https://skytotwo.github.io//post/java-delete-file">
        </link>
        <updated>2019-08-05T04:19:50.000Z</updated>
        <summary type="html"><![CDATA[<p>之前有用到过在项目里删除本地文件，记录下代码。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前有用到过在项目里删除本地文件，记录下代码。</p>
<!-- more -->
<pre><code class="language-java">import Java.io.File;
public class Test {
public static void main(String args[]) {
   Test t = new Test();
   delFolder(&quot;d:/test&quot;);
   System.out.println(&quot;OK&quot;);
}
// 删除文件夹
// param folderPath 文件夹完整绝对路径
public static void delFolder(String folderPath) {
   try {
    delAllFile(folderPath); // 删除完里面所有内容
    String filePath = folderPath;
    filePath = filePath.toString();
    java.io.File myFilePath = new java.io.File(filePath);
    myFilePath.delete(); // 删除空文件夹
   } catch (Exception e) {
    e.printStackTrace();
   }
}
// 删除指定文件夹下所有文件
// param path 文件夹完整绝对路径
public static boolean delAllFile(String path) {
   boolean flag = false;
   File file = new File(path);
   if (!file.exists()) {
    return flag;
   }
   if (!file.isDirectory()) {
    return flag;
   }
   String[] tempList = file.list();
   File temp = null;
   for (int i = 0; i &lt; tempList.length; i++) {
    if (path.endsWith(File.separator)) {
     temp = new File(path + tempList[i]);
    } else {
temp = new File(path + File.separator + tempList[i]);
    }
    if (temp.isFile()) {
     temp.delete();
    }
    if (temp.isDirectory()) {
       delAllFile(path + &quot;/&quot; + tempList[i]);// 先删除文件夹里面的文件
       delFolder(path + &quot;/&quot; + tempList[i]);// 再删除空文件夹
     flag = true;
    }
   }
   return flag;
}
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网页登陆页面设置Cookie]]></title>
        <id>https://skytotwo.github.io//post/js-cookie-set</id>
        <link href="https://skytotwo.github.io//post/js-cookie-set">
        </link>
        <updated>2019-08-05T04:11:45.000Z</updated>
        <summary type="html"><![CDATA[<p>cookie是保存http协议状态的一个重要手段，基本上所有网站都会使用到cookie机制，cookie是session的一个实现方式，当然现在还有token来代替cookie，但cookie依旧是很重要的一个模式，这里在js中实现设置cookie进而实现登陆访问。</p>
]]></summary>
        <content type="html"><![CDATA[<p>cookie是保存http协议状态的一个重要手段，基本上所有网站都会使用到cookie机制，cookie是session的一个实现方式，当然现在还有token来代替cookie，但cookie依旧是很重要的一个模式，这里在js中实现设置cookie进而实现登陆访问。</p>
<!-- more -->
<pre><code class="language-javascript">&lt;%@ page contentType=&quot;text/html; charset=GB2312&quot;%&gt;
&lt;%@ page import=&quot;tellhow.commonweb.system.*&quot; %&gt;
&lt;%
   String useraccounts=&quot;&quot;;
   String userpassword=&quot;&quot;;
   String Messageinfo=&quot;请输入用户信息&quot;;
   useraccounts=request.getParameter(&quot;accounts&quot;);
   userpassword=request.getParameter(&quot;password&quot;);
   String flag = request.getParameter(&quot;flag&quot;)==null?&quot;&quot;:request.getParameter(&quot;flag&quot;);//flag为1则为从oms系统登陆 
   if(useraccounts!=null&amp;&amp;userpassword!=null){
   if(!useraccounts.equals(&quot;null&quot;)&amp;&amp;!useraccounts.equals(&quot;&quot;)&amp;&amp;!userpassword.equals(&quot;null&quot;)&amp;&amp;!userpassword.equals(&quot;&quot;)){
   loginBean myloginbean=new loginBean();
   myloginbean.init(pageContext);
   int retval;
   retval=myloginbean.checkuserlogin(useraccounts,userpassword,flag);
   switch(retval)
   {
      case 1:
         // response.sendRedirect(&quot;system/index_manage.jsp&quot;);
         // response.sendRedirect(&quot;gz/index.jsp&quot;);
         String url = request.getContextPath() + &quot;/getUserMsg.do?method=getUserInfo&amp;username=&quot; + useraccounts;
         System.out.println(url);
         response.sendRedirect(url);
      break;
      case -1:
          Messageinfo=&quot;您输入的密码不对，请重新输入!&quot;;
      break;
      case -2:
          Messageinfo=&quot;您输入的用户不存在，请重新输入!&quot;;
      break;
   }
   }
 }
%&gt;
&lt;script language=&quot;javascript&quot; type=&quot;text/javascript&quot;&gt;
	function window_Onload(){
	  loginfrm.accounts.focus();
	}
	function onInputKeyup(){
	  if(event.keyCode==13){
	  		if(event.srcElement.name==&quot;accounts&quot;){
	      		loginfrm.password.focus();
	      		return;
    		}
    		if(event.srcElement.name==&quot;password&quot;){
	      		loginfrm.submit();
	      		return;
    		}
  	  }
	}
&lt;/script&gt;
&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;
&quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=gb2312&quot;&gt;
&lt;title&gt;网站管理系统&lt;/title&gt;
&lt;!--[if lte IE 6]&gt;
&lt;script src=&quot;../css/mycss/js/DD_belatedPNG_0.0.8a.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    DD_belatedPNG.fix('*');
&lt;/script&gt;
&lt;![endif]--&gt;
&lt;link href=&quot;css/mycss/style/public.css&quot; type=&quot;text/css&quot; rel=&quot;stylesheet&quot; /&gt;
&lt;script src=&quot;css/mycss/js/jquery.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;css/mycss/js/index.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/jquery-1.8.3.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;js/jquery.cookie.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body  onload=&quot;window_Onload();getCookie();&quot;&gt;
&lt;FORM action=login.jsp method=post name=&quot;loginfrm&quot;&gt;
&lt;div class=&quot;main_area&quot;&gt;
    &lt;div class=&quot;main_left_area&quot;&gt;&lt;img src=&quot;css/mycss/images/logo_bg01.png&quot; width=&quot;280&quot; height=&quot;130&quot; /&gt;&lt;/div&gt;
    &lt;div class=&quot;main_mid_area&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;main_right_area&quot;&gt;&lt;/div&gt;
    &lt;div class=&quot;main_info_area&quot;&gt;
        &lt;div class=&quot;fill01_area&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;title_area&quot;&gt;&lt;img src=&quot;css/mycss/images/main_bg02.png&quot; width=&quot;487&quot; height=&quot;46&quot; alt=&quot;网站管理系统&quot;/&gt;&lt;/div&gt;
        &lt;div class=&quot;fill02_area&quot;&gt;&lt;/div&gt;
        &lt;div class=&quot;login_area&quot;&gt;
            &lt;div class=&quot;login_left_area&quot;&gt;
                &lt;div class=&quot;fill03_area&quot;&gt;&lt;/div&gt;
                &lt;div class=&quot;login_info_area&quot;&gt;
                    &lt;span&gt;用户名：&lt;/span&gt;&lt;input name=&quot;accounts&quot; id=&quot;accounts&quot; type=&quot;text&quot; onkeyup=&quot;onInputKeyup();&quot;&gt;
                    &lt;div class=&quot;fill04_area&quot;&gt;&lt;/div&gt;
                    &lt;span&gt;密　码：&lt;/span&gt;&lt;input name=&quot;password&quot; id=&quot;password&quot; type=&quot;password&quot; onkeyup=&quot;onInputKeyup();&quot;&gt;
                &lt;/div&gt;
            &lt;/div&gt;
            &lt;div class=&quot;login_right_area&quot;&gt;
                &lt;a  onclick=&quot;savedata();&quot;&gt;&lt;/a&gt;
            &lt;/div&gt;
            &lt;!-- &lt;a class=&quot;href03_area&quot; href=&quot;/login.jsp?accounts=guest&amp;password=1&quot;&gt;&lt;span &gt;&lt;/span&gt;&lt;font face=&quot;verdana&quot; size=&quot;3&quot; color=&quot;black&quot;&gt; 来宾访问&lt;/font&gt;&lt;/a&gt; --&gt;
        &lt;/div&gt;
        &lt;div class=&quot;login_href_area&quot;&gt;
            &lt;input type=&quot;checkbox&quot; id=&quot;boxchange&quot; name=&quot;checkbox&quot; value=&quot;1&quot;/&gt;
            &lt;a&gt;记住用户名密码&lt;/a&gt;
            &lt;a class=&quot;href03_area&quot; href=&quot;/login.jsp?accounts=guest&amp;password=1&quot;&gt;&lt;/a&gt;
        &lt;/div&gt;
        &lt;div class=&quot;flag_area&quot;&gt;&lt;%=Messageinfo%&gt;&lt;/div&gt;
        &lt;div &gt;&lt;/div&gt;
        &lt;div &gt;&lt;/div&gt;
        &lt;div class=&quot;login_href_areabottom&quot;&gt;&lt;font &gt;调控中心用户请使用OMS账户登录,其他用户请点击“来宾访问”&lt;/font&gt;&lt;/div&gt;
        &lt;div class=&quot;foot_area&quot;&gt;广州供电局有限公司 版权所有  技术支持:泰豪软件&lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/form&gt;
&lt;/body&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
	var checkstate = null;//标识符，是为了在保存前调用设置cookie方法的进行判断
	$(&quot;#boxchange&quot;).change(function() { 
		if(document.all.checkbox.checked){ 
        	 checkstate = &quot;1&quot;;
         }else{
        	 checkstate = &quot;0&quot;;
        }
         
	});
	function savedata(){
		//存储cookie
	  	if(&quot;1&quot; == checkstate){  
				setCookie();
				//$.cookie(&quot;pwd&quot;,&quot;&quot;);
		}else if(&quot;0&quot; == checkstate){
			$.cookie('login_code', null, { expires: -1 });
	  		$.cookie('pwd', null, { expires: -1 });
		}
		loginfrm.submit();
	}
		
	//设置cookie
	function setCookie(){ //设置cookie    
       var loginCode = $(&quot;#accounts&quot;).val(); //获取用户名信息    
       var pwd = $(&quot;#password&quot;).val(); //获取登陆密码信息    
       $.cookie('login_code',loginCode, { expires: 7 });//调用jquery.cookie.js中的方法设置cookie中的用户名    
       $.cookie('pwd',pwd, { expires: 7 });//调用jquery.cookie.js中的方法设置cookie中的登陆密码
    }   
	function getCookie(){ //获取cookie    
        var loginCode = $.cookie('login_code'); //获取cookie中的用户名    
        var pwd =  $.cookie('pwd'); //获取cookie中的登陆密码    
        if(loginCode){//用户名存在的话把用户名填充到用户名文本框    
           $(&quot;#accounts&quot;).val(loginCode);    
        }    
        if(pwd){//密码存在的话把密码填充到密码文本框    
           $(&quot;#password&quot;).val(pwd);   
        } 
      //选中保存秘密的复选框
        if(loginCode != null &amp;&amp; loginCode != '' &amp;&amp; pwd != null &amp;&amp; pwd != ''){
        $(&quot;[name='checkbox']&quot;).attr(&quot;checked&quot;,&quot;true&quot;);   
       	   checkstate = &quot;1&quot;;
         }else{
         	checkstate = &quot;0&quot;;
      }
 }     

&lt;/script&gt;
&lt;/html&gt;

</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Scrapy Item Loaders机制详解]]></title>
        <id>https://skytotwo.github.io//post/scrapy-item-loaders</id>
        <link href="https://skytotwo.github.io//post/scrapy-item-loaders">
        </link>
        <updated>2019-08-05T04:03:20.000Z</updated>
        <summary type="html"><![CDATA[<p>scrapy中的item其实设计上使用的是面向对象的模式，将爬取的数据字段组合封装，进一步交由管道处理存储，这里对其机制做相关讲解。</p>
]]></summary>
        <content type="html"><![CDATA[<p>scrapy中的item其实设计上使用的是面向对象的模式，将爬取的数据字段组合封装，进一步交由管道处理存储，这里对其机制做相关讲解。</p>
<!-- more -->
<h4 id="1-items"><strong>1. Items</strong></h4>
<p>爬虫的主要任务就是从非结构化的数据中获得结构化的数据。<br>
Item 对象是种简单的容器，保存了爬取到得数据。 其提供了 类似于词典(dictionary-like) 的API以及用于声明可用字段的简单语法。</p>
<p><strong>声明Item</strong><br>
Item使用简单的class定义语法以及 Field 对象来声明。例如:</p>
<pre><code class="language-python">import scrapy

class Product(scrapy.Item):
    name = scrapy.Field()
    price = scrapy.Field()
    stock = scrapy.Field()
    last_updated = scrapy.Field(serializer=str)
</code></pre>
<p><strong>Item字段：</strong><br>
Field 对象指明了每个字段的元数据(metadata)。例如上面例子中 last_updated 中指明了该字段的序列化函数。</p>
<p>可以为每个字段指明任何类型的元数据。Field 对象对接受的值没有任何限制。Field 对象中保存的每个键可以由多个组件使用，并且只有这些组件知道这个键的存在。设置 Field 对象的主要目的就是在一个地方定义好所有的元数据。</p>
<p>需要注意的是，用来声明item的 Field 对象并没有被赋值为class的属性。 不过您可以通过 Item.fields 属性进行访问。</p>
<h4 id="2-用item-loader来填充item"><strong>2. 用Item Loader来填充Item</strong></h4>
<p>Item Loaders提供了一种便捷的方式填充抓取到的 Items 。 虽然Items可以使用自带的类字典形式API填充，但是Items Loaders提供了更便捷的API， 可以分析原始数据并对Item进行赋值。</p>
<p>从另一方面来说， Items 提供保存抓取数据的 容器 ， 而 Item Loaders提供的是 填充 容器的机制。</p>
<p>Item Loaders提供的是一种灵活，高效的机制，可以更方便的被spider或source format (HTML, XML, etc)扩展，并override更易于维护的、不同的内容分析规则。</p>
<p>要使用Item Loader, 你必须先将它实例化. 可以使用类似字典的对象来进行实例化, 或者不使用对象也可以, 当不用对象进行实例化的时候,Item会自动使用 ItemLoader.default_item_class 属性中指定的Item 类在Item Loader constructor中实例化.</p>
<p>然后,你开始收集数值到Item Loader时,通常使用 Selectors. 你可以在同一个item field 里面添加多个数值;Item Loader将知道如何用合适的处理函数来“添加”这些数值.</p>
<p>下面是在 Spider 中典型的Item Loader的用法, 使用 Items chapter 中声明的 Product item:</p>
<pre><code class="language-python">from scrapy.contrib.loader import ItemLoader
from myproject.items import Product

def parse(self, response):
    l = ItemLoader(item=Product(), response=response)
    l.add_xpath('name', '//div[@class=&quot;product_name&quot;]')
    l.add_xpath('name', '//div[@class=&quot;product_title&quot;]')
    l.add_xpath('price', '//p[@id=&quot;price&quot;]')
    l.add_css('stock', 'p#stock]')
    l.add_value('last_updated', 'today') # you can also use literal values
    return l.load_item()
</code></pre>
<p>我们可以看到发现 name 字段被从页面中两个不同的XPath位置提取:</p>
<pre><code class="language-python">//div[@class=&quot;product_name&quot;]
//div[@class=&quot;product_title&quot;]
</code></pre>
<p>换言之,数据通过用 add_xpath() 的方法,把从两个不同的XPath位置提取的数据收集起来. 这是将在以后分配给 name 字段中的数据｡</p>
<p>之后,类似的请求被用于 price 和 stock 字段 (后者使用 CSS selector 和 add_css() 方法), 最后使用不同的方法 add_value() 对 last_update 填充文本值( today ).</p>
<p>最终, 当所有数据被收集起来之后, 调用 ItemLoader.load_item() 方法, 实际上填充并且返回了之前通过调用 add_xpath(), add_css(), and add_value() 所提取和收集到的数据的Item.</p>
<h4 id="3-输入处理器与输出处理器"><strong>3. 输入处理器与输出处理器</strong></h4>
<ol>
<li>Item Loader在每个字段中都包含了一个输入处理器和一个输出处理器｡</li>
<li>输入处理器收到数据时立刻提取数据 (通过 add_xpath(), add_css() 或者 add_value() 方法) 之后输入处理器的结果被收集起来并且保存在ItemLoader内(但尚未分配给该Item).</li>
<li>收集到所有的数据后, 调用 ItemLoader.load_item() 方法来填充,并得到填充后的 Item 对象。在这一步中先调用输出处理器来处理之前收集到的数据，然后再存入Item中。输出处理器的结果是被分配到Item的最终值｡</li>
</ol>
<p>需要注意的是，输入和输出处理器都是可调用对象，调用时传入需要被分析的数据， 处理后返回分析得到的值。因此你可以使用任意函数作为输入、输出处理器。 唯一需注意的是它们必须接收一个（并且只是一个）迭代器性质的positional参数。</p>
<h4 id="4-声明items-loaders"><strong>4. 声明Items Loaders</strong></h4>
<p>Item Loaders 的声明类似于Items，以class的语法来声明：</p>
<pre><code class="language-python">from scrapy.contrib.loader import ItemLoader
from scrapy.contrib.loader.processor import TakeFirst, MapCompose, Join

class ProductLoader(ItemLoader):
    default_output_processor = TakeFirst()
    name_in = MapCompose(unicode.title)
    name_out = Join()
    price_in = MapCompose(unicode.strip)
    # ...
</code></pre>
<p>input processors 以_in为后缀来声明，output processors 以_out 为后缀来声明。也可以用ItemLoader.default_input_processor 和ItemLoader.default_output_processor 属性来声明默认的 input/output processors。</p>
<h4 id="5-声明input-and-output-processors"><strong>5. 声明Input and Output Processors</strong></h4>
<p>前面讲到，input and output processors可以在定义Item Loaders的时候声明，这是非常普遍的使用方法。但是，你也可以在定义Item的时候声明输入输出处理器。下面是例子：</p>
<pre><code class="language-python">import scrapy
from scrapy.contrib.loader.processor import Join, MapCompose, TakeFirst
from w3lib.html import remove_tags

def filter_price(value):
    if value.isdigit():
        return value

class ProductItem(scrapy.Item):
    name = scrapy.Field(
        input_processor=MapCompose(remove_tags),
        output_processor=Join(),
    )
    price = scrapy.Field(
        input_processor=MapCompose(remove_tags, filter_price),
        output_processor=TakeFirst(),
    )
</code></pre>
<p>使用Item：</p>
<pre><code class="language-bash">&gt;&gt;&gt; from scrapy.contrib.loader import ItemLoader
&gt;&gt;&gt; il = ItemLoader(item=Product())
&gt;&gt;&gt; il.add_value('name', [u'Welcome to my', u'&lt;strong&gt;website&lt;/strong&gt;'])
&gt;&gt;&gt; il.add_value('price', [u'€', u'&lt;span&gt;1000&lt;/span&gt;'])
&gt;&gt;&gt; il.load_item()
{'name': u'Welcome to my website', 'price': u'1000'}
</code></pre>
<p>关于集中声明 input and output processors方式的优先级排序如下：</p>
<ol>
<li>在Item Loader 中声明的 field-specific 属性: field_in and field_out (most precedence)</li>
<li>Item中的字段元数据(input_processor and output_processor key)</li>
<li>Item Loader 默认处理器: ItemLoader.default_input_processor() and ItemLoader.default_output_processor() (least precedence)</li>
</ol>
<h4 id="6-item-loader-context"><strong>6. Item Loader Context</strong></h4>
<p>Item Loader Context 是一个被Item Loader中的输入输出处理器共享的任意的键值对字典。它能在Item Loader声明、实例化、使用的时候传入。它用于调整输入输出处理器的行为。</p>
<p>举例来讲，函数parse_length用于接收text值并且获取其长度：</p>
<pre><code class="language-python">def parse_length(text, loader_context):
    unit = loader_context.get('unit', 'm')
    # ... length parsing code goes here ... 
    return parsed_length
</code></pre>
<p>通过接收一个loader_context参数，这个函数告诉Item Loader它能够接收Item Loader context。于是当函数被调用的时候Item Loader传递当前的active context给它。</p>
<p>有多种方式改变Item Loader context的值：</p>
<ol>
<li>
<p>修改当前 active Item Loader context：</p>
<p>loader = ItemLoader(product)<br>
loader.context[‘unit’] = ‘cm’</p>
</li>
<li>
<p>在Item Loader实例化的时候：</p>
<p>loader = ItemLoader(product, unit=’cm’)</p>
</li>
<li>
<p>对于那些支持带Item Loader context实例化的输入输出处理器（例如MapCompose），在Item Loader声明的时候修改它context：</p>
<pre><code class="language-python">class ProductLoader(ItemLoader): 
length_out = MapCompose(parse_length, unit=’cm’)
</code></pre>
</li>
</ol>
<h4 id="7-itemloader-object"><strong>7. ItemLoader object</strong></h4>
<p>参见官方文档</p>
<h4 id="8-重用和扩展item-loaders"><strong>8. 重用和扩展Item Loaders</strong></h4>
<p>当你的项目逐渐变大，使用了越来越多的spider的时候，维护变成了一个基本的问题。尤其是当你需要处理每个spider的许多不同的解析规则的时候，会出现很多的异常，迫使你开始考虑重用的问题。</p>
<p>Item Loader支持传统的Python继承机制来处理spider之间的差异。</p>
<p>例如，有些网站把它们的产Product名用三个短线封装起来（如：---Plasma TV---），而你想要去掉这些东西。</p>
<p>你可以通过reusing and extending默认Product Item Loader的方式去掉短线：</p>
<pre><code class="language-python">from scrapy.loader.processors import MapCompose
from myproject.ItemLoaders import ProductLoader

def strip_dashes(x):
    return x.strip('-')

class SiteSpecificLoader(ProductLoader):
    name_in = MapCompose(strip_dashes, ProductLoader.name_in)
</code></pre>
<p>另一种情形时继承Item Loader也很有用：有多种格式的源数据（如XML, HTML），在XML版本里面你想要去除CDATA:</p>
<pre><code class="language-python">from scrapy.loader.processors import MapCompose
from myproject.ItemLoaders import ProductLoader
from myproject.utils.xml import remove_cdata

class XmlProductLoader(ProductLoader):
    name_in = MapCompose(remove_cdata, ProductLoader.name_in)
</code></pre>
<p>这便是扩展输入处理器的方法。</p>
<ul>
<li>
<p>对于输出处理器，更常用的方式是在Item字段元数据里声明。因为通常它们依赖于具体的字段而不是网站。</p>
</li>
<li>
<p>还有很多其他方式开扩展、继承和覆盖Item Loader，不同的层次结构适于不同的项目。Scrapy只是提供了这些机制，不强制要求具体的组织方式。</p>
</li>
</ul>
<h4 id="9-内置的处理器"><strong>9. 内置的处理器</strong></h4>
<p>尽管你可以使用可调用的函数作为输入输出处理器，Scrapy提供了一些常用的处理器。有些处理器，如MapCompose（通常用于输入处理器），能把多个函数执行的结果按顺序组合起来产生最终的输出。</p>
<p>下面是一些内置的处理器：</p>
<p><strong>9.1 Identity</strong></p>
<p>class scrapy.loader.processors.Identity<br>
最简单的处理器，不进行任何处理，直接返回原来的数据。无参数。</p>
<p><strong>9.2 TakeFirst</strong></p>
<p>class scrapy.loader.processors.TakeFirst<br>
返回第一个非空(non-null/non-empty)值，常用于单值字段的输出处理器。无参数。</p>
<p>示例如下：</p>
<pre><code class="language-python">&gt;&gt;&gt; from scrapy.loader.processors import TakeFirst
&gt;&gt;&gt; proc = TakeFirst()
&gt;&gt;&gt; proc(['', 'one', 'two', 'three'])
'one'
</code></pre>
<p><strong>9.3 Join</strong></p>
<p>class scrapy.loader.processors.Join(separator=u’ ‘)<br>
返回用分隔符连接后的值。分隔符默认为空格。不接受Loader contexts。</p>
<p>当使用默认分隔符的时候，这个处理器等同于这个函数：</p>
<pre><code class="language-python">u' '.join
</code></pre>
<p>使用示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from scrapy.loader.processors import Join
&gt;&gt;&gt; proc = Join()
&gt;&gt;&gt; proc(['one', 'two', 'three'])
u'one two three'
&gt;&gt;&gt; proc = Join('&lt;br&gt;')
&gt;&gt;&gt; proc(['one', 'two', 'three'])
u'one&lt;br&gt;two&lt;br&gt;three'
</code></pre>
<p><strong>9.4 Compose</strong></p>
<p>class scrapy.loader.processors.Compose(*functions, **default_loader_context)<br>
用给定的多个函数的组合而构造的处理器。每个输入值被传递到第一个函数，然后其输出再传递到第二个函数，诸如此类，直到最后一个函数返回整个处理器的输出。</p>
<p>默认情况下，当遇到None值的时候停止处理。可以通过传递参数stop_on_none=False改变这种行为。</p>
<p>使用示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from scrapy.loader.processors import Compose
&gt;&gt;&gt; proc = Compose(lambda v: v[0], str.upper)
&gt;&gt;&gt; proc(['hello', 'world'])
'HELLO'
</code></pre>
<p>每个函数可以选择接收一个loader_context参数。</p>
<p><strong>9.5 MapCompose</strong></p>
<p>class scrapy.loader.processors.MapCompose(*functions, **default_loader_context)<br>
与Compose处理器类似，区别在于各个函数结果在内部传递的方式：</p>
<ol>
<li>
<p>输入值是被迭代的处理的，每一个元素被单独传入第一个函数进行处理。处理的结果被l连接起来(concatenate)形成一个新的迭代器，并被传入第二个函数，以此类推，直到最后一个函数。最后一个函数的输出被连接起来形成处理器的输出。</p>
</li>
<li>
<p>每个函数能返回一个值或者一个值列表，也能返回None(会被下一个函数所忽略)</p>
</li>
<li>
<p>这个处理器提供了方便的方式来组合多个处理单值的函数。因此它常用与输入处理器，因为用extract()函数提取出来的值是一个unicode strings列表。</p>
</li>
</ol>
<p>下面的例子能说明这个处理器的工作方式：</p>
<pre><code class="language-python">&gt;&gt;&gt; def filter_world(x):
...     return None if x == 'world' else x
...
&gt;&gt;&gt; from scrapy.loader.processors import MapCompose
&gt;&gt;&gt; proc = MapCompose(filter_world, unicode.upper)
&gt;&gt;&gt; proc([u'hello', u'world', u'this', u'is', u'scrapy'])
[u'HELLO, u'THIS', u'IS', u'SCRAPY']
</code></pre>
<p>与Compose处理器类似，它也能接受Loader context。</p>
<p><strong>9.6 SelectJmes</strong></p>
<p>class scrapy.loader.processors.SelectJmes(json_path)<br>
查询指定的JSON path并返回输出。需要jmespath(https://github.com/jmespath/jmespath.py)支持。每次接受一个输入。</p>
<p>示例：</p>
<pre><code class="language-python">&gt;&gt;&gt; from scrapy.loader.processors import SelectJmes, Compose, MapCompose
&gt;&gt;&gt; proc = SelectJmes(&quot;foo&quot;) #for direct use on lists and dictionaries
&gt;&gt;&gt; proc({'foo': 'bar'})
'bar'
&gt;&gt;&gt; proc({'foo': {'bar': 'baz'}})
{'bar': 'baz'}
</code></pre>
<p>与Json一起使用：</p>
<pre><code class="language-python">&gt;&gt;&gt; import json
&gt;&gt;&gt; proc_single_json_str = Compose(json.loads, SelectJmes(&quot;foo&quot;))
&gt;&gt;&gt; proc_single_json_str('{&quot;foo&quot;: &quot;bar&quot;}')
u'bar'
&gt;&gt;&gt; proc_json_list = Compose(json.loads, MapCompose(SelectJmes('foo')))
&gt;&gt;&gt; proc_json_list('[{&quot;foo&quot;:&quot;bar&quot;}, {&quot;baz&quot;:&quot;tar&quot;}]')
[u'bar']
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[python中dict和set实现原理]]></title>
        <id>https://skytotwo.github.io//post/python-dict-set</id>
        <link href="https://skytotwo.github.io//post/python-dict-set">
        </link>
        <updated>2019-08-05T03:55:32.000Z</updated>
        <summary type="html"><![CDATA[<p>python的dict和set设计上是很巧妙的，底层是用c语言编写，哈希表实现，这样确保了高效的数据处理。</p>
]]></summary>
        <content type="html"><![CDATA[<p>python的dict和set设计上是很巧妙的，底层是用c语言编写，哈希表实现，这样确保了高效的数据处理。</p>
<!-- more --> 
<p>1、dict的性能远高于list<br>
2、list的查询消耗随着查询数量的增大而增大<br>
3、dict的查询消耗并不会随着查询数量的增大而增大</p>
<p><strong>dict内部实现是根据哈西表来实现的：</strong><br>
<img src="http://picture.totoro.site/images/2019/08/05/20180407100709_810.png" alt="20180407100709_810.png"></p>
<p>1、当申明dict变量的时候，就会在内存中开辟一个连续的数组空间。<br>
2、连续的空间是允许存在空白的，这是为了后续能够实现在原空间内插入数据。<br>
3、如果在后续插入数据的时候，发现原空间中空白的比例小于原空间的三分之一，就会再申请开辟一段连续啊的空间用于存储，将原有的数据搬迁出来和新的数据一起插入新的空间中。（这时候顺序会打乱）<br>
4、dict查找时，会根据key值计算出在hash表中的位置，hash表中的键值对位置是唯一的。计算的方式是根据key值的后一位组合元素进行计算，计算过程中如果发现hash表中已经存在值，就加上key值前一位进行计算，最终找出value值的位置。如下：<br>
<img src="http://picture.totoro.site/images/2019/08/05/20180407102108_979.png" alt="20180407102108_979.png"><br>
abc —— key ，根据c来计算位置，如果计算结果被别的值占据，则用bc来计算。</p>
<p>5、dict查找性能快的原因是，直接对key值进行hash计算，因为开辟的数组空间是连续的，有偏移量的，直接将偏移量返回，就能马上找到value值在哪里。</p>
<hr>
<p><strong>原理概要</strong><br>
1、dict或者set的值，都必须是可以hash的，不可变的值都是可以被hash的，如str、fronzenset、tuple，或者自己定义的类，实现了__hash__这个魔法方法的，都可以被hash。<br>
2、dict的内存花销大，但是查询速度快，自定义的对象或者python的内部对象都是用dict来包装的。<br>
3、dict的存储顺序和元素的添加顺序有关。<br>
4、添加数据有可能改变已有数据的顺序。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[微信小程序学习记要（上）]]></title>
        <id>https://skytotwo.github.io//post/wechat-miniapp-learning-mark</id>
        <link href="https://skytotwo.github.io//post/wechat-miniapp-learning-mark">
        </link>
        <updated>2019-08-05T03:49:54.000Z</updated>
        <summary type="html"><![CDATA[<p>几年前小程序火爆的时候，自己也跟着学习了一下，有许多小细节需要注意的，这里做一点记录</p>
]]></summary>
        <content type="html"><![CDATA[<p>几年前小程序火爆的时候，自己也跟着学习了一下，有许多小细节需要注意的，这里做一点记录</p>
<!-- more -->
<p>1、图片等尺寸应该使用rpx自适应标准，素材应该选用iphone6作为标准。<br>
遵循原则是：1px（物理像素）=1rpx=0.5pt（逻辑像素）<br>
所以如果素材是750px，则编写尺寸则是750rpx。<br>
2、在页面布局中，横向元素应该使用rpx，纵向大部分情况下是使用px，因为横向拉伸效果明显，需要自适应。<br>
3、编写样式的时候，可以用class或者style。而其中规则是，一般静态的样式，不太会改变的样式就用class，一些动态的样式就用style，style每一次编译的时候都回去解析样式，性能上来说，所有都放在style里，性能会降低。<br>
4、要让元素隐藏，可以使用wx:if=&quot;false&quot;,false的值也可以从js中绑定过来，用{{false}}表示。<br>
5、数据绑定wx:for所传的对象的代称为“wx:for-item=item”。<br>
6、wx:for 循环需要放在block块中，如下：</p>
<pre><code class="language-xml">&lt;block wx:for=&quot;{{posts_key}}&quot;&gt;
    ......
&lt;/block&gt;
</code></pre>
<p>7、点击冒泡事件：除了submit等少数事件外，其余均符合冒泡事件。即触发子元素后，父元素也会被触发。如果不想触发父元素，可以不使用bind前缀，使用catch前缀。<br>
8、使用template模板的原因，是因为将循环代码块抽离，可以达到多个页面复用的效果，直接引入就可以使用。<br>
9、template模板在 wx:for 循环中的使用，传递数据可以直接data=&quot;{{item}}&quot;,如下：</p>
<pre><code class="language-xml">&lt;block wx:for=&quot;{{posts_key}}&quot;&gt;
    &lt;!-- template--&gt;
    &lt;template is=&quot;postItem&quot; data=&quot;{{item}}&quot;/&gt;
&lt;/block&gt;
</code></pre>
<p>10、以下是几种引入方式：<br>
js引入方式（必须是相对路径，不然会报错！）</p>
<pre><code class="language-javascript">var postsData = require('../../data/posts-data.js');
</code></pre>
<p>template在wxml中的引入（路径可以相对也可以绝对）</p>
<pre><code class="language-xml">&lt;import src=&quot;post-item/post-item-template.wxml&quot;/&gt;
</code></pre>
<p>样式文件在wxss中的引入</p>
<pre><code class="language-xml">@import &quot;post-item/post-item-template.wxss&quot;;
</code></pre>
<p>11、数据文件要让外部使用，需要在里面自定义一个接口，暴露出去，如下：</p>
<pre><code class="language-javascript">module.exports = {
  postList: local_database
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[附件上传至FTP和从FTP下载的代码]]></title>
        <id>https://skytotwo.github.io//post/upload-or-download-ftp</id>
        <link href="https://skytotwo.github.io//post/upload-or-download-ftp">
        </link>
        <updated>2019-08-05T03:42:49.000Z</updated>
        <summary type="html"><![CDATA[<p>之前用java做过福建上传ftp和从ftp下载文件的功能，这里做一下记录。</p>
]]></summary>
        <content type="html"><![CDATA[<p>之前用java做过福建上传ftp和从ftp下载文件的功能，这里做一下记录。</p>
<!-- more -->
<p>/<em><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>以下为附件上传至FTP和从FTP下载的代码</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>*****************************/</p>
<pre><code class="language-java">
/**  
* Description: 向SFTP服务器上传文件  
* @param host FTP服务器hostname  
* @param port FTP服务器端口  
* @param username FTP登录账号  
* @param password FTP登录密码  
* @param basePath FTP服务器基础目录 
* @param filePath FTP服务器文件存放路径。例如分日期存放：/2015/01/01。文件的路径为
* basePath+filePath 
* @param filename 上传到FTP服务器上的文件名  
* @param input 输入流  
* @return 成功返回true，否则返回false  
* @throws Exception 
* @author jolly	2017-12-1
*/    
public static boolean uploadFileToSFTP(String filename, HttpServletRequest request) throws Exception {  
	boolean result = false;  
	FTPClient ftp = new FTPClient();  
	Properties prop = new Properties();
	ResourceBundle resource = ResourceBundle
		.getBundle(&quot;tellhow/actions/ftp&quot;);// 读取ftp配置文件
	String host = resource.getString(&quot;HOST&quot;);
	int port = Integer.parseInt(resource.getString(&quot;PORT&quot;));
	String username = resource.getString(&quot;USERNAME&quot;);
	String password = resource.getString(&quot;PASSWORD&quot;);
	String filePath = resource.getString(&quot;FILEPATH&quot;);
	String localPath = request.getRealPath(&quot;/WebRoot/WEB-INF/upload/&quot;);
	try {  
		int reply;  
		ftp.connect(host, port);// 连接FTP服务器  
		// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器  
		boolean b = ftp.login(username, password);// 登录  
		if(!b){
			throw new Exception(&quot;登陆FTP不成功！&quot;);
		}
		reply = ftp.getReplyCode();  
		if (!FTPReply.isPositiveCompletion(reply)) {  
			ftp.disconnect();  
			return result;  
		}  
		File file = new File(localPath+filename);
		InputStream input = new FileInputStream(file);
		boolean t = ftp.changeWorkingDirectory(encoding(filePath));
		if(!t){
			ftp.mkd(encoding(filePath));
			ftp.changeWorkingDirectory(encoding(filePath));
		}
		//设置上传文件的类型为二进制类型  
		//ftp.setFileType(FTP.BINARY_FILE_TYPE);  
		boolean b2 = ftp.storeFile(encoding(filename), input);
		input.close();
		ftp.logout();
		if(!b2){
			throw new Exception(&quot;上传文件不成功！&quot;); 
		}
		result = true;  
	} catch (IOException e) {  
		e.printStackTrace();  
		throw new Exception(&quot;未能连接上Ftp服务器！&quot;);
	} finally {  
		if (ftp.isConnected()) {  
			try {  
				ftp.disconnect();  
			} catch (IOException ioe) {  
			}  
		} 
	}  
	return result;  
}  

/**  
* Description: 从FTP服务器下载文件  
* @param host FTP服务器hostname  
* @param port FTP服务器端口  
* @param username FTP登录账号  
* @param password FTP登录密码  
* @param remotePath FTP服务器上的相对路径  
* @param fileName 要下载的文件名  
* @param localPath 下载后保存到本地的路径  
* @return  
* @author jolly	2017-12-1
* @throws Exception 
*/    
public static boolean downloadFileFromFTP(String fileName, HttpServletRequest request) throws Exception {  
	boolean result = false;  
	FTPClient ftp = new FTPClient();  
	Properties prop = new Properties();
	ResourceBundle resource = ResourceBundle
		.getBundle(&quot;tellhow/actions/ftp&quot;);// 读取ftp配置文件
	String host = resource.getString(&quot;host&quot;);
	int port = Integer.parseInt(resource.getString(&quot;PORT&quot;));
	String username = resource.getString(&quot;USERNAME&quot;);
	String password = resource.getString(&quot;PASSWORD&quot;);
	String basePath = resource.getString(&quot;BASEPATH&quot;);
	String filePath = resource.getString(&quot;FILEPATH&quot;);
	String remotePath = resource.getString(&quot;REMOTEPATH&quot;);
	String localPath = request.getRealPath(&quot;/WebRoot/WEB-INF/upload&quot;);
	try {  
		int reply;  
		ftp.connect(host, port);  
		// 如果采用默认端口，可以使用ftp.connect(host)的方式直接连接FTP服务器  
		boolean b = ftp.login(username, password);// 登录  
		if(!b){
			throw new Exception(&quot;登陆FTP不成功！&quot;);
		}
		reply = ftp.getReplyCode();  
		if (!FTPReply.isPositiveCompletion(reply)) {  
			ftp.disconnect();  
			return result;  
		}  
		ftp.changeWorkingDirectory(remotePath);// 转移到FTP服务器目录  
		FTPFile[] fs = ftp.listFiles();  
		for (FTPFile ff : fs) {  
			if (ff.getName().equals(fileName)) {  
				File localFile = new File(localPath + &quot;/&quot; + ff.getName());  

				OutputStream is = new FileOutputStream(localFile);  
				ftp.retrieveFile(ff.getName(), is);  
				is.close();  
			}  
		}  

		ftp.logout();  
		result = true;  
	} catch (IOException e) {  
		e.printStackTrace();  
	} finally {  
		if (ftp.isConnected()) {  
			try {  
				ftp.disconnect();  
			} catch (IOException ioe) {  
			}  
		}  
	}  
	return result;  
} 


/**
* 编码转换
* @param obj
* @return
*/
private static String encoding(Object obj){
	try{
		if(obj==null)
			return &quot;&quot;;
		else
			return new String(obj.toString().getBytes(&quot;GBK&quot;),&quot;ISO-8859-1&quot;);
	}catch(Exception e){
		e.printStackTrace();
	}
	return &quot;&quot;; 
}

//删除文件，用于ftp上传完后删除本地临时文件夹文件
public void delFolder(String folderPath) {
	try {
		delAllFile(folderPath); // 删除完里面所有内容
	} catch (Exception e) {
		e.printStackTrace();
	}
}
// 删除指定文件夹下所有文件
// param path 文件夹完整绝对路径
public boolean delAllFile(String path) {
	boolean flag = false;
	File file = new File(path);
	if (!file.exists()) {
		return flag;
	}
	if (!file.isDirectory()) {
		return flag;
	}
	String[] tempList = file.list();
	File temp = null;
	for (int i = 0; i &lt; tempList.length; i++) {
		if (path.endsWith(File.separator)) {
			temp = new File(path + tempList[i]);
		} else {
			temp = new File(path + File.separator + tempList[i]);
		}
		if (temp.isFile()) {
			temp.delete();
		}
		if (temp.isDirectory()) {
			delAllFile(path + &quot;/&quot; + tempList[i]);// 先删除文件夹里面的文件
			flag = true;
		}
	}
	return flag;
}

public class SFTPConstants {
	public static final String SFTP_REQ_HOST = &quot;host&quot;;
	public static final String SFTP_REQ_PORT = &quot;port&quot;;
	public static final String SFTP_REQ_USERNAME = &quot;username&quot;;
	public static final String SFTP_REQ_PASSWORD = &quot;password&quot;;
	public static final int SFTP_DEFAULT_PORT = 22;
	public static final String SFTP_REQ_LOC = &quot;location&quot;;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[js代码判断浏览器种类]]></title>
        <id>https://skytotwo.github.io//post/js-check-browser</id>
        <link href="https://skytotwo.github.io//post/js-check-browser">
        </link>
        <updated>2019-08-05T03:38:17.000Z</updated>
        <summary type="html"><![CDATA[<p>很多时候，前端需要对当前浏览器类型进行判断，进而触发不同的操作，这里使用js代码对浏览器的种类进行判断。</p>
]]></summary>
        <content type="html"><![CDATA[<p>很多时候，前端需要对当前浏览器类型进行判断，进而触发不同的操作，这里使用js代码对浏览器的种类进行判断。</p>
<!-- more -->
<p>第一种，只区分浏览器，不考虑版本<br>
复制代码 代码如下:</p>
<pre><code class="language-javascript">function myBrowser(){
    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
    var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1;
    if (isOpera) {
        return &quot;Opera&quot;
    }; //判断是否Opera浏览器
    if (userAgent.indexOf(&quot;Firefox&quot;) &gt; -1) {
        return &quot;FF&quot;;
    } //判断是否Firefox浏览器
    if (userAgent.indexOf(&quot;Chrome&quot;) &gt; -1){
  		return &quot;Chrome&quot;;
 	}
    if (userAgent.indexOf(&quot;Safari&quot;) &gt; -1) {
        return &quot;Safari&quot;;
    } //判断是否Safari浏览器
    if (userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera) {
        return &quot;IE&quot;;
    }; //判断是否IE浏览器
}
</code></pre>
<p>//以下是调用上面的函数</p>
<pre><code class="language-javascript">var mb = myBrowser();
if (&quot;IE&quot; == mb) {
    alert(&quot;我是 IE&quot;);
}
if (&quot;FF&quot; == mb) {
    alert(&quot;我是 Firefox&quot;);
}
if (&quot;Chrome&quot; == mb) {
    alert(&quot;我是 Chrome&quot;);
}
if (&quot;Opera&quot; == mb) {
    alert(&quot;我是 Opera&quot;);
}
if (&quot;Safari&quot; == mb) {
    alert(&quot;我是 Safari&quot;);
}
</code></pre>
<p>第二种，区分浏览器，并考虑IE5.5 6 7 8<br>
复制代码 代码如下:</p>
<pre><code class="language-javascript">function myBrowser(){
    var userAgent = navigator.userAgent; //取得浏览器的userAgent字符串
    var isOpera = userAgent.indexOf(&quot;Opera&quot;) &gt; -1; //判断是否Opera浏览器
    var isIE = userAgent.indexOf(&quot;compatible&quot;) &gt; -1 &amp;&amp; userAgent.indexOf(&quot;MSIE&quot;) &gt; -1 &amp;&amp; !isOpera; //判断是否IE浏览器
    var isFF = userAgent.indexOf(&quot;Firefox&quot;) &gt; -1; //判断是否Firefox浏览器
    var isSafari = userAgent.indexOf(&quot;Safari&quot;) &gt; -1; //判断是否Safari浏览器
    if (isIE) {
        var IE5 = IE55 = IE6 = IE7 = IE8 = false;
        var reIE = new RegExp(&quot;MSIE (\\d+\\.\\d+);&quot;);
        reIE.test(userAgent);
        var fIEVersion = parseFloat(RegExp[&quot;$1&quot;]);
        IE55 = fIEVersion == 5.5;
        IE6 = fIEVersion == 6.0;
        IE7 = fIEVersion == 7.0;
        IE8 = fIEVersion == 8.0;
        if (IE55) {
            return &quot;IE55&quot;;
        }
        if (IE6) {
            return &quot;IE6&quot;;
        }
        if (IE7) {
            return &quot;IE7&quot;;
        }
        if (IE8) {
            return &quot;IE8&quot;;
        }
    }//isIE end
    if (isFF) {
        return &quot;FF&quot;;
    }
    if (isOpera) {
        return &quot;Opera&quot;;
    }
}//myBrowser() end
</code></pre>
<p>//以下是调用上面的函数</p>
<pre><code class="language-javascript">if (myBrowser() == &quot;FF&quot;) {
    alert(&quot;我是 Firefox&quot;);
}
if (myBrowser() == &quot;Opera&quot;) {
    alert(&quot;我是 Opera&quot;);
}
if (myBrowser() == &quot;Safari&quot;) {
    alert(&quot;我是 Safari&quot;);
}
if (myBrowser() == &quot;IE55&quot;) {
    alert(&quot;我是 IE5.5&quot;);
}
if (myBrowser() == &quot;IE6&quot;) {
    alert(&quot;我是 IE6&quot;);
}
if (myBrowser() == &quot;IE7&quot;) {
    alert(&quot;我是 IE7&quot;);
}
if (myBrowser() == &quot;IE8&quot;) {
    alert(&quot;我是 IE8&quot;);
}
</code></pre>
<p>下面给出一个判断当前浏览器是IE的JS代码.<br>
原理是利用了IE与标准浏览器在处理数组的toString方法的差异做成的。对于标准游览器，如果数组里面最后一个字符为逗号，JS引擎会自动剔除它。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[jsp实现导出word文档]]></title>
        <id>https://skytotwo.github.io//post/jsp-word-config</id>
        <link href="https://skytotwo.github.io//post/jsp-word-config">
        </link>
        <updated>2019-08-05T03:33:18.000Z</updated>
        <summary type="html"><![CDATA[<p>java中除了使用常规的库来实现到处word，excel外，可以在jsp里配置实现导出效果，实际上效果是一致的，这里记录下相关的配置。</p>
]]></summary>
        <content type="html"><![CDATA[<p>java中除了使用常规的库来实现到处word，excel外，可以在jsp里配置实现导出效果，实际上效果是一致的，这里记录下相关的配置。</p>
<!-- more -->
<p>1、设置response</p>
<pre><code class="language-javascript">response.setContentType(&quot;application/vnd.ms-word; charset=UTF-8&quot;);
response.setHeader(&quot;Pragma&quot;,&quot;No-Cache&quot;);
response.setHeader(&quot;Cache-Control&quot;,&quot;No-Cache&quot;);
response.setHeader(&quot;Content-disposition&quot;,&quot;attachment; filename=&quot;+URLEncoder.encode(nc+&quot;(&quot;+bh+&quot;)&quot;, &quot;UTF-8&quot;)+&quot;.doc&quot;);
</code></pre>
<p>2、html指定word</p>
<pre><code class="language-javascript">&lt;html  xmlns:w='urn:schemas-microsoft-com:office:word' &gt;
</code></pre>
<p>3、head里添加配置文件</p>
<pre><code class="language-xml">&lt;xml&gt;  
    &lt;w:WordDocument&gt;  
      &lt;w:View&gt;Print&lt;/w:View&gt;  
      &lt;w:DoNotOptimizeForBrowser/&gt;  
      &lt;w:Compatibility&gt;  
        &lt;w:DontGrowAutofit/&gt;  
      &lt;/w:Compatibility&gt;  
    &lt;/w:WordDocument&gt;  
&lt;/xml&gt; 
</code></pre>
<p>4、导出</p>
<pre><code class="language-javascript">$(&quot;table&quot;).attr(&quot;border&quot;,'0');
	window.print();
</code></pre>
]]></content>
    </entry>
</feed>