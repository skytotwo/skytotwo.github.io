<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://skytotwo.github.io/</id>
    <title>Totoro の Home</title>
    <updated>2019-06-16T10:31:22.981Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://skytotwo.github.io/"/>
    <link rel="self" href="https://skytotwo.github.io//atom.xml"/>
    <subtitle>空杯心态，每天进步</subtitle>
    <logo>https://skytotwo.github.io//images/avatar.png</logo>
    <icon>https://skytotwo.github.io//favicon.ico</icon>
    <rights>All rights reserved 2019, Totoro の Home</rights>
    <entry>
        <title type="html"><![CDATA[Django settings.py 的media路径设置]]></title>
        <id>https://skytotwo.github.io//post/django-settings-meida-lujing</id>
        <link href="https://skytotwo.github.io//post/django-settings-meida-lujing">
        </link>
        <updated>2019-06-16T08:45:56.000Z</updated>
        <summary type="html"><![CDATA[<p>Django对media等静态文件的路径配置有自己的一套，在settings和url里面都有对应配置，这里简单做一下介绍。</p>
]]></summary>
        <content type="html"><![CDATA[<p>Django对media等静态文件的路径配置有自己的一套，在settings和url里面都有对应配置，这里简单做一下介绍。</p>
<!--more-->
<p>在一个 models 中使用 FileField 或 ImageField 需要以下步骤:</p>
<ol>
<li>
<p>在你的 settings 文件中, 定义一个完整路径给MEDIA_ROOT 以便让 Django在此处保存上传文件. (出于性能考虑,这些文件并不保存到数据库.) 定义MEDIA_URL 作为该目录的公共 URL. 要确保该目录对 WEB 服务器用户帐号是可写的.</p>
</li>
<li>
<p>在你的 models.py 中添加 FileField 或 ImageField, 并确保定义了upload_to 选项,以告诉 Django 使用MEDIA_ROOT 的哪个子目录保存上传文件.</p>
</li>
<li>
<p>你的数据库中要保存的只是文件的路径(相对于 MEDIA_ROOT)，要想得到这个文件的路径可以用&quot;.url&quot;方法。例如，如果models里有一个取名为&quot;photo&quot;的ImageField，可以在Html模板里通过双花括号加object.photo.url得到该图片的路径。</p>
</li>
</ol>
<p>settings.py 设置</p>
<p>媒体文件的绝对路径：</p>
<pre><code class="language-python"># Absolute path to the directory that holds media.
# Example: &quot;/home/media/media.lawrence.com/&quot;   
MEDIA_ROOT = 'D:/Python26/Lib/site-packages/django/bin/newproj/media'
</code></pre>
<p>媒体文件的相对路径：</p>
<pre><code class="language-python"># URL that handles the media served from MEDIA_ROOT.
# Example: &quot;http://media.lawrence.com&quot;
MEDIA_URL = '/site_media/' 
</code></pre>
<p>设置静态文件路径</p>
<pre><code class="language-python">STATIC_PATH = 'D:/Python26/Lib/site-packages/django/bin/newproj/media'
</code></pre>
<p>urls.py 影射路径</p>
<pre><code class="language-python">(r'^site_media/(?P&lt;path&gt;.*)$', 'django.views.static.serve',{'document_root': settings.STATIC_PATH}),
</code></pre>
<p>将 MEDIA_URL 的site_media 影射到 settings.STATIC_PATH</p>
<p>models.py 上传图片字段设置</p>
<pre><code class="language-python">photo = models.ImageField('上传图片',upload_to='photos')
</code></pre>
<p>相当于传到 D:/Python26/Lib/site-packages/django/bin/newproj/media/photos 目录下，浏览时通过/site_media/photos/ 访问。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[django drf实现第三方登录]]></title>
        <id>https://skytotwo.github.io//post/django-drf-disanfang</id>
        <link href="https://skytotwo.github.io//post/django-drf-disanfang">
        </link>
        <updated>2019-06-16T08:19:48.000Z</updated>
        <summary type="html"><![CDATA[<p>对于现在的网站来说，第三方登陆可以说是一个常用的设计了，通过授权来实现诸如qq，微信，微博等第三方平台的第三方登陆。而对于Django的drf来说，也是可以很好的嵌入第三方登陆模块的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>对于现在的网站来说，第三方登陆可以说是一个常用的设计了，通过授权来实现诸如qq，微信，微博等第三方平台的第三方登陆。而对于Django的drf来说，也是可以很好的嵌入第三方登陆模块的。</p>
<!--more-->
<p>第三方登录都是采用OAuth2.0规范来实现的，基本流程是：</p>
<p>1、注册相关平台的开放平台的开发者账号，从而可以新建应用来开发调试。比如说微博就是在微博开放平台；微信就是在微信开放平台，QQ就是在QQ互联。</p>
<p>2、注册完账号后就可以在相关平台注册应用了。注册应用会得到appkey和appsecrt，这是必要的两个参数，以qq为例：</p>
<ul>
<li>（1）、第一步是获取Authorization Code，通过访问文档定义的接口，传递相关必要参数如appkey和appsectrt参数，拼接参数至url，用get方式访问url。</li>
<li>（2）、第二步是会跳转至第三方登陆页面，输入账号密码登陆成功后，会重定向至预设的redirect_url，并传递回Authorization Code</li>
<li>（2）、第三步是用Authorization Code获取到Access Token，当页面重定向至设定的重定向url后（通常是网站首页），即可以调用某个接口访问第三方的接口，拼接url传入Authorization Code获取到Access Token，通过Access Token可以获取到用户信息，随后进行注册等操作。</li>
</ul>
<p>drf实现第三方登录可以使用现成的框架，如github上的social—app—django，http://python-social-auth.readthedocs.io/en/latest/。</p>
<p><strong>一般设置步骤是：</strong></p>
<ol>
<li>
<p>安装框架
pip install social-auth-app-django，安装的时候会附带安装一些依赖，比如social-core等，而框架也是基于social-core开发的。</p>
</li>
<li>
<p>在settings的INSTALLED_APPS中注册
INSTALLED_APPS = [
。。。。。
'social_django',
]</p>
</li>
<li>
<p>在setting文件的DATABASES中设置数据库引擎，因为第三方登录需要的是innodb，这样做后面的migration才不会出错。</p>
</li>
</ol>
<pre><code class="language-python">DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': &quot;mxshop&quot;,
        'USER': 'root',
        'PASSWORD': '123456',
        'HOST': '127.0.0.1',
        'OPTIONS': {'init_command' : 'SET default_storage_engine=INNODB;'}
    }
}
</code></pre>
<ol start="4">
<li>
<p>执行migrate，需要生成三个表，而不需要makemigration的原因是在安装的social_django中已经有了ini文件，可以直接进行migrate操作生成表。</p>
</li>
<li>
<p>在setting的AUTHENTICATION_BACKENDS中配置：</p>
</li>
</ol>
<pre><code class="language-python">AUTHENTICATION_BACKENDS = (
   'social_core.backends.qq.QQOAuth2',
    'social_core.backends.weibo.WeiboOAuth2',
    'social_core.backends.weixin.WeixinOAuth2',
    'django.contrib.auth.backends.ModelBackend',
    ...
)
</code></pre>
<p>其中的qq、weibo和微信名称都是在'social_core.backends中有定义的。</p>
<ol start="6">
<li>配置TEMPLATES</li>
</ol>
<pre><code class="language-python">TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [os.path.join(BASE_DIR, 'templates')]
        ,
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
               。。。。。。
                'social_django.context_processors.backends', #第三方登录
                'social_django.context_processors.login_redirect', #第三方登录重定向
            ],
        },
    },
]
</code></pre>
<ol start="7">
<li>在urls的urlpatterns中添加访问url，该url会封装了两个url，一个是登录至第三方平台，并且传回Authorization Code回来，第二个是用code去获取Access Token拿到用户信息，然后返回本系统，如果本系统登陆了的话就会将第三方平台的账号与已登录的账号做个绑定，如果没有登录则会用第三方返回的信息在本系统生成一个账号，并完成登录。</li>
</ol>
<pre><code class="language-python">urlpatterns = [
。。。。。。
     #第三方登录url
     url('', include('social_django.urls', namespace='social')),
]
</code></pre>
<ol start="8">
<li>
<p>注意两点：
（1）、如果url中之前配置过login的url，如jwt的模式
url(r'^login/<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo mathvariant="normal">′</mo></msup><mo separator="true">,</mo><mi>o</mi><mi>b</mi><mi>t</mi><mi>a</mi><mi>i</mi><msub><mi>n</mi><mi>j</mi></msub><mi>w</mi><msub><mi>t</mi><mi>t</mi></msub><mi>o</mi><mi>k</mi><mi>e</mi><mi>n</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mi mathvariant="normal">一</mi><mi mathvariant="normal">定</mi><mi mathvariant="normal">要</mi><mi mathvariant="normal">在</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>i</mi><mi>n</mi><mi mathvariant="normal">后</mi><mi mathvariant="normal">面</mi><mi mathvariant="normal">用</mi></mrow><annotation encoding="application/x-tex">&#x27;, obtain_jwt_token),
一定要在login后面用</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.038em;vertical-align:-0.286108em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">o</span><span class="mord mathdefault">b</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">i</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord"><span class="mord mathdefault">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord cjk_fallback">一</span><span class="mord cjk_fallback">定</span><span class="mord cjk_fallback">要</span><span class="mord cjk_fallback">在</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord cjk_fallback">后</span><span class="mord cjk_fallback">面</span><span class="mord cjk_fallback">用</span></span></span></span>终止，不然会与第三方登录的url的login方法混淆。
（2）、在拿到Acces Token并拿到相关信息后重定向的页面是在开放平台设置的redict_url，建议返回首页index，地址是本机的地址，也就是服务器的地址，不管是测试还是生产环境，不同于支付宝支付的返回，这里的是浏览器发起的重定向，并不会影响跳转。</p>
</li>
<li>
<p>在settings中配置第三方登录所需要的appkey和sppsecret
SOCIAL_AUTH_你的第三方名称（在social_core的backend中有）_KEY = 'appkey'
SOCIAL_AUTH_你的第三方名称（在social_core的backend中有）_SECRET = 'appsecret'</p>
</li>
<li>
<p>因为social_django是适用于django，获取信息返回后，返回的用户信息是给浏览器设置sessionid，但是drf的话，则是使用Token登录，这里则需要重写返回的方法，再返回的时候设置用户“name”和“token”，具体修改的代码位于socia_core的actions.py文件中的do_complete里，方法最后会将返回url，可以先将整个social_core拷贝至新建好的目录下。修改代码如下：</p>
</li>
</ol>
<pre><code class="language-python">from rest_framework_jwt.serializers import jwt_encode_handler, jwt_payload_handler

def do_complete(backend, login, user=None, redirect_name='next', *args, **kwargs):
	response = backend.strategy.redirect(url)
	payload = jwt_payload_handler(user)
	response.set_cookie(&quot;name&quot;, user.name if user.name else user.username, max_age=24*3600)
	response.set_cookie(&quot;token&quot;, jwt_encode_handler(payload))
	return response
</code></pre>
<p>特别需要注意的是cookie一定要设置过期时间，如上所示。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[asyncio 简介]]></title>
        <id>https://skytotwo.github.io//post/asyncio-jian-jie</id>
        <link href="https://skytotwo.github.io//post/asyncio-jian-jie">
        </link>
        <updated>2019-06-14T13:30:12.000Z</updated>
        <summary type="html"><![CDATA[<p>一直对asyncio这个库比较感兴趣，毕竟这是官网也非常推荐的一个实现高并发的一个模块，python也是在python 3.4中引入了协程的概念。也通过这次整理更加深刻理解这个模块的使用</p>
]]></summary>
        <content type="html"><![CDATA[<p>一直对asyncio这个库比较感兴趣，毕竟这是官网也非常推荐的一个实现高并发的一个模块，python也是在python 3.4中引入了协程的概念。也通过这次整理更加深刻理解这个模块的使用</p>
<!--more-->
<h3 id="asyncio-是干什么的">asyncio 是干什么的？</h3>
<h4 id="异步网络操作">异步网络操作</h4>
<ul>
<li>并发</li>
<li>协程</li>
</ul>
<p>python3.0时代，标准库里的异步网络模块：select(非常底层) python3.0时代，第三方异步网络库：Tornado python3.4时代，asyncio：支持TCP,子进程。</p>
<p>现在的asyncio，有了很多的模块已经在支持：aiohttp,aiodns,aioredis等等 https://github.com/aio-libs 这里列出了已经支持的内容，并在持续更新</p>
<p>当然到目前为止实现协程的不仅仅只有asyncio,tornado和gevent都实现了类似功能</p>
<hr>
<p><strong>关于asyncio的一些关键字的说明：</strong></p>
<ul>
<li>
<p>event_loop 事件循环：程序开启一个无限循环，把一些函数注册到事件循环上，当满足事件发生的时候，调用相应的协程函数</p>
</li>
<li>
<p>coroutine 协程：协程对象，指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用。</p>
</li>
<li>
<p>task 任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含了任务的各种状态</p>
</li>
<li>
<p>future: 代表将来执行或没有执行的任务的结果。它和task上没有本质上的区别</p>
</li>
<li>
<p>async/await 关键字：python3.5用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口。</p>
</li>
</ul>
<p>看了上面这些关键字，你可能扭头就走了，其实一开始了解和研究asyncio这个模块有种抵触，自己也不知道为啥，这也导致很长一段时间，这个模块自己也基本就没有关注和使用，但是随着工作上用python遇到各种性能问题的时候，自己告诉自己还是要好好学习学习这个模块。</p>
<hr>
<h4 id="定义一个协程"><strong>定义一个协程</strong></h4>
<pre><code class="language-python">import time
import asyncio


now = lambda : time.time()


async def do_some_work(x):
    print(&quot;waiting:&quot;, x)

start = now()
# 这里是一个协程对象，这个时候do_some_work函数并没有执行
coroutine = do_some_work(2)
print(coroutine)
#  创建一个事件loop
loop = asyncio.get_event_loop()
# 将协程加入到事件循环loop
loop.run_until_complete(coroutine)

print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>在上面带中我们通过async关键字定义一个协程（coroutine）,当然协程不能直接运行，需要将协程加入到事件循环loop中</p>
<p>**asyncio.get_event_loop：**创建一个事件循环，然后使用run_until_complete将协程注册到事件循环，并启动事件循环</p>
<hr>
<h4 id="创建一个task"><strong>创建一个task</strong></h4>
<p>协程对象不能直接运行，在注册事件循环的时候，其实是run_until_complete方法将协程包装成为了一个任务（task）对象. task对象是Future类的子类，保存了协程运行后的状态，用于未来获取协程的结果</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()


async def do_some_work(x):
    print(&quot;waiting:&quot;, x)

start = now()

coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = loop.create_task(coroutine)
print(task)
loop.run_until_complete(task)
print(task)
print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>结果为：</p>
<pre><code class="language-python">&lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex2.py:13&gt;&gt;
waiting: 2
&lt;Task finished coro=&lt;do_some_work() done, defined at /app/py_code/study_asyncio/simple_ex2.py:13&gt; result=None&gt;
Time: 0.0003514289855957031
</code></pre>
<p>创建task后，在task加入事件循环之前为pending状态，当完成后，状态为finished</p>
<p>关于上面通过loop.create_task(coroutine)创建task,同样的可以通过 asyncio.ensure_future(coroutine)创建task</p>
<p>关于这两个命令的官网解释： https://docs.python.org/3/library/asyncio-task.html#asyncio.ensure_future</p>
<pre><code class="language-python">asyncio.ensure_future(coro_or_future, *, loop=None)
Schedule the execution of a coroutine object: wrap it in a future. Return a Task object.

If the argument is a Future, it is returned directly.
</code></pre>
<p>https://docs.python.org/3/library/asyncio-eventloop.html#asyncio.AbstractEventLoop.create_task</p>
<pre><code class="language-python">AbstractEventLoop.create_task(coro)
Schedule the execution of a coroutine object: wrap it in a future. Return a Task object.

Third-party event loops can use their own subclass of Task for interoperability. In this case, the result type is a subclass of Task.

This method was added in Python 3.4.2. Use the async() function to support also older Python versions
</code></pre>
<hr>
<h4 id="绑定回调"><strong>绑定回调</strong></h4>
<p>绑定回调，在task执行完成的时候可以获取执行的结果，回调的最后一个参数是future对象，通过该对象可以获取协程返回值。</p>
<pre><code class="language-python">import time
import asyncio


now = lambda : time.time()


async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    return &quot;Done after {}s&quot;.format(x)


def callback(future):
    print(&quot;callback:&quot;,future.result())


start = now()
coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(coroutine)
print(task)
task.add_done_callback(callback)
print(task)
loop.run_until_complete(task)

print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>结果为：</p>
<pre><code class="language-python">&lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex3.py:13&gt;&gt;
&lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex3.py:13&gt; cb=[callback() at /app/py_code/study_asyncio/simple_ex3.py:18]&gt;
waiting: 2
callback: Done after 2s
Time: 0.00039196014404296875
</code></pre>
<p>通过add_done_callback方法给task任务添加回调函数，当task（也可以说是coroutine）执行完成的时候,就会调用回调函数。并通过参数future获取协程执行的结果。这里我们创建 的task和回调里的future对象实际上是同一个对象</p>
<hr>
<h4 id="阻塞和await"><strong>阻塞和await</strong></h4>
<p>使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行</p>
<p>耗时的操作一般是一些IO操作，例如网络请求，文件读取等。我们使用asyncio.sleep函数来模拟IO操作。协程的目的也是让这些IO操作异步化。</p>
<pre><code class="language-python">import asyncio
import time



now = lambda :time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    # await 后面就是调用耗时的操作
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)


start = now()

coroutine = do_some_work(2)
loop = asyncio.get_event_loop()
task = asyncio.ensure_future(coroutine)
loop.run_until_complete(task)

print(&quot;Task ret:&quot;, task.result())
print(&quot;Time:&quot;, now() - start)
</code></pre>
<p>在await asyncio.sleep(x)，因为这里sleep了，模拟了阻塞或者耗时操作，这个时候就会让出控制权。 即当遇到阻塞调用的函数的时候，使用await方法将协程的控制权让出,以便loop调用其他的协程。</p>
<hr>
<h4 id="并发和并行"><strong>并发和并行</strong></h4>
<ul>
<li>
<p>并发：指的是一段时间内执行多想任务</p>
</li>
<li>
<p>并行：指的是用同一个时间点执行多个任务。</p>
</li>
</ul>
<p>下面这个例子非常形象：</p>
<p>并发情况下是一个老师在同一时间段辅助不同的人功课。并行则是好几个老师分别同时辅助多个学生功课。简而言之就是一个人同时吃三个馒头还是三个人同时分别吃一个的情况，吃一个馒头算一个任务</p>
<pre><code class="language-python">import asyncio
import time


now = lambda :time.time()


async def do_some_work(x):
    print(&quot;Waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

start = now()

coroutine1 = do_some_work(1)
coroutine2 = do_some_work(2)
coroutine3 = do_some_work(4)

tasks = [
    asyncio.ensure_future(coroutine1),
    asyncio.ensure_future(coroutine2),
    asyncio.ensure_future(coroutine3)
]

loop = asyncio.get_event_loop()
loop.run_until_complete(asyncio.wait(tasks))

for task in tasks:
    print(&quot;Task ret:&quot;,task.result())

print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>运行结果：</p>
<pre><code class="language-python">Waiting: 1
Waiting: 2
Waiting: 4
Task ret: Done after 1s
Task ret: Done after 2s
Task ret: Done after 4s
Time: 4.004154920578003
</code></pre>
<p>总时间为4s左右。4s的阻塞时间，足够前面两个协程执行完毕。如果是同步顺序的任务，那么至少需要7s。此时我们使用了aysncio实现了并发。asyncio.wait(tasks) 也可以使用 asyncio.gather(*tasks) ,前者接受一个task列表，后者接收一堆task。</p>
<p>关于asyncio.gather和asyncio.wait官网的说明：</p>
<p>https://docs.python.org/3/library/asyncio-task.html#asyncio.gather</p>
<pre><code class="language-python">Return a future aggregating results from the given coroutine objects or futures.

All futures must share the same event loop. If all the tasks are done successfully, the returned future’s result is the list of results (in the order of the original sequence, not necessarily the order of results arrival). If return_exceptions is true, exceptions in the tasks are treated the same as successful results, and gathered in the result list; otherwise, the first raised exception will be immediately propagated to the returned future.
</code></pre>
<p>https://docs.python.org/3/library/asyncio-task.html#asyncio.wait</p>
<pre><code class="language-python">Wait for the Futures and coroutine objects given by the sequence futures to complete. Coroutines will be wrapped in Tasks. Returns two sets of Future: (done, pending).

The sequence futures must not be empty.

timeout can be used to control the maximum number of seconds to wait before returning. timeout can be an int or float. If timeout is not specified or None, there is no limit to the wait time.

return_when indicates when this function should return.
</code></pre>
<hr>
<h4 id="协程嵌套"><strong>协程嵌套</strong></h4>
<p>使用async可以定义协程，协程用于耗时的io操作，我们也可以封装更多的io操作过程，这样就实现了嵌套的协程，即一个协程中await了另外一个协程，如此连接起来。</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]

    dones, pendings = await asyncio.wait(tasks)
    for task in dones:
        print(&quot;Task ret:&quot;, task.result())

    # results = await asyncio.gather(*tasks)
    # for result in results:
    #     print(&quot;Task ret:&quot;,result)


start = now()

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>如果我们把上面代码中的：</p>
<pre><code class="language-python">    dones, pendings = await asyncio.wait(tasks)
    for task in dones:
        print(&quot;Task ret:&quot;, task.result())
</code></pre>
<p>替换为：</p>
<pre><code class="language-python">results = await asyncio.gather(*tasks)
 for result in results:
     print(&quot;Task ret:&quot;,result)
</code></pre>
<p>这样得到的就是一个结果的列表</p>
<p>不在main协程函数里处理结果，直接返回await的内容，那么最外层的run_until_complete将会返回main协程的结果。 将上述的代码更改为：</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    return await asyncio.gather(*tasks)

start = now()

loop = asyncio.get_event_loop()
results = loop.run_until_complete(main())
for result in results:
    print(&quot;Task ret:&quot;,result)

print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>或者返回使用asyncio.wait方式挂起协程。</p>
<p>将代码更改为：</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    return await asyncio.wait(tasks)

start = now()

loop = asyncio.get_event_loop()
done,pending = loop.run_until_complete(main())
for task in done:
    print(&quot;Task ret:&quot;,task.result())

print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>也可以使用asyncio的as_completed方法</p>
<pre><code class="language-python">import asyncio
import time


now = lambda: time.time()

async def do_some_work(x):
    print(&quot;waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

async def main():
    coroutine1 = do_some_work(1)
    coroutine2 = do_some_work(2)
    coroutine3 = do_some_work(4)
    tasks = [
        asyncio.ensure_future(coroutine1),
        asyncio.ensure_future(coroutine2),
        asyncio.ensure_future(coroutine3)
    ]
    for task in asyncio.as_completed(tasks):
        result = await task
        print(&quot;Task ret: {}&quot;.format(result))

start = now()

loop = asyncio.get_event_loop()
loop.run_until_complete(main())
print(&quot;Time:&quot;, now()-start)
</code></pre>
<p>从上面也可以看出，协程的调用和组合非常灵活，主要体现在对于结果的处理：如何返回，如何挂起</p>
<hr>
<h4 id="协程的停止"><strong>协程的停止</strong></h4>
<p>future对象有几个状态：</p>
<ul>
<li>Pending</li>
<li>Running</li>
<li>Done</li>
<li>Cacelled
创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done，如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task</li>
</ul>
<pre><code class="language-python">import asyncio
import time


now = lambda :time.time()


async def do_some_work(x):
    print(&quot;Waiting:&quot;,x)
    await asyncio.sleep(x)
    return &quot;Done after {}s&quot;.format(x)

coroutine1 =do_some_work(1)
coroutine2 =do_some_work(2)
coroutine3 =do_some_work(2)

tasks = [
    asyncio.ensure_future(coroutine1),
    asyncio.ensure_future(coroutine2),
    asyncio.ensure_future(coroutine3),
]

start = now()

loop = asyncio.get_event_loop()
try:
    loop.run_until_complete(asyncio.wait(tasks))
except KeyboardInterrupt as e:
    print(asyncio.Task.all_tasks())
    for task in asyncio.Task.all_tasks():
        print(task.cancel())
    loop.stop()
    loop.run_forever()
finally:
    loop.close()

print(&quot;Time:&quot;,now()-start)
</code></pre>
<p>启动事件循环之后，马上ctrl+c，会触发run_until_complete的执行异常 KeyBorardInterrupt。然后通过循环asyncio.Task取消future。可以看到输出如下：</p>
<pre><code class="language-python">Waiting: 1
Waiting: 2
Waiting: 2
^C{&lt;Task finished coro=&lt;do_some_work() done, defined at /app/py_code/study_asyncio/simple_ex10.py:13&gt; result='Done after 1s'&gt;, &lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex10.py:15&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /usr/local/lib/python3.5/asyncio/tasks.py:428]&gt;, &lt;Task pending coro=&lt;do_some_work() running at /app/py_code/study_asyncio/simple_ex10.py:15&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt; cb=[_wait.&lt;locals&gt;._on_completion() at /usr/local/lib/python3.5/asyncio/tasks.py:428]&gt;, &lt;Task pending coro=&lt;wait() running at /usr/local/lib/python3.5/asyncio/tasks.py:361&gt; wait_for=&lt;Future pending cb=[Task._wakeup()]&gt;&gt;}
False
True
True
True
Time: 1.0707225799560547
</code></pre>
<p>True表示cannel成功，loop stop之后还需要再次开启事件循环，最后在close，不然还会抛出异常</p>
<p>循环task，逐个cancel是一种方案，可是正如上面我们把task的列表封装在main函数中，main函数外进行事件循环的调用。这个时候，main相当于最外出的一个task，那么处理包装的main函数即可。</p>
<hr>
<h4 id="不同线程的事件循环"><strong>不同线程的事件循环</strong></h4>
<p>很多时候，我们的事件循环用于注册协程，而有的协程需要动态的添加到事件循环中。一个简单的方式就是使用多线程。当前线程创建一个事件循环，然后在新建一个线程，在新线程中启动事件循环。当前线程不会被block。</p>
<pre><code class="language-python">import asyncio
from threading import Thread
import time

now = lambda :time.time()

def start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

def more_work(x):
    print('More work {}'.format(x))
    time.sleep(x)
    print('Finished more work {}'.format(x))

start = now()
new_loop = asyncio.new_event_loop()
t = Thread(target=start_loop, args=(new_loop,))
t.start()
print('TIME: {}'.format(time.time() - start))

new_loop.call_soon_threadsafe(more_work, 6)
new_loop.call_soon_threadsafe(more_work, 3)
</code></pre>
<p>启动上述代码之后，当前线程不会被block，新线程中会按照顺序执行call_soon_threadsafe方法注册的more_work方法， 后者因为time.sleep操作是同步阻塞的，因此运行完毕more_work需要大致6 + 3</p>
<hr>
<h4 id="新线程协程"><strong>新线程协程</strong></h4>
<pre><code class="language-python">import asyncio
import time
from threading import Thread

now = lambda :time.time()


def start_loop(loop):
    asyncio.set_event_loop(loop)
    loop.run_forever()

async def do_some_work(x):
    print('Waiting {}'.format(x))
    await asyncio.sleep(x)
    print('Done after {}s'.format(x))

def more_work(x):
    print('More work {}'.format(x))
    time.sleep(x)
    print('Finished more work {}'.format(x))

start = now()
new_loop = asyncio.new_event_loop()
t = Thread(target=start_loop, args=(new_loop,))
t.start()
print('TIME: {}'.format(time.time() - start))

asyncio.run_coroutine_threadsafe(do_some_work(6), new_loop)
asyncio.run_coroutine_threadsafe(do_some_work(4), new_loop)
</code></pre>
<p>上述的例子，主线程中创建一个new_loop，然后在另外的子线程中开启一个无限事件循环。 主线程通过run_coroutine_threadsafe新注册协程对象。这样就能在子线程中进行事件循环的并发操作，同时主线程又不会被block。一共执行的时间大概在6s左右。</p>
]]></content>
    </entry>
</feed>